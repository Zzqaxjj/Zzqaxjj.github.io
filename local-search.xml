<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络/跨域</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/%E8%B7%A8%E5%9F%9F/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="跨域通信的方式"><a href="#跨域通信的方式" class="headerlink" title="跨域通信的方式"></a>跨域通信的方式</h3><ul><li>JSONP</li><li>CORS</li><li>Hash</li><li>postMessage</li><li>WebSoket</li></ul><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ul><li>端口相同</li><li>域名相同</li><li>协议相同</li></ul><p>例子：<code>http://www.example.com/dir/page.html</code> 这个网址，协议是<code>http</code>，域名是<code>www.example.com</code>，端口是<code>80</code></p><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<strong>是浏览器做的努力</strong></p><h3 id="同源策略限制范围"><a href="#同源策略限制范围" class="headerlink" title="同源策略限制范围"></a>同源策略限制范围</h3><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取<ul><li>DOM 无法获得</li><li>AJAX 请求不能发送</li></ul></li></ul><h3 id="CROS跨域资源请求"><a href="#CROS跨域资源请求" class="headerlink" title="CROS跨域资源请求"></a>CROS跨域资源请求</h3><p>CORS(Cross-origin resource sharing)跨域资源请求</p><p>浏览器在请求一个跨域资源的时候，如果是跨域的Ajax请求，他会在请求头中加一个<code>origin</code>字段，但他是不知道这个资源服务端是否允许跨域请求的。浏览器会发送到服务端，如果服务器返回的头中没有<code>&#39;Access-Control-Allow-Origin&#39;: &#39;对应网址或 * &#39;</code> 的话，那么浏览器就会把请求内容给忽略掉，并且在控制台报错</p><h3 id="CORS限制"><a href="#CORS限制" class="headerlink" title="CORS限制"></a>CORS限制</h3><p>允许的请求方法</p><ul><li>GET</li><li>POST </li><li>HEAD</li></ul><p>允许的Content-Type</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-ulencoded</li></ul><p>其他类型的请求方法和Content-Type需要通过<strong>预请求验证</strong>后然后才能发送</p><h3 id="CORS预请求"><a href="#CORS预请求" class="headerlink" title="CORS预请求"></a>CORS预请求</h3><p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求。</p><p>服务器在HTTP header中加入允许请求的方法和Content-Type后，其他指定的方法和Content-Type就可以成功请求了</p><pre><code>&#39;Access-Control-Allow-Headers&#39;: &#39;允许Content-Type&#39;&#39;Access-Control-Allow-Methods&#39;: &#39;允许的请求方法&#39;&#39;Access-Control-Max-Age&#39;: &#39;预请求允许其他方法和类型传输的时间&#39;</code></pre><h3 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h3><p>浏览器上虽然有同源限制，但是像 srcipt标签、link标签、img标签、iframe标签，这种<strong>在标签上通过src地址来加载一些内容的时候浏览器是允许进行跨域请求的</strong>。 </p><p>所以JSONP的原理就是：</p><ul><li>创建一个script标签，这个script标签的src就是请求的地址；</li><li>这个script标签插入到DOM中，浏览器就根据src地址访问服务器资源</li><li>返回的资源是一个文本，但是因为是在script标签中，浏览器会执行它</li><li>而这个文本恰好是函数调用的形式，即函数名（数据），浏览器会把它当作JS代码来执行即调用这个函数</li><li>只要提前约定好这个函数名，并且这个函数存在于window对象中，就可以把数据传递给处理函数。</li></ul><h3 id="Hash值跨域通信"><a href="#Hash值跨域通信" class="headerlink" title="Hash值跨域通信"></a>Hash值跨域通信</h3><p>背景：在页面A下提供iframe或frame嵌入了跨域的页面B</p><p>容器页面 -&gt; 嵌入页通信：</p><p>在A页面中改变B的url中的hash值，B不会刷新，但是B可以用过<code>window.onhashchange</code>事件监听到hash变化</p><h3 id="postMessage通信"><a href="#postMessage通信" class="headerlink" title="postMessage通信"></a>postMessage通信</h3><pre><code class="js">// 窗口A中window.postMessage(&#39;data&#39;, &#39;http://A.com&#39;);// 窗口B中window.addEventListener(&#39;message&#39;, function(event) {  console.log(event.origin);    // http://A.com  console.log(event.source);    // A 对象window引用  console.log(event.data);      // 数据})</code></pre><h3 id="WebSoket-跨域通信"><a href="#WebSoket-跨域通信" class="headerlink" title="WebSoket 跨域通信"></a>WebSoket 跨域通信</h3><pre><code class="js">var ws = new WebSocket(&#39;wss://echo.websoket.org&#39;) //这个是后端端口ws.onopen = function(evt) {  ws.send(&#39;some message&#39;)}ws.onmessage = function (evt) {  console.log(evt.data);}ws.onclose = function(evt){  console.log(&#39;连接关闭&#39;);}</code></pre><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。</p><p>只需要给页面添加 document.domain = ‘test.com’ 表示二级域名都相同就可以实现跨域</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/缓存</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/%E7%BC%93%E5%AD%98/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>参考链接：<a href="https://juejin.im/entry/5ad86c16f265da505a77dca4" target="_blank" rel="noopener">https://juejin.im/entry/5ad86c16f265da505a77dca4</a></p><h3 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img src="../img/http-cache.png" srcset="/img/loading.gif" alt=""></p><p>由上图我们可以知道：</p><ul><li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p></li><li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p></li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：</p><p><img src="../img/force-cache.png" srcset="/img/loading.gif" alt=""></p><p>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图</p><p><img src="../img/consult-cache.png" srcset="/img/loading.gif" alt=""></p><p>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图</p><p><img src="../img/force-cache-use.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>那么强制缓存的缓存规则是什么？</p></blockquote><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><blockquote><p>Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？</p></blockquote><p>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</p></li><li><p>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</p></li><li><p>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</p></li><li><p>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p></li><li><p>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</p></li></ul><p>接下来，我们直接看一个例子，如下：</p><p><img src="../img/cache-demo.png" srcset="/img/loading.gif" alt=""></p><p>由上面的例子我们可以知道：</p><ul><li><p>HTTP响应报文中expires的时间值，是一个绝对值</p></li><li><p>HTTP响应报文中Cache-Control为max-age=600，是相对值</p></li></ul><p>由于Cache-Control的优先级比expires高，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。</p><p>注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。</p><p>了解强制缓存的过程后，我们拓展性的思考一下：</p><blockquote><p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p></blockquote><p>这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。</p><blockquote><p>那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？</p></blockquote><p>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p><p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：</p><p>访问<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a> –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a> –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)</p><p>过程如下：</p><ul><li>访问<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a></li></ul><p><img src="../img/cache-github.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>关闭博客的标签页</p></li><li><p>重新打开<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a></p></li><li><p>刷新</p></li></ul><p><img src="../img/cache-reopen.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？</p></blockquote><p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p><ul><li><p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</p></li><li><p>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</p></li><li><p>时效性：一旦该进程关闭，则该进程的内存则会清空。</p></li><li><p>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p></li></ul><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><p>协商缓存生效，返回304，如下</p><p><img src="../img/cache-consult-304.png" srcset="/img/loading.gif" alt=""></p><p>协商缓存失效，返回200和请求结果结果，如下</p><p><img src="../img/cache-200.png" srcset="/img/loading.gif" alt=""></p><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h3><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。</p><p><img src="../img/cache-lastmodify.png" srcset="/img/loading.gif" alt=""></p><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。</p><p><img src="../img/if-modified-since.png" srcset="/img/loading.gif" alt=""></p><h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h3><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。</p><p><img src="../img/etag.png" srcset="/img/loading.gif" alt=""></p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。</p><p><img src="../img/etag-match.png" srcset="/img/loading.gif" alt=""></p><p>注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p><p><img src="../img/cache-all.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/从输入URL到页面加载完成的过程</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="从输入URL到页面加载完成的过程"><a href="#从输入URL到页面加载完成的过程" class="headerlink" title="从输入URL到页面加载完成的过程"></a>从输入URL到页面加载完成的过程</h3><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">参考链接</a></p><p><img src="../img/%E8%BE%93%E5%85%A5URL%E5%90%8E.png" srcset="/img/loading.gif" alt="输入URL后.png"></p><ul><li>判断是否需要跳转(301)</li><li>从浏览器中读取缓存</li><li>DNS解析</li><li>TCP连接</li><li>HTTP请求发出</li><li>服务端处理请求，HTTP响应返回</li><li>浏览器拿到响应数据，解析响应内内容，把解析结果展示给用户</li></ul><ol><li>在浏览器地址栏输入URL</li><li>判断是否有永久重定向(301)<ol><li>如果有，直接跳转到对应URL</li></ol></li><li>浏览器查看资源是否有<strong>强缓存</strong>，有则直接使用，如果是<strong>协商缓存</strong>则需要到服务器进行校验资源是否可用<ol><li>检验新鲜通常有两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>：<ul><li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li><li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li><li>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</li><li>浏览器<strong>组装一个HTTP（GET）请求报文</strong></li><li><strong>DNS解析</strong>，查找过程如下：<ol><li>浏览器缓存</li><li>本机缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS查询（递归查询 / 迭代查询）</li></ol></li><li><strong>端口建立TCP链接</strong>，三次握手如下：<ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li><li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li><li>TCP链接建立后<strong>发送HTTP请求</strong></li><li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</li><li>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</li><li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li><li>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></li><li>浏览器接收HTTP响应，然后根据情况选择<strong>关闭TCP连接或者保留重用，关闭TCP连接的四次挥手如下</strong>：<ol><li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li><li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li><li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li><li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li></ol></li><li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li><li>如果资源可缓存，<strong>进行缓存</strong></li><li>对响应进行<strong>解码</strong>（例如gzip压缩）</li><li>根据资源类型决定如何处理（假设资源为HTML文档）</li><li><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</li><li><strong>构建DOM树</strong>：<ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li><li>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></li><li>构建<strong>CSSOM树</strong>：<ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li><li><strong><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="noopener">根据DOM树和CSSOM树构建渲染树</a></strong>:<ol><li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code></li><li>对每一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容和计算样式</li></ol></li><li><strong>js解析如下</strong>：<ol><li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li><li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li><li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用document.write()</strong>，它们可以访问自己script和之前的文档元素</li><li>当文档完成解析，document.readState变成interactive</li><li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li><li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li><li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete,window触发load事件</li></ol></li><li><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/UDP</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/UDP/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/UDP/</url>
    
    <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP（User Datagram Protocol），又叫用户数据报协议。<br>UDP是一个无连接的、不可靠、基于数据报的传输协议。UDP只是报文（报文可以理解为一段段的数据）的搬运工，不会对报文进行任何拆分和拼装操作。</p><p>具体来说</p><ul><li>在发送端，应用层将数据传递给传输层，UDP只会给数据怎加一个UDP头标识一下这是UDP，然后就传递给网络层了，不进行任何拆分。</li><li>在接收端，网络层将数据传递给传输层，UDP只取出IP报文头就传递给应用层，不进行任何拼装。</li></ul><p>特点：</p><ul><li>面向报文</li><li>不可靠传输</li><li>高效</li></ul><p>应用场景：<br>当强调输出性能而非完整性时，如音频和多媒体的实时传输。有个视频流传输协议RTP的实时传输就是基于UDP封装而来的。</p><h3 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h3><ol><li>UDP是<strong>无连接</strong>的，也就是说同学不需要建立和断开链接。</li><li>UDP是不可靠的。它不会去备份数据，也不关心对方是否能收到数据。</li><li>UDP<strong>没有拥塞控制</strong>，一直以恒定的速度发送数据，即使网络条件不好，也不进行速率调整。 造成的弊端就是在网络条件不好时可能导致丢包。</li></ol><h3 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h3><p>因为 UDP 没有 TCP 那么复杂，不需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。</p><p>UDP包头部包含了以下几个数据</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p><img src="../img/UDP.png" srcset="/img/loading.gif" alt="UDP Header"></p><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>支持一对一，一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/TCP</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/TCP/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP（Transmission Control Protocol），又叫传输控制协议。<br>TCP协议是面向连接的，可靠的，基于字节流的传输协议。在基于 TCP 进行通信时，通信双方需要先建立一个 TCP 连接，建立连接需要经过三次握手，断开连接的时候需要经过四次挥手。</p><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p><img src="../img/TCP.png" srcset="/img/loading.gif" alt="TCP header"></p><p>对于 TCP 头部来说，以下几个字段是很重要的:</p><ul><li><p><code>序列号</code> （Sequence number），这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</p></li><li><p><code>确认号</code> （Acknowledgement Number），这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</p></li><li><p><code>窗口大小</code> （Window Size），表示还能接收多少字节的数据，用于流量控制</p></li><li><p><code>标识符</code></p><ul><li>ACK=1 ：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</li><li>SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li><li>FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。</li><li>URG=1 :  该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li><li>PSH=1 ：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li><li>RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li></ul></li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="../img/thr-handshake.png" srcset="/img/loading.gif" alt="三次握手"></p><p>简单的说：</p><ul><li><p>第一次握手</p><ul><li>SYN = 1， seq(client) = x</li><li>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li></ul></li><li><p>第二次握手</p><ul><li>SYN = 1，ACK = 1，确认序号 = x+1, seq(server) = y</li><li>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态</li></ul></li><li><p>第三次握手</p><ul><li>ACK = 1，确认序号 = y+1, seq(client) = x + 1</li><li>客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li></ul></li></ul><h3 id="为什么不用两次握手？"><a href="#为什么不用两次握手？" class="headerlink" title="为什么不用两次握手？"></a>为什么不用两次握手？</h3><p>主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>假设有这样一种场景, 客户端发送的第一个请求连接并且没有丢失，但是被滞留的时间太长。由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送报文。<br>而现在第一个请求到达服务端，这个请求已经报废了，但是又会建立连接。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="../img/quarticBye.png" srcset="/img/loading.gif" alt="四次挥手"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p><ul><li><p>第一次挥手</p><ul><li>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</li></ul></li><li><p>第二次挥手</p><ul><li>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 <strong>CLOSE_WAIT</strong> 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 <strong>TCP 连接时双向的</strong>，所以 B 仍旧可以发送数据给 A。</li></ul></li><li><p>第三次挥手</p><ul><li>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入<strong>LAST-ACK</strong>状态。</li><li>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。</li></ul></li><li><p>第四次挥手</p><ul><li>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 <strong>TIME-WAIT</strong> 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 <strong>CLOSED</strong> 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</li></ul></li></ul><h3 id="为什么-A-要进入-TIME-WAIT-状态，等待-2MSL-时间后才进入-CLOSED-状态？"><a href="#为什么-A-要进入-TIME-WAIT-状态，等待-2MSL-时间后才进入-CLOSED-状态？" class="headerlink" title="为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？"></a>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</h3><p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p><h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 </p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了</p><h2 id="ARQ-（超时重传）协议"><a href="#ARQ-（超时重传）协议" class="headerlink" title="ARQ （超时重传）协议"></a>ARQ （超时重传）协议</h2><p>通过确认和超时机制保证了数据的正确送达，ARQ 协议包含<code>停止等待 ARQ</code> 和<code>连续 ARQ</code></p><h3 id="停止等待-ARQ"><a href="#停止等待-ARQ" class="headerlink" title="停止等待 ARQ"></a>停止等待 ARQ</h3><p><strong>正常传输过程</strong></p><p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p><p><strong>当报文丢失或出错：</strong></p><p>报文传输的过程中丢包： 这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p><p>传输过程中报文出错： 对端会抛弃该报文并等待 A 端重传。</p><p>PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。</p><p><strong>ACK 超时或丢失：</strong></p><p>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p><p>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK 。</p><h3 id="连续-ARQ"><a href="#连续-ARQ" class="headerlink" title="连续 ARQ"></a>连续 ARQ</h3><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1的数据。</p><p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>上面讲到了发送窗口。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。</p><p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。</p><p><img src="../img/slideWindow.png" srcset="/img/loading.gif" alt="滑动窗口"></p><p>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p><p>当发送端接收到应答报文后，会随之将窗口进行滑动</p><p><strong>滑动窗口实现了流量控制</strong>。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p><p><strong>Zero 窗口</strong></p><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p><h2 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h2><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p><h3 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h3><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口从1开始指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p><p>慢开始算法步骤具体如下</p><ol><li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li><li>每过一个 RTT (往返时延) 就将窗口大小乘二</li><li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法</li></ol><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p><img src="../img/ysbm.png" srcset="/img/loading.gif" alt="拥塞避免"></p><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p><p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 1 MSS</li><li>启动拥塞避免算法</li></ul><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p><h3 id="RTT与RTO"><a href="#RTT与RTO" class="headerlink" title="RTT与RTO"></a>RTT与RTO</h3><ul><li><strong>RTT</strong>(Round Trip Time)<ul><li>一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值。 </li></ul></li><li><strong>RTO</strong>(Retransmission Time Out)<ul><li>重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。 </li></ul></li><li>RTT和RTO 的关系是<ul><li>由于网络波动的不确定性，每个RTT都是动态变化的，所以RTO也应随着RTT动态变化。</li></ul></li></ul><p><a href="https://blog.csdn.net/whgtheone/article/details/80970292" target="_blank" rel="noopener">博客链接</a></p><h3 id="TCP-小结"><a href="#TCP-小结" class="headerlink" title="TCP 小结"></a>TCP 小结</h3><p>为什么TCP这么复杂?</p><p>因为既要保证可靠性, 同时又要尽可能提高性能</p><p>保证可靠性的机制</p><ul><li>校验和</li><li>序列号(按序到达)</li><li>确认应答</li><li>超时重传</li><li>连接管理</li><li>流量控制</li><li>拥塞控制</li></ul><p>提高性能的机制</p><ul><li>滑动窗口</li><li>快速重传</li><li>延迟应答</li><li>捎带应答</li></ul><p>定时器</p><ul><li>超时重传定时器</li><li>保活定时器</li><li>TIME_WAIT定时器</li></ul><h3 id="基于-TCP-的应用层协议"><a href="#基于-TCP-的应用层协议" class="headerlink" title="基于 TCP 的应用层协议"></a>基于 TCP 的应用层协议</h3><ul><li>HTTP</li><li>HTTPS</li><li>SSH</li><li>Telnet</li><li>FTP</li><li>SMTP</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/RESTful</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/RESTful/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/RESTful/</url>
    
    <content type="html"><![CDATA[<h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h1><p>REST (Representational State Transfer)，中文意思是：表述性状态转移。 一组架构约束条件和原则，如果一个架构符合 REST 的约束条件和原则，我们就称它为 RESTful 架构。</p><p>RESTful基本概念</p><ul><li>在 REST 中，一切的内容都被认为是一种资源</li><li>每个资源都由 URI 唯一标识</li><li>使用统一的接口处理资源请求（POST/GET/PUT/DELETE/HEAD）</li><li>无状态（每次请求之前是无关联，没有 session ）</li></ul><h2 id="理解RESTful"><a href="#理解RESTful" class="headerlink" title="理解RESTful"></a>理解RESTful</h2><p>下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。</p><ul><li>资源与URI</li><li>统一资源接口</li><li>资源的表述</li><li>资源的链接</li><li>状态的转移</li></ul><h3 id="资源和URI"><a href="#资源和URI" class="headerlink" title="资源和URI"></a>资源和URI</h3><ul><li>使用 <code>/</code> 来表示资源的层级关系</li><li>使用 <code>?</code> 用来过滤资源</li><li>使用 <code>_</code> 或者 <code>-</code> 让URI的可读性更好</li><li><code>,</code> 或 <code>;</code> 可以用来表示同级资源的关系</li></ul><h3 id="统一资源接口"><a href="#统一资源接口" class="headerlink" title="统一资源接口"></a>统一资源接口</h3><table><thead><tr><th>请求方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>获取某个资源。 幂等（取多少次结果都没有变化）</td></tr><tr><td>POST</td><td>创建一个新的资源</td></tr><tr><td>PUT</td><td>替换某个已有的资源（更新操作） ， 幂等（更新多次只保存一个结果）</td></tr><tr><td>DELETE</td><td>删除某个资源</td></tr><tr><td>HEAD</td><td>主要用于确认 URL 的有效性以及资源更新的日期时间等</td></tr><tr><td>PATCH</td><td>新引入的，对PUT方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><h3 id="资源表述"><a href="#资源表述" class="headerlink" title="资源表述"></a>资源表述</h3><p>客户端获取的只是资源的表述而已。资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。文本资源可以采用 html、xml、json 等格式，图片可以使用 PNG 或 JPG 展现出来。</p><p>资源的表述包括数据和描述数据的元数据，例如，HTTP 头 “Content-Type” 就是这样一个元数据属性。</p><p>那么客户端如何知道服务端提供哪种表述形式呢？</p><p>答案是可以通过 HTTP 内容协商，客户端可以通过 Accept 头请求一种特定格式的表述，服务端则通过 Content-Type 告诉客户端资源的表述形式。</p><p>MIME 类型</p><p>accept: text/xml html文件</p><p>Content-Type告诉客户端资源的表述形式</p><h3 id="资源的链接"><a href="#资源的链接" class="headerlink" title="资源的链接"></a>资源的链接</h3><p>超媒体即应用状态引擎（可以做多层链接）</p><p><a href="https://api.github.com/repos/github" target="_blank" rel="noopener">https://api.github.com/repos/github</a></p><pre><code>{  &quot;message&quot;: &quot;Not Found&quot;,  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;}</code></pre><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>服务器端不应该保存客户端状态。</p><p>应用状态 -&gt; 服务器端不保存应用状态</p><p>访问订单 根据接口去查询</p><p>访问商品 查询</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/README</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/README/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/README/</url>
    
    <content type="html"><![CDATA[<h1 id="网络知识"><a href="#网络知识" class="headerlink" title="网络知识"></a>网络知识</h1><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a><a href="Ajax.md">Ajax</a></h2><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><a href="HTTP.md">HTTP</a></h2><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><a href="TCP.md">TCP</a></h2><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><a href="UDP.md">UDP</a></h2><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a><a href="./跨域.md">跨域</a></h2><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><a href="缓存.md">缓存</a></h2><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a><a href="cookie和session.md">cookie和session</a></h2><h2 id="从输入URL到页面加载完成的过程"><a href="#从输入URL到页面加载完成的过程" class="headerlink" title="从输入URL到页面加载完成的过程"></a><a href="从输入URL到页面加载完成的过程.md">从输入URL到页面加载完成的过程</a></h2><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a><a href="HTTPS.md">HTTPS</a></h2><h3 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI 七层协议"></a>OSI 七层协议</h3><ul><li>应用层<ul><li>为应用提供通信服务</li></ul></li><li>表示层<ul><li>定义数据格式以及加密</li></ul></li><li>会话层<ul><li>定义了如何开始、控制、结束一个会话，包括对多个双向消息的控制和管理。</li></ul></li><li>传输层<ul><li>选择差错恢复协议还是无差错恢复协议</li><li>TCP、UDP</li></ul></li><li>网络层<ul><li>端到端包传输。</li><li>路由选择、包分解成更小的包</li></ul></li><li>数据链路层<ul><li>定义单个链路上如何传输数据</li></ul></li><li>物理层<ul><li>传输介质相关</li></ul></li></ul><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS 的作用就是通过域名查询到具体的 IP。</p><ol><li>操作系统会首先在本地缓存中查询</li><li>没有的话会去系统配置的 DNS 服务器中查询</li><li>如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li><li>然后去该服务器查询 google 这个二级域名</li><li>接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP</li></ol><p>以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。</p><h3 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h3><ul><li>Ajax</li><li>WebSocket</li><li>CORS</li></ul><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>在单个 TCP 连接上进行全双工通讯的协议。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建<strong>持久性</strong>的连接，并进行<strong>双向</strong>数据传输。</p><ul><li>Socket.onopen    连接建立时触发</li><li>Socket.onmessage    客户端接收服务端数据时触发</li><li>Socket.onerror    通信发生错误时触发</li><li>Socket.onclose    连接关闭时触发</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/nginx</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/nginx/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx代理"><a href="#nginx代理" class="headerlink" title="nginx代理"></a>nginx代理</h1><h3 id="nginx基本代理"><a href="#nginx基本代理" class="headerlink" title="nginx基本代理"></a>nginx基本代理</h3><pre><code>server {  listen        80;  # 访问的域名  server_name   test.com;  # 代理请求  location / {    proxy_pass http://127.0.0.1:8888;    # 设置HTTP头中修改host为test.com    proxy_set_header Host $host;  }}</code></pre><h3 id="nginx配置缓存"><a href="#nginx配置缓存" class="headerlink" title="nginx配置缓存"></a>nginx配置缓存</h3><pre><code># 写在server外proxy_cache_path  cache levels=1:2 keys_zoom=my_cache:10m</code></pre><ul><li>cache<ul><li>文件夹名</li></ul></li><li>levels=1:2<ul><li>设置二级文件夹来存缓存，因为随着文件的越来越多查找速度会越来越慢</li></ul></li><li>keys_zoom=my_cache:10m<ul><li>申请10兆内存来缓存内容</li></ul></li></ul><pre><code>server {  listen        80;  server_name   test.com;  location / {    proxy_cache   my_cache; #在这里写缓存    proxy_pass http://127.0.0.1:8888;    proxy_set_header Host $host;  }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/HTTPS</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/HTTPS/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/HTTPS/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>http默认采用80作为通讯端口，对于传输采用不加密的方式，https默认采用443，对于传输的数据进行加密传输。</p><h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><p>明文： 明文指的是未被加密过的原始数据。</p><p>密文：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。</p><p>密钥：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。</p><pre><code>其加密过程如下：明文 + 加密算法 + 私钥 =&gt; 密文解密过程如下：密文 + 解密算法 + 私钥 =&gt; 明文</code></pre><p>对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。</p><p>其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。</p><ul><li><p><strong>被公钥加密过的密文只能被私钥解密</strong>，过程如下：</p><pre><code>明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文</code></pre></li><li><p><strong>被私钥加密过的密文只能被公钥解密</strong>，过程如下：</p><pre><code>明文 + 加密算法 + 私钥 =&gt; 密文， 密文 + 解密算法 + 公钥 =&gt; 明文</code></pre></li></ul><p>由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。<br>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br>在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p><h2 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h2><p><strong>HTTPS协议 = HTTP协议 + SSL/TLS协议</strong>，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。</p><p><strong>SSL</strong>的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0。</p><p><strong>TLS</strong>的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。</p><p>HTTPS为了兼顾安全与效率，<strong>同时使用了对称加密和非对称加密</strong>。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，<strong>对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输</strong>。</p><p><img src="../img/httpscrypt.png" srcset="/img/loading.gif" alt="加密"></p><p>HTTPS在传输的过程中会涉及到三个密钥：</p><ul><li>服务器端的公钥和私钥，用来进行非对称加密</li><li>客户端生成的随机密钥，用来进行对称加密</li></ul><p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。</p><ol><li>客户端向服务器发起HTTPS请求，连接到服务器的443端口</li><li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</li><li>服务器将自己的公钥发送给客户端。</li><li>客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>然后服务器将加密后的密文发送给客户端。</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</li></ol><p>原文链接：<a href="https://www.jianshu.com/p/14cd2c9d2cd2" target="_blank" rel="noopener">https://www.jianshu.com/p/14cd2c9d2cd2</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/HTTP</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/HTTP/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><h3 id="HTTP-协议的特点"><a href="#HTTP-协议的特点" class="headerlink" title="HTTP 协议的特点"></a>HTTP 协议的特点</h3><ul><li>无连接<ul><li>限制每次连接只处理一个请求</li></ul></li><li>无状态<ul><li>协议对于事务处理没有记忆能力。</li></ul></li><li>简单快速<ul><li>客户向服务器请求服务时，只需传送请求方法和路径。</li></ul></li><li>灵活<ul><li>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li></ul></li></ul><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><ul><li>请求行<ul><li>请求类型</li><li>要访问的资源</li><li>HTTP协议版本号</li></ul></li><li>请求头<ul><li>用来说明服务器要使用的附加信息（一些键值对）</li><li>例如：User-Agent、 Accept、Content-Type、Connection</li></ul></li><li>空行<ul><li>分割请求头与请求体</li></ul></li><li>请求体<ul><li>可以添加任意的其他数据</li></ul></li></ul><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><ul><li>状态行<ul><li>状态码</li><li>状态消息 </li><li>HTTP协议版本号</li></ul></li><li>消息报头<ul><li>说明客户端要使用的一些附加信息</li><li>如：Content-Type、charset、响应的时间</li></ul></li><li>响应正文<ul><li>返回给客户端的文本信息 </li></ul></li></ul><h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><ul><li>GET<ul><li>获取资源</li></ul></li><li>POST<ul><li>传输资源</li></ul></li><li>PUT<ul><li>更新资源</li></ul></li><li>DELETE<ul><li>删除资源</li></ul></li><li>HEAD<ul><li>获取报文首部</li></ul></li></ul><h3 id="Post-和-Get-的区别"><a href="#Post-和-Get-的区别" class="headerlink" title="Post 和 Get 的区别"></a>Post 和 Get 的区别</h3><ul><li>GET在浏览器回退时是无害的，而POST会再次提交</li><li>Get请求能缓存，Post不能</li><li>Post相对Get相对安全一些，因为Get请求都包含在URL中，而且会被浏览器保存记录，Post不会。但是再抓包的情况下都是一样的。</li><li>Post 可以通过 request body来传输比 Get 更多的数据 </li><li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的</li><li>Post 支持更多的编码类型且不对数据类型限制</li><li>POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)</li></ul><p>先引入副作用和幂等的概念。<br>副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。<br>幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。<br>在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。</p><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><h4 id="1XX-指示信息"><a href="#1XX-指示信息" class="headerlink" title="1XX 指示信息"></a>1XX 指示信息</h4><p>表示请求已接收，继续处理</p><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul><li><strong>200</strong> OK</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li><strong>206</strong> Partial Content，进行范围请求</li></ul><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul><li><strong>301</strong> 永久性重定向，表示资源已被分配了新的 URL</li><li><strong>302</strong> 临时性重定向，表示资源临时被分配了新的 URL</li><li>303 表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li><strong>304</strong> 未修改，重定位到浏览器。自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</li><li>307 临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><ul><li><strong>404</strong> 在服务器上没有找到请求的资源</li><li><strong>403</strong> forbidden，表示对请求资源的访问被服务器拒绝</li><li>400 请求报文存在语法错误</li><li>401  表示发送的请求需要有通过 HTTP 认证的认证信息</li></ul><h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><ul><li><strong>500</strong> 表示服务器端在执行请求时发生了错误</li><li>501 表示服务器不支持当前请求所需要的某个功能</li><li><strong>503</strong> 表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h3 id="HTTP持久连接（HTTP1-1支持）"><a href="#HTTP持久连接（HTTP1-1支持）" class="headerlink" title="HTTP持久连接（HTTP1.1支持）"></a>HTTP持久连接（HTTP1.1支持）</h3><p>HTTP协议采用“请求-应答”模式，并且HTTP是基于TCP进行连接的。普通模式（非keep-alive）时，每个请求或应答都需要建立一个连接，完成之后立即断开。</p><p>当使用<code>Conection: keep-alive</code>模式（又称持久连接、连接重用）时，keep-alive使客户端道服务器端连接持续有效，即不关闭底层的TCP连接，当出现对服务器的后继请求时，keep-alive功能避免重新建立连接。</p><h3 id="HTTP管线化-（HTTP1-1支持）"><a href="#HTTP管线化-（HTTP1-1支持）" class="headerlink" title="HTTP管线化 （HTTP1.1支持）"></a>HTTP管线化 （HTTP1.1支持）</h3><p><img src="../img/pipe.png" srcset="/img/loading.gif" alt="pipe"></p><p>管线化后，请求和响应不再是依次交替的了。他可以支持一次性发送多个请求，并一次性接收多个响应。</p><ul><li>只有get与head请求可以进行管线化，POST有限制</li><li>初次创建连接时不应该启动管线机制，因为服务器不一定支持该协议</li></ul><h3 id="HTTP数据协商"><a href="#HTTP数据协商" class="headerlink" title="HTTP数据协商"></a>HTTP数据协商</h3><p>在客户端向服务端发送请求的时候，客户端会申明可以接受的数据格式和数据相关的一些限制是什么样的；服务端在接受到这个请求时他会根据这个信息进行判断到底返回怎样的数据。</p><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><ul><li>Accept <ul><li>在请求中使用Accept可申明想要的数据格式</li></ul></li><li>Accept-Encoding<ul><li>告诉服务端使用什么的方式来进行压缩</li><li>例如：gzip、deflate、br</li></ul></li><li>Accept-Language<ul><li>描述语言信息</li></ul></li><li>User-Agent<ul><li>用来描述客户端浏览器相关信息</li><li>可以用来区分PC端页面和移动端页面</li></ul></li></ul><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><ul><li>Content-Type<ul><li>对应Accept，从请求中的Accept支持的数据格式中选一种来返回</li></ul></li><li>Content-Encoding<ul><li>对应 Accept-Encoding，指服务端到底使用的是那种压缩方式</li></ul></li><li>Content-Language<ul><li>对应Accept-Language</li></ul></li></ul><h4 id="form-表单中enctype数据类型"><a href="#form-表单中enctype数据类型" class="headerlink" title="form 表单中enctype数据类型"></a>form 表单中enctype数据类型</h4><ul><li><code>application/x-www-form-urlencoded</code><ul><li>key=value&amp;key=value 格式</li></ul></li><li><code>multipart/form-data</code><ul><li>用于提交文件</li><li>multipart表示请求是由多个部分组成（因为上传文件的时候文件不能以字符串形式提交，需要单独分出来）</li><li>boundary 用来分隔不同部分</li></ul></li><li><code>text/plain</code></li></ul><h3 id="HTTP-Redirect-重定向"><a href="#HTTP-Redirect-重定向" class="headerlink" title="HTTP Redirect 重定向"></a>HTTP Redirect 重定向</h3><ul><li>302 暂时重定向<ul><li>浏览器每次访问都要先去目标网址访问，再重定向到新的网址</li></ul></li><li>301 永久重定向<ul><li>当浏览器收到的HTTP状态码为301时，下次访问对应网址就直接调整到新的网址，不会再访问原网址</li></ul></li></ul><h3 id="HTTP-CSP-内容安全策略"><a href="#HTTP-CSP-内容安全策略" class="headerlink" title="HTTP CSP 内容安全策略"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP" target="_blank" rel="noopener">HTTP CSP 内容安全策略</a></h3><p>CSP Content-Security-Policy</p><ul><li>限制资源获取</li><li>报告资源获取越权</li></ul><p>例子：</p><ul><li><code>Content-Security-Policy: default-src http: https:</code> 表示只允许通过http、https的方式加载资源</li><li><code>&#39;Content-Security-Policy&#39;: &#39;default-src&#39; \&#39;self\&#39;; form-action\&#39;self\&#39; &#39;</code> 表示只能加载本域下的资源，只能向本域发送表单请求</li></ul><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。</p><p>HTTP2采用<code>二进制格式传输</code>，取代了HTTP1.x的文本格式，二进制格式解析更高效。<br><code>多路复用</code>代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。</p><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p>HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。<br>HTTP2中</p><ul><li>同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。</li><li>单个连接上可以并行交错的请求和响应，之间互不干扰</li></ul><p>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</p><p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p><p><strong>多路复用，就是在一个 TCP 连接中可以存在多条流。</strong> 换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p><p><img src="../img/http2Connet.png" srcset="/img/loading.gif" alt="http2"></p><h3 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h3><p>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p><h3 id="服务端-Push"><a href="#服务端-Push" class="headerlink" title="服务端 Push"></a>服务端 Push</h3><p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p><p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。</p><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><table><thead><tr><th align="center">通用字段</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">浏览器想要优先使用的连接类型，比如  <code>keep-alive</code></td></tr><tr><td align="center">Date</td><td align="center">创建报文时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Via</td><td align="center">代理服务器相关信息</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">要求客户端升级协议</td></tr><tr><td align="center">Warning</td><td align="center">在内容中可能存在错误</td></tr></tbody></table><table><thead><tr><th align="center">请求字段</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">能正确接收的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">能正确接收的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">能正确接收的编码格式列表</td></tr><tr><td align="center">Accept-Language</td><td align="center">能正确接收的语言列表</td></tr><tr><td align="center">Expect</td><td align="center">期待服务端的指定行为</td></tr><tr><td align="center">From</td><td align="center">请求方邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">服务器的域名</td></tr><tr><td align="center">If-Match</td><td align="center">两端资源标记比较</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">本地资源未修改返回 304（比较时间）</td></tr><tr><td align="center">If-None-Match</td><td align="center">本地资源未修改返回 304（比较标记）</td></tr><tr><td align="center">User-Agent</td><td align="center">客户端信息</td></tr><tr><td align="center">Max-Forwards</td><td align="center">限制可被代理及网关转发的次数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">向代理服务器发送验证信息</td></tr><tr><td align="center">Range</td><td align="center">请求某个内容的一部分</td></tr><tr><td align="center">Referer</td><td align="center">表示浏览器所访问的前一个页面</td></tr><tr><td align="center">TE</td><td align="center">传输编码方式</td></tr></tbody></table><table><thead><tr><th align="center">响应字段</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否支持某些种类的范围</td></tr><tr><td align="center">Age</td><td align="center">资源在代理缓存中存在的时间</td></tr><tr><td align="center">ETag</td><td align="center">资源标识</td></tr><tr><td align="center">Location</td><td align="center">客户端重定向到某个 URL</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">向代理服务器发送验证信息</td></tr><tr><td align="center">Server</td><td align="center">服务器名字</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">获取资源需要的验证信息</td></tr></tbody></table><table><thead><tr><th align="center">实体字段</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源的正确请求方式</td></tr><tr><td align="center">Content-Encoding</td><td align="center">内容的编码格式</td></tr><tr><td align="center">Content-Language</td><td align="center">内容使用的语言</td></tr><tr><td align="center">Content-Length</td><td align="center">request body 长度</td></tr><tr><td align="center">Content-Location</td><td align="center">返回数据的备用地址</td></tr><tr><td align="center">Content-MD5</td><td align="center">Base64加密格式的内容 MD5检验值</td></tr><tr><td align="center">Content-Range</td><td align="center">内容的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">内容的媒体类型</td></tr><tr><td align="center">Expires</td><td align="center">内容的过期时间</td></tr><tr><td align="center">Last_modified</td><td align="center">内容的最后修改时间</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/cookie和session</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/cookie%E5%92%8Csession/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/cookie%E5%92%8Csession/</url>
    
    <content type="html"><![CDATA[<h1 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>cookie:<br>登录网站，第一天输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。</p><p>session:<br>session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>服务器通过设置<code>set-cookie</code>这个响应头，将cookie信息返回给浏览器，浏览器将响应头中的cookie信息保存在本地，当下次向服务器发送HTTP请求时，浏览器会自动将保存的这些cookie信息添加到请求头中。</p><p>通过cookie，服务器就会识别出浏览器，从而保证返回的数据是这个用户的。</p><ul><li>通过<code>set-cookie</code>设置</li><li>下次请求会自动带上</li><li>键值对，可设置多个</li></ul><h3 id="cookie属性"><a href="#cookie属性" class="headerlink" title="cookie属性"></a>cookie属性</h3><ul><li>max-age<ul><li>过期时间有多长</li><li>默认在浏览器关闭时失效</li></ul></li><li>expires<ul><li>到哪个时间点过期</li></ul></li><li>secure<ul><li>表示这个cookie只会在https的时候才会发送</li></ul></li><li>HttpOnly<ul><li>设置后无法通过在js中使用document.cookie访问</li><li>保障安全，防止攻击者盗用用户cookie</li></ul></li><li>domain<ul><li>表示该cookie对于哪个域是有效的。 </li></ul></li></ul><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><ul><li>存放在服务器的一种用来存放用户数据的类似HashTable的结构</li><li>浏览器第一次发送请求时，服务器自动生成了HashTable和SessionID来唯一标识这个hash表，并将sessionID存放在cookie中通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的sessionID随着cookie发送到服务器上，服务器从请求中提取sessionID，并和保存的所有sessionID进行对比，找到这个用户对应的hash表。<ul><li>一般这个值是有时间限制的，超时后销毁，默认30min</li></ul></li><li>当用户在应用程序的web页面间挑转时，存储在session对象中的变量不会丢失而是在整个用户会话中一直存在下去。</li><li>session依赖于cookie，因为sessionID是存放在cookie中的。</li></ul><h2 id="sesssion与cookie的区别"><a href="#sesssion与cookie的区别" class="headerlink" title="sesssion与cookie的区别"></a>sesssion与cookie的区别</h2><ul><li>cookie存在客户端，session存在于服务端。</li><li>cookie在客户端中存放，容易伪造，不如session安全</li><li>session会消耗大量服务器资源，cookie在每次HTTP请求中都会带上，影响网络性能</li><li>域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而<a href="http://www.a.com的Session在api.a.com下都不能用" target="_blank" rel="noopener">www.a.com的Session在api.a.com下都不能用</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/CDN</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/CDN/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/CDN/</url>
    
    <content type="html"><![CDATA[<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>CDN（Content Delivery Network，内容分发网络）是构建在现有互联网基础之上的一层智能虚拟网络，通过在网络各处部署节点服务器，实现将源站内容分发至所有CDN节点，使用户可以就近获得所需的内容。CDN服务缩短了用户查看内容的访问延迟，提高了用户访问网站的响应速度与网站的可用性，解决了网络带宽小、用户访问量大、网点分布不均等问题。</p><h2 id="加速原理"><a href="#加速原理" class="headerlink" title="加速原理"></a>加速原理</h2><p>当用户访问使用CDN服务的网站时，本地DNS服务器通过CNAME方式将最终域名请求重定向到CDN服务。CDN通过一组预先定义好的策略(如内容类型、地理区域、网络负载状况等)，将当时能够最快响应用户的CDN节点IP地址提供给用户，使用户可以以最快的速度获得网站内容。使用CDN后的HTTP请求处理流程如下：</p><h3 id="CDN节点有缓存场景"><a href="#CDN节点有缓存场景" class="headerlink" title="CDN节点有缓存场景"></a>CDN节点有缓存场景</h3><p><img src="../img/cdncache.png" srcset="/img/loading.gif" alt="cdncache"></p><ol><li>用户在浏览器输入要访问的网站域名，向本地DNS发起域名解析请求。</li><li>域名解析的请求被发往网站授权DNS服务器。</li><li>网站DNS服务器解析发现域名已经CNAME到了<a href="http://www.example.com.c.cdnhwc1.com。" target="_blank" rel="noopener">www.example.com.c.cdnhwc1.com。</a></li><li>请求被指向CDN服务。</li><li>CDN对域名进行智能解析，将响应速度最快的CDN节点IP地址返回给本地DNS。</li><li>用户获取响应速度最快的CDN节点IP地址。</li><li>浏览器在得到速度最快节点的IP地址以后，向CDN节点发出访问请求。</li><li>CDN节点将用户所需资源返回给用户。</li></ol><h3 id="CDN节点无缓存场景"><a href="#CDN节点无缓存场景" class="headerlink" title="CDN节点无缓存场景"></a>CDN节点无缓存场景</h3><p><img src="../img/cdnnocahche.png" srcset="/img/loading.gif" alt="无缓存"></p><ol><li>用户在浏览器输入要访问的网站域名，向本地DNS发起域名解析请求。</li><li>域名解析的请求被发往网站授权DNS服务器。</li><li>网站DNS服务器解析发现域名已经CNAME到了<a href="http://www.example.com.c.cdnhwc1.com。" target="_blank" rel="noopener">www.example.com.c.cdnhwc1.com。</a></li><li>请求被指向CDN服务。</li><li>CDN对域名进行智能解析，将响应速度最快的CDN节点IP地址返回给本地DNS。</li><li>用户获取响应速度最快的CDN节点IP地址。</li><li>浏览器在得到速度最快节点的IP地址以后，向CDN节点发出访问请求。</li><li>CDN节点回源站拉取用户所需资源。</li><li>将回源拉取的资源缓存至节点。</li><li>将用户所需资源返回给用户。</li></ol><p>PS：CNAME别名解析是将域名指向一个网址（域名）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络/Ajax</title>
    <link href="/uncategorized/%E7%BD%91%E7%BB%9C/Ajax/"/>
    <url>/uncategorized/%E7%BD%91%E7%BB%9C/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX" target="_blank" rel="noopener">Ajax | MDN</a></p><p>AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XML）。简单点说，就是使用 XMLHttpRequest 对象与服务器通信。 它可以使用JSON，XML，HTML和text文本等格式发送和接收数据。AJAX最吸引人的就是它的“异步”特性，也就是说他可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p><h3 id="创建一个简单的Ajax"><a href="#创建一个简单的Ajax" class="headerlink" title="创建一个简单的Ajax"></a>创建一个简单的Ajax</h3><ul><li><p>创建 XMLHttpRequest 对象</p><pre><code class="js">if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ... httpRequest = new XMLHttpRequest();} else if (window.ActiveXObject) { // IE 6 and older httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);}</code></pre></li><li><p>绑定onreadystatechange 事件</p><pre><code class="js">httpRequest.onreadystatechange = function(){ // Process the server response here.};</code></pre></li><li><p>向服务器发送请求</p><pre><code class="js">httpRequest.open(&#39;GET&#39;, &#39;http://www.example.org/some.file&#39;, true);httpRequest.send();</code></pre></li></ul><p>完整的例子</p><pre><code class="js">function ajax(url, cb) {  let xhr;  if(window.XMLHttpRequest) {    xhr = new XMLHttpRequest();  } else {    xhr = ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);  }  xhr.onreadystatechange = function() {    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) {      cb(xhr.responseText);    }   }  xhr.open(&#39;GET&#39;, url, true);  xhr.send();}</code></pre><h3 id="httpRequest-readyState的值"><a href="#httpRequest-readyState的值" class="headerlink" title="httpRequest.readyState的值"></a>httpRequest.readyState的值</h3><ul><li>0 (未初始化) or (请求还未初始化)</li><li>1 (正在加载) or (已建立服务器链接)</li><li>2 (加载成功) or (请求已接受)</li><li>3 (交互) or (正在处理请求)</li><li>4 (完成) or (请求已完成并且响应已准备好)</li></ul><h3 id="访问服务端返回的数据"><a href="#访问服务端返回的数据" class="headerlink" title="访问服务端返回的数据"></a>访问服务端返回的数据</h3><ul><li>httpRequest.responseText<ul><li>服务器以文本字符的形式返回</li></ul></li><li>httpRequest.responseXML <ul><li>以 XMLDocument 对象方式返回，之后就可以使用JavaScript来处理</li></ul></li></ul><h3 id="GET-注意事项"><a href="#GET-注意事项" class="headerlink" title="GET 注意事项"></a>GET 注意事项</h3><ul><li>如果不设置响应头 <code>Cache-Control: no-cache</code> 浏览器将会把响应缓存下来而且再也不无法重新提交请求。你也可以添加一个总是不同的 GET 参数，比如时间戳或者随机数 (详情见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache" target="_blank" rel="noopener">bypassing the cache</a>)</li></ul><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p>POST请求则需要设置<code>RequestHeader</code>告诉后台传递内容的编码方式以及在send方法里传入对应的值</p><pre><code class="js">xhr.open(&quot;POST&quot;, url, true);xhr.setRequestHeader(&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;);xhr.send(&quot;key1=value1&amp;key2=value2&quot;);</code></pre><h3 id="Ajax与cookie"><a href="#Ajax与cookie" class="headerlink" title="Ajax与cookie"></a>Ajax与cookie</h3><ul><li>ajax会自动带上同源的cookie，不会带上不同源的cookie</li><li>可以通过前端设置withCredentials为true， 后端设置Header的方式让ajax自动带上不同源的cookie，但是这个属性对同源请求没有任何影响。会被自动忽略。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials" target="_blank" rel="noopener">withCredentials | MDN</a></p><pre><code class="js">var xhr = new XMLHttpRequest();xhr.open(&#39;GET&#39;, &#39;http://example.com/&#39;, true);xhr.withCredentials = true;xhr.send(null);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法/树的遍历/深度优先遍历</title>
    <link href="/uncategorized/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <url>/uncategorized/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[/** * 递归式深度遍历tree */function deepTravel(tree, nodeList = []) {  if(tree) {    nodeList.push(tree);    for(let i of Object.keys(tree.children)) {      deepTravel(tree.children[i], nodeList)    }  }  return nodeList;}/** * 非递归式 遍历tree *  * 使用：栈 * 但入栈时是反着把 children 数组 push 入栈的，保证下一次 pop 能拿到左子树元素 */function deepTravel(tree) {  let stack = [];  let nodeList = [];  tree && stack.push(tree);  //注意，这里如果 while(stack) 会死循环  while(stack.length) {    let node = stack.pop();    nodeList.push(node);    for(let i = node.children.length - 1; i >= 0; i --) {      stack.push(node.children[i]);    }  }}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法/树的遍历/广度优先遍历</title>
    <link href="/uncategorized/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <url>/uncategorized/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[/** * 广度优先遍历树 *  * 使用： 队列 */function widthTravel(tree)  {  let queue = [];  let nodeList  = [];  tree && queue.push(tree);  while(queue.length) {    let node = queue.shift();    for(let i = 0; i < node.children.length; i ++) {      queue.push(node[i]);    }  }  return nodeList;}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法/排序算法</title>
    <link href="/uncategorized/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/uncategorized/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>每次两两比较，大的放到后面，第 i 轮找出 第 n - i 轮大的数</p><pre><code class="js">function bubbleSort(arr) {    // 外层，需要遍历的次数    for(let i = 1; i &lt; arr.length; i ++) {        // 内层，每次比较        for(let j = 0; j &lt; arr.length - i; j ++) {            if(arr[j] &gt; arr[j + 1]) {                let temp = arr[j]                arr[j] = arr[j + 1]                arr[j + 1] = temp;            }        }    }}</code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每一轮从数组的未排序部分加一开始，找到一个最小的值的索引，然后与未排序将其放到未排序部分的最左位置。</p><pre><code class="js">function selectionSort(arr) {    // 选多少次    for(let i = 0; i &lt; arr.length - 1; i ++) {        let minIndex = i;        // 在arr[i + 1, ] 中找最小值索引， i+1 代表有序的下一个数，我们默认第一个元素是最小的        for(let j = i + 1; j &lt; arr.length; j ++) {            if(arr[j] &lt; arr[minIndex]) {                minIndex = j;            }        }        if(minIndex != i) {            // 交换            let temp = arr[minIndex]            arr[minIndex] = arr[i]            arr[i] = temp;        }    }}</code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>为当前元素保存一个副本，依次向前遍历前面的元素是否比自己大，如果比自己大就直接把前一个元素赋值到当前元素的位置，当前某位置的元素不再比当前元素大的时候，将当前元素的值赋值到这个位置。</p><pre><code class="js">function insertSort(arr) {    for(let i = 1; i &lt; arr.length; i++) {        let j, temp = arr[i];        for(j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp; j --) {            arr[j] = arr[j - 1];        }        arr[j] = temp;    }}</code></pre><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><pre><code class="js">/** * 将数组arr分为两部分，前一部分整体小于后一部分 */function partition(arr, left, right) {    // 交换数组最左元素与数组的中间元素    let midIndex = ((left + right) / 2) &gt;&gt; 0;    swap(arr, left, midIndex)    // 基准元素    const flagItem = arr[left];    let i = left + 1,        j = right;    while (true) {        while (i &lt;= right &amp;&amp; arr[i] &lt; flagItem) {            i++;        }        while (j &gt;= left &amp;&amp; arr[j] &gt; flagItem) {            j--;        }        if (i &gt; j) {            break;        } else {            swap(arr, i, j);            i++;            j--;        }    }    swap(arr, left, j);    return j;}function quickSort(arr, left = 0, right = arr.length - 1) {    if (left &gt;= right) {        return;    }    const mid = partition(arr, left, right);    quickSort(arr, left, mid - 1);    quickSort(arr, mid + 1, right);}</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre><code class="cpp">/** * 归并数组的两个有序部分 *  * 将arr[left, mid], arr[mid, right]两部分归并 */template &lt;typename T&gt;void __merge(T arr[], int left,int mid, int right){  T tempArr[right - left + 1]; //创建临时空间  for (int i = left; i &lt;= right; i++) {    tempArr[i - left] = arr[i];  }  // i，j分别为数组两部分的游标  int i = left, j = mid + 1;  for(int k = left; k &lt;= right; k++) {    //考虑越界的情况    if( i &gt; mid ) {      arr[k] = tempArr[j - left];      j ++;    }     else if(j &gt; right) {      arr[k] = tempArr[i - left];      i ++;    }    //不越界    else if(tempArr[i - left] &lt; tempArr[j - left]) {      arr[k] = tempArr[i - left];      i ++;    } else {      arr[k] = tempArr[j - left];      j ++;    }  }}/** * 递归使用归并排序，队arr[left, right]范围进行排序 */template &lt;typename T&gt;void __mergeSort(T arr[], int left, int right){  if (left &gt;= right) {    return;  }  int mid = (left + right) / 2;  __mergeSort(arr, left, mid);  __mergeSort(arr, mid + 1, right);  //将两个数组进行归并  if(arr[mid] &gt; arr[mid+1]) { //这个判断可以很大程度提升再接近有序时的性能    __merge(arr, left, mid, right);  }}</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><pre><code class="cpp">/** * shiftDown 沿着树不断调整位子  * 比较左右子树，是否有比自己大的，如果有就和大的那个交换位置 * 使得大的再上，小的在下 * 为了维持堆的特性，还得把那个交换到子树上的较小元素拿去尝试对他进行shiftDown */template &lt;typename T&gt;void __shiftDown(T arr, int pos, int len) {  while(2 * pos + 1 &lt; len){    int j = pos * 2 + 1;  //默认左孩子    if(j + 1 &lt; len) { //如果有右孩子      if(arr[j + 1] &gt; arr[j]) {        j += 1;      }    }    if(arr[pos] &lt; arr[j]) {      swap(arr[pos], arr[j]);      pos = j;  //--这步容易忘，因为是循环，所以每次都要对pos进行shiftDown--    } else {      break;    }  }}/** * 通用堆排序 */template &lt;typename T&gt;void heapSort(T arr[], int n){  //Heapify  for(int i = (n-1)/2; i &gt;= 0; i-- ) {    __shiftDown(arr, i, n);  }  //出堆，放到数组末尾  for(int i = n - 1; i &gt; 0; i--){    swap(arr[i], arr[0]);    __shiftDown(arr, 0, i);  }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>其他/错误监控</title>
    <link href="/uncategorized/%E5%85%B6%E4%BB%96/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/"/>
    <url>/uncategorized/%E5%85%B6%E4%BB%96/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h3><ul><li>资源加载错误</li><li>代码运行错误</li></ul><h3 id="错误的捕获方式"><a href="#错误的捕获方式" class="headerlink" title="错误的捕获方式"></a>错误的捕获方式</h3><p>即时运行错误的捕获方式</p><ul><li>try - catch</li><li>window.onerror</li></ul><p>资源加载错误</p><ul><li>object.onerror<ul><li>image标签、script标签上都可以加onerror事件</li><li>资源加载错误不会冒泡，但会捕获</li></ul></li><li>performance.getEntries()<ul><li>获取所有已经加载资源的获取时长</li></ul></li><li>window对象上通过事件捕获 Error事件</li></ul><p>注： addEventLitener(‘事件类型’, function(e){ /<em>回调函数</em>/ },捕获true或冒泡false ) </p><p>一般情况下错误监控都是在捕获的阶段进行。</p><h3 id="跨域的JS运行错误"><a href="#跨域的JS运行错误" class="headerlink" title="跨域的JS运行错误"></a>跨域的JS运行错误</h3><p>因为了，只知道错误，但是无法定位错误信息<br>解决方法：</p><ol><li>客户端，在script标签上增加crossorigin属性</li><li>服务端，设置JS资源响应头 <code>Access-Control-Allow-Origin: *</code></li></ol><h3 id="上报错误信息"><a href="#上报错误信息" class="headerlink" title="上报错误信息"></a>上报错误信息</h3><ol><li>采用Ajax通信上报</li><li>利用image对象的src属性上报</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>其他/hybird</title>
    <link href="/uncategorized/%E5%85%B6%E4%BB%96/hybird/"/>
    <url>/uncategorized/%E5%85%B6%E4%BB%96/hybird/</url>
    
    <content type="html"><![CDATA[<h1 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h1><h3 id="hybrid是什么，为何会使用hybrid"><a href="#hybrid是什么，为何会使用hybrid" class="headerlink" title="hybrid是什么，为何会使用hybrid"></a>hybrid是什么，为何会使用hybrid</h3><p>hybrid即”混合”，即前端和客户端的混合开发，某些环节也可能涉及server端</p><p>hybird存在的核心意义在于快速迭代，无需审核</p><p>具体实现：</p><ul><li>前端做好静态网页，将文件交给客户端</li><li>客户端拿到前端静态网页，以文件形式存储在app中</li><li>客户端在一个webview中</li><li>使用file协议加载静态页面</li></ul><h3 id="各技术适用场景"><a href="#各技术适用场景" class="headerlink" title="各技术适用场景"></a>各技术适用场景</h3><ul><li>使用NativeApp<ul><li>体验要求极致，变化不频繁</li></ul></li><li>使用hybrid<ul><li>体验要求高，变化频繁</li></ul></li><li>使用h5<br>-体验要求低，不常用</li></ul><h3 id="hybrid存在价值"><a href="#hybrid存在价值" class="headerlink" title="hybrid存在价值"></a>hybrid存在价值</h3><ul><li>可快速迭代更新</li><li>体验流畅</li><li>双端公用一套代码</li></ul><h3 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h3><ul><li>是app中的一个组件。</li><li>用于加载h5页面，即小型浏览器内核</li><li>只是单纯的展示一个网页界面 </li></ul><p><img src="../img/webview.png" srcset="/img/loading.gif" alt="webview"></p><h3 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h3><p>加载本地的资源<br><img src="../img/file.png" srcset="/img/loading.gif" alt="file"></p><h3 id="app发布后，静态文件如何实时更新？"><a href="#app发布后，静态文件如何实时更新？" class="headerlink" title="app发布后，静态文件如何实时更新？"></a>app发布后，静态文件如何实时更新？</h3><ul><li>将静态文件(html,css,js等)压缩成包，上传到服务端</li><li>客户端每次启动，都去服务端检查静态文件发布日期</li><li>如果服务端发布日期晚与客户端使用资源的发布日期，就去下载最新的压缩包</li><li>下载完成后解压，将现有文件覆盖</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试/自我介绍</title>
    <link href="/uncategorized/%E9%9D%A2%E8%AF%95/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    <url>/uncategorized/%E9%9D%A2%E8%AF%95/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><ul><li>基本信息、姓名、年龄、手机、邮箱、博客、籍贯</li><li>学历</li><li>工作经历，实践-公司-岗位-指责-技术栈-业绩</li><li>开源项目，Github说明</li></ul><h2 id="自我陈述"><a href="#自我陈述" class="headerlink" title="自我陈述"></a>自我陈述</h2><ul><li>把握面试的沟通方向</li><li>豁达、自信的适度发挥</li></ul><p>有的点自己是认证准备过的，当你秀这个的时候不要膨胀，是要面试官欣赏你就够了，你如果在某方面还显得鄙视面试官那就完了。</p><h2 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h2><p>当沿着一个问题问下去，碰到一个自己不会的问题的时候你要说请面试官指点启发一下，或者说我回去思考一下。不要说不懂算了，他会觉得你对技术没有追求。</p><p>面试时问题会有难有简单，刚开始问简单的问题时不要觉得不屑，一定要把节奏放的平缓。</p><p>切忌小聪明，要谦虚</p><p>聊的方向要对，聊项目时越细越好</p><p>碰到难题不要胆怯，好好思考，不要动不动说不会，要去猜、去思考，心态要平和</p><p>连续碰到几个答不上来的自己一定不要消极，要积极一些，不然面试官更没有兴趣来和你聊。 </p><p>难度大的面试就算过不了，也要提一些疑问，请教一下，争取在这场面试里收获点什么。 问问面试官应该看哪些资料补一下这些知识点，然后问问补完了是不是还可以再来投这个岗位。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试/README</title>
    <link href="/uncategorized/%E9%9D%A2%E8%AF%95/README/"/>
    <url>/uncategorized/%E9%9D%A2%E8%AF%95/README/</url>
    
    <content type="html"><![CDATA[<h3 id="如何看待面试"><a href="#如何看待面试" class="headerlink" title="如何看待面试"></a>如何看待面试</h3><p>考官与考生面对面交谈与观察为主要手段，测评考生的知识、能力、经验等有关素质的考试活动。</p><h3 id="考察重点"><a href="#考察重点" class="headerlink" title="考察重点"></a>考察重点</h3><p>校招考察的主要是能力和知识，经验是很少的。</p><h3 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h3><p>出现了什么问题，是怎么解决的</p><h3 id="面试环节"><a href="#面试环节" class="headerlink" title="面试环节"></a>面试环节</h3><ul><li>一面<ul><li>基础知识</li><li>围绕知识点进行考察</li></ul></li><li>二三面<ul><li>基础上的衍生</li><li>考察原理</li><li>让学生show一下自己研究的东西</li></ul></li><li>三四面<ul><li>负责人的考察</li><li>整体能力</li></ul></li><li>HR面<ul><li>具有一票否决权</li><li>沟通、性格、潜力</li></ul></li></ul><h3 id="职位描述分析"><a href="#职位描述分析" class="headerlink" title="职位描述分析"></a>职位描述分析</h3><p>根据面试时的职位描述来分析面试官会考察你哪些内容。</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>不会的、不熟悉的就不要画蛇添足</p><h3 id="态度"><a href="#态度" class="headerlink" title="态度"></a>态度</h3><ul><li>谦虚</li><li>内心诚实</li><li>回答灵活</li><li>回答不要咬定</li></ul><h3 id="基础面"><a href="#基础面" class="headerlink" title="基础面"></a>基础面</h3><ul><li>页面布局</li><li>CSS盒模型</li><li>DOM事件</li><li>HTTP协议</li><li>面向对象</li><li>原型链</li><li>通信</li><li>安全</li><li>算法</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统/进程与线程</title>
    <link href="/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h2><p>进程是<strong>资源分配</strong>的基本单位，用来管理资源（例如：内存，文件，网络等资源）</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。（PCB是描述进程的数据结构）</p><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h2><p>线程是<strong>独立调度</strong>的基本单位。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><h2 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h2><h3 id="（一）拥有资源"><a href="#（一）拥有资源" class="headerlink" title="（一）拥有资源"></a>（一）拥有资源</h3><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><h3 id="（二）调度"><a href="#（二）调度" class="headerlink" title="（二）调度"></a>（二）调度</h3><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p><h3 id="（三）系统开销"><a href="#（三）系统开销" class="headerlink" title="（三）系统开销"></a>（三）系统开销</h3><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><h3 id="（四）通信方面"><a href="#（四）通信方面" class="headerlink" title="（四）通信方面"></a>（四）通信方面</h3><p>进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统/死锁与银行家算法</title>
    <link href="/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E4%B8%8E%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <url>/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E4%B8%8E%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁概念、产生原因"><a href="#死锁概念、产生原因" class="headerlink" title="死锁概念、产生原因"></a>死锁概念、产生原因</h3><p>死锁是指多个进程循环等待彼此占有的资源而无限期的僵持等待下去的局面。原因是：</p><ul><li>系统提供的资源太少了，远不能满足并发进程对资源的需求</li><li>进程推进顺序不合适，互相占有彼此需要的资源，同时请求对方占有的资源，往往是程序设计不合理</li></ul><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p>需要同时具有以下四个条件：</p><ul><li>互斥条件：即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有</li><li>不可抢占条件：进程所获得的资源在未使用完毕之前，资源申请者不能强行的从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放</li><li>占有且等待条件：进程至少已经占有了一个资源，但又申请了一个新的被其他进程所占有的资源，此时处于等待状态</li><li>循环等待条件：若干个进程形成环形链，每个都占用对方申请的下一个资源</li></ul><h2 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h2><p>为使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一，或者允许死锁产生，但当死锁发生时能检测出思索，并有能力实现恢复。<br>一般有死锁的预防、死锁避免、死锁的检测与恢复三种方法。</p><ol><li>死锁预防：破坏导致死锁必要条件中的任意一个就可以预防死锁。例如，要求用户申请资源时一次性申请所需要的全部资源，这就破坏了保持和等待条件；将资源分层，得到上一层资源后，才能够申请下一层资源，它破坏了环路等待条件。预防通常会降低系统的效率。</li><li>死锁避免：避免是指进程在每次申请资源时判断这些操作是否安全，例如，使用银行家算法。死锁避免算法的执行会增加系统的开销。</li><li>死锁检测：死锁预防和避免都是事前措施，而死锁的检测则是判断系统是否处于死锁状态，如果是，则执行死锁解除策略。</li><li>死锁解除：这是与死锁检测结合使用的，它使用的方式就是剥夺。即将某进程所拥有的资源强行收回，分配给其他的进程。</li></ol><h3 id="死锁预防："><a href="#死锁预防：" class="headerlink" title="死锁预防："></a>死锁预防：</h3><ul><li>打破互斥条件：允许进程同时访问资源（有些资源就是不可以同时访问的，无实用价值）</li><li>打破不可抢占条件：比如给进程设置优先级，高优先级的可以抢占资源(实现困难，降低系统性能)</li><li>打破占有且等待条件：实行资源预分配策略，即进程在运行前一次性的向系统申请它所需要的全部资源(不可预测资源的使用，利用率低，降低并发性)</li><li>破坏循环等待条件：采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出（限制和编号实现困难，增加系统开销，有些资源暂时不用也需要先申请，增加了进程对资源的占用时间）</li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>允许进程动态的申请资源，但系统在进行资源分配前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源你分配给进程，否则，让进程等待。</p><p>所谓安全状态，是指系统能按某种进程推进顺序，为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，是每个进程都可以顺序的完成。此时成P1P2P3…为安全序列，如果系统无法找到一个安全序列，则称系统处于不安全状态。</p><p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。<br><strong>银行家算法</strong>是最著名的死锁避免算法。</p><h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p>资源分配图&amp;&amp;死锁定理</p><h3 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h3><ol><li>资源剥夺法。挂起某些思索进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源时，而处于资源匮乏的状态。</li><li>进程撤销法。强制撤销一个或一部分进程并剥夺这些进程的资源。撤销的原则可以按进程的优先级和撤销进程代价的高低进行。</li><li>进程回退法。让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>当一个进程申请使用资源的时候，银行家算法通过先<strong>试探分配</strong>给该进程资源，然后通过安全性算法<strong>判断分配后的系统是否处于安全状态</strong>，若不安全则试探分配作废，让该进程继续等待。<br><img src="../img/yhjsf.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>银行家算法中的进程：</p><ul><li>包含进程Pi的需求资源数量（也是<strong>最大需求资源数量</strong>，MAX）</li><li><strong>已分配</strong>给该进程的资源A（Allocation）</li><li><strong>还需要</strong>的资源数量N（Need=M-A）</li></ul></li><li><p>Available为<strong>空闲资源数量</strong>，即资源池（注意：资源池的剩余资源数量+已分配给所有进程的资源数量=系统中的资源总量）</p></li></ul><p>假设资源P1申请资源，银行家算法先试探的分配给它（当然先要看看当前资源池中的资源数量够不够）。<br>若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态）。</p><p>若有进程可执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其它进程，若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列。</p><p>如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0<br>–&gt;<br>回收（Work+已分配给P0的A0=Work）<br>–&gt;<br>分配给P3–&gt;回收（Work+A3=Work）<br>–&gt;<br>分配给P2<br>–&gt;<br>······<br>满足所有进程</p><p>如此就可避免系统存在潜在死锁的风险。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统/README</title>
    <link href="/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/README/"/>
    <url>/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/README/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>参考资源：<a href="https://frank-lam.github.io/fullstack-tutorial/#/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">https://frank-lam.github.io/fullstack-tutorial/#/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</a></p><h3 id="CPU组成"><a href="#CPU组成" class="headerlink" title="CPU组成"></a>CPU组成</h3><p>CPU是由运算器和控制器这两个部分组成的。</p><p>1、运算器由算术逻辑单元（ALU）、累加器、状态寄存器、通用寄存器组等组成。算术逻辑运算单元（ALU）的基本功能为加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、求补等操作。</p><p>计算机运行时，运算器的操作和操作种类由控制器决定。运算器处理的数据来自存储器；处理后的结果数据通常送回存储器，或暂时寄存在运算器中。与Control Unit共同组成了CPU的核心部分。</p><p>2、控制器分组合逻辑控制器和微程序控制器，两种控制器各有长处和短处。组合逻辑控制器设计麻烦，结构复杂，一旦设计完成，就不能再修改或扩充，但它的速度快。</p><p>微程序控制器设计方便，结构简单，修改或扩充都方便，修改一条机器指令的功能，只需重编所对应的微程序；</p><p>要增加一条机器指令，只需在控制存储器中增加一段微程序，但是，它是通过执行一段微程。具体对比如下：组合逻辑控制器又称硬布线控制器，由逻辑电路构成，完全靠硬件来实现指令的功能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/防抖节流</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h3><p>函数防抖就是在函数需要频繁触发的情况下，只有足够的空闲时间，才执行一次。 </p><p>典型应用</p><ul><li>百度搜索框在输入稍有停顿时才更新推荐热词。</li><li>拖拽</li></ul><pre><code class="js">function debounce(handler, delay){  delay = delay || 300;  var timer = null;  return function(){    var _self = this,        _args = arguments;    clearTimeout(timer);    timer = setTimeout(function(){      handler.apply(_self, _args);    }, delay);  }}</code></pre><p>防抖函数为什么要记录<code>this</code>和参数的例子： <a href="./debounce-demo.js">debounce-demo.js</a></p><h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h3><p>一个函数只有在大于执行周期时才执行，周期内调用不执行。好像水滴积攒到一定程度才会触发一次下落一样。</p><p>典型应用： </p><ul><li><p>抢券时疯狂点击，既要限制次数，又要保证先点先发出请求</p></li><li><p>窗口调整</p></li><li><p>页面滚动</p><pre><code class="js">function throttle(handler, wait){wait = wait || 300;var lastTime = 0;return function(){ var _self = this, _args = arguments; var nowTime = new Date().getTime(); if((nowTime - lastTime) &gt; wait){   handler.apply(_self, _args);   lastTime = nowTime; }}}</code></pre></li></ul><p>复杂但好用版：</p><pre><code class="js">function throttle(fn, interval, context, firstTime) {  let timer;  firstTime = typeof firstTime !== &#39;undefined&#39; ? firstTime : true;  return function() {    let args = arguments;    let __me = this;    if (typeof context !== &#39;undefined&#39;) {      __me = context;    }    if (firstTime) {      fn.apply(__me, args);      return (firstTime = false);    }    if (timer) {      return false;    }    timer = setTimeout(function() {      clearTimeout(timer);      timer = null;      fn.apply(__me, args);    }, interval);  };}</code></pre><h3 id="节流与防抖的本质"><a href="#节流与防抖的本质" class="headerlink" title="节流与防抖的本质"></a>节流与防抖的本质</h3><p>以闭包的形式存在，通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用<strong>定时器</strong>或<strong>时间差</strong>来控制事件的触发频率。<br><img src="../img/fdjl.png" srcset="/img/loading.gif" alt="fdjl"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/闭包</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E9%97%AD%E5%8C%85/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a>闭包问题</h1><h3 id="循环中赋值为引用的问题"><a href="#循环中赋值为引用的问题" class="headerlink" title="循环中赋值为引用的问题"></a>循环中赋值为引用的问题</h3><pre><code class="js">for (var i = 1; i &lt; 5; i++) {  setTimeout(function timer() {    console.log(i)  }, i * 1000)}</code></pre><p>解决方法有3种</p><p>第一种，使用<code>立即执行函数</code>方式</p><pre><code class="js">for (var i = 1; i &lt; 5; i++) {  (fuction(j){    setTimeout(function timer() {      console.log(j)    }, j * 1000)  })(i)}</code></pre><p>第二种，使用ES6的<code>let</code></p><pre><code class="js">for (let i = 1; i &lt; 5; i++) {  setTimeout(function timer() {    console.log(i)  }, i * 1000)}</code></pre><p>第三种，使用<code>setTimeout的第三个参数</code></p><pre><code class="js">for (var i = 1; i &lt; 5; i++) {  setTimeout(function timer(j) {    console.log(j)  }, i * 1000, i)}</code></pre><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>实现一个foo函数 可以这么使用:</p><pre><code class="js">a = foo();b = foo();c = foo();// a === 1;b === 2;c === 3;foo.clear();d = foo(); //d === 1;</code></pre><pre><code class="js">function myIndex() {    var index = 1;    function foo(){        return index++;    }    foo.clear = function() {        index = 1;    }    return foo;}var foo = myIndex();</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/观察者模式</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="JS观察者模式"><a href="#JS观察者模式" class="headerlink" title="JS观察者模式"></a>JS观察者模式</h1><blockquote><p>观察者模式:观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。而js中最常见的观察者模式就是事件触发机制。</p></blockquote><h3 id="先来个完整的"><a href="#先来个完整的" class="headerlink" title="先来个完整的"></a>先来个完整的</h3><pre><code class="js">class EventEmiter {  constructor () {    this.eventPool = {    //  &#39;eventName&#39;: []    }  }  listen(eventName, callback) {    if(this.eventPool[eventName]) {      if(this.eventPool[eventName].indexOf(callback) === -1) {        this.eventPool[eventName].push(callback)      }    } else {      this.eventPool[eventName] = [callback]    }  }  // trigger是有参数的  trigger(eventName, ...args) {    if(this.eventPool[eventName]) {      this.eventPool[eventName].forEach(cb =&gt; cb(...args))    }  }  remove(eventName, callback) {    if(this.eventPool[eventName]) {        let cbIndex = this.eventPool[eventName].indexOf(callback)        this.eventPool[eventName].splice(cbIndex, 1)    }  }  once(eventName, callback) {    this.listen(eventName, function _cb(...args) {      callback(...args);      this.remove(eventName, _cb)    })    }}</code></pre><p><a href="https://www.jianshu.com/p/10a20df72bf2" target="_blank" rel="noopener">ES5/ES6实现观察者模式(自定义事件) - 简书</a></p><h3 id="先搭架子"><a href="#先搭架子" class="headerlink" title="先搭架子"></a>先搭架子</h3><ol><li>要有一个对象，存储着它自己的触发函数。而且这个对象的触发函数可能有很多种，比如一个onclick可能触发多个事件，那么handler的属性应该是一个数组，每个数组的值都是一个函数。</li></ol><pre><code class="js">handler={  type1:[func1,func2...],  type2:[func3,func4...],  ...}</code></pre><p>现在这个对象的主体部分已经思考好了，现在就是要它‘动起来’，给它添加各种动作。<br>一个事件可能有哪些动作呢？</p><ul><li>add：添加事件某种类型的函数，</li><li>remove: 移除某种类型的函数，</li><li>fire：触发某种类型的函数,</li><li>once:触发某种类型的函数，然后移除掉这个函数</li></ul><p>现在，自定义事件的架子已经搭建好了</p><pre><code class="js">eventOb={  //函数储存  handler:{    type1:[func1,func2...],    type2:[func2,func4...],    ...  },  //主要事件  add:function(){},  remove:function(){},  fire:function(){},  once:function(){},}</code></pre><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>添加一个事件监听，首先传入参数应该是 事件类型type，和触发函数 func，传入的时候检测有没有这个函数，有了就不重复添加。</p><pre><code class="js">add:function (type,func) {  //检测type是否存在  if(eventOb.handleFunc[type]){    //检测事件是否存在，不存在则添加    if(eventOb.handleFunc[type].indexOf(func)===-1){      eventOb.handleFunc[type].push(func);    }  }  else{    eventOb.handleFunc[type]=[func];  }},</code></pre><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>remove有一个潜在的需求，就是如果你的事件不存在，它应该会报错。而这里不会报错，index在func不存在的时候是-1；这时候要报错。</p><pre><code class="js">remove:function (type,func) {  try{    let target = eventOb.handleFunc[type];    let index = target.indexOf(func);    if(index===-1) throw error;    target.splice(index,1);  }catch (e){      console.error(&#39;别老想搞什么飞机，删除我有的东西！&#39;);  }},</code></pre><h3 id="fire"><a href="#fire" class="headerlink" title="fire"></a>fire</h3><p>触发一个点击事件肯定是要触发它全部的函数，这里也是一样，所以只需要传入type，然后事件可能不存在，像上面一样处理。</p><pre><code class="js">fire:function (type,func) {  try{    let target = eventOb.handleFunc[type];    let count = target.length;    for (var i = 0; i &lt; count; i++) {      //加()使立即执行      target[i]();    }      }  catch (e){    console.error(&#39;别老想搞什么飞机，触发我有的东西！&#39;);  }},</code></pre><p>但会有问题，我只想触发并且删除某个事件怎么办，fire一下就全触发了呀。<br>所以fire的问题就显现出来了。我们还是要给它一个func，但是可选。</p><pre><code class="js">fire:function (type,func) {  try{    let target = eventOb.handleFunc[type];    if(arguments.length===1) {      //不传func则全部触发      let count = target.length;      for (var i = 0; i &lt; count; i++) {          target[i]();      }    }else{      //传func则触发func      let index=target.indexOf(func);      if(index===-1)throw error;      func();    }    //need some code  }catch (e){    console.error(&#39;别老想搞什么飞机，触发我有的东西！&#39;);    //need some code  }},</code></pre><h3 id="once"><a href="#once" class="headerlink" title="once"></a>once</h3><p>fire，然后remove</p><pre><code class="js">once (event, callback) {  this.fire(event, (...args) =&gt; {      callback(...args);      this.remove(event)  })}</code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="js">class eventObs {  constructor(){    this.handleFunc={}  }  add(type,func){    if(this.handleFunc[type]){        if(this.handleFunc[type].indexOf(func)===-1){            this.handleFunc[type].push(func);        }    }else{        this.handleFunc[type]=[func];    }  };  fire(type,func){    try{      if(arguments.length===1) {          let target = this.handleFunc[type];          let count = target.length;          for (var i = 0; i &lt; count; i++) {              target[i]();          }      }else{          let target = this.handleFunc[type];          let index=target.indexOf(func);          if(index===-1)throw error;          func();      }      return true;    }catch (e){        console.error(&#39;别老想搞什么飞机，触发我有的东西！&#39;);        return false;    }  };  remove(type,func){      try{          let target = this.handleFunc[type];          let index=target.indexOf(func);          if(index===-1)throw error;          target.splice(index,1);      }catch (e){          console.error(&#39;别老想搞什么飞机，删除我有的东西！&#39;);      }  };  once(type,func) {    this.fire(type, func)    ? this.remove(type, func)    : null;  }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/类型判断</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="实现一个类型判断函数"><a href="#实现一个类型判断函数" class="headerlink" title="实现一个类型判断函数"></a>实现一个类型判断函数</h3><ol><li>判断null</li><li>判断基础类型</li><li>使用<code>Object.prototype.toString.call(target)</code>来判断<strong>引用类型</strong></li></ol><p>注意： 一定是使用<code>call</code>来调用，不然是判断的Object.prototype的类型<br>之所以要先判断是否为基本类型是因为：虽然<code>Object.prototype.toString.call()</code>能判断出某值是：number/string/boolean，但是其实在包装的时候是把他们先转成了对象然后再判断类型的。 但是JS中包装类型和原始类型还是有差别的，因为对一个包装类型来说，typeof的值是object</p><pre><code class="javascript">/** * 类型判断 */function getType(target) {  //先处理最特殊的Null  if(target === null) {    return &#39;null&#39;;  }  //判断是不是基础类型  const typeOfT = typeof target  if(typeOfT !== &#39;object&#39;) {    return typeOfT;  }  //肯定是引用类型了  const template = {    &quot;[object Object]&quot;: &quot;object&quot;,    &quot;[object Array]&quot; : &quot;array&quot;,    &quot;[object Function]&quot;: &quot;function&quot;,    // 一些包装类型    &quot;[object String]&quot;: &quot;object - string&quot;,    &quot;[object Number]&quot;: &quot;object - number&quot;,    &quot;[object Boolean]&quot;: &quot;object - boolean&quot;  };  const typeStr = Object.prototype.toString.call(target);  return template[typeStr];}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/深浅拷贝</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是拷贝第一层的拷贝</p><p>使用<code>Object.assign</code>解决这个问题。</p><pre><code class="js">let a = {  age: 1}let b = Object.assign({}, a)a.age = 2console.log(b.age) // 1</code></pre><p>通过展开运算符 <code>...</code> 来实现浅拷贝</p><pre><code class="js">let a = {  age: 1}let b = {...a};a.age = 2;console.log(b.age)  // 1</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>简单的做法：<code>JSON.parse(JSON.stringfy(obj))</code><br>但是该方法也是有局限性的：</p><ul><li>会忽略<code>undefined</code></li><li>会忽略<code>symbol</code>  </li><li>会忽略函数   </li><li>不能解决循环引用的对象 （会抱错）</li></ul><p>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 <a href="https://www.jianshu.com/p/4f07ef18b5d7" target="_blank" rel="noopener"><code>MessageChannel</code></a></p><p><strong>自封装深拷贝</strong><br>思路：</p><ol><li>使用for-in遍历对象</li><li>因为for-in会遍历原型链上的属性，所以需要判断属性是否在原型链上，不是原型链才拷贝</li><li>判断属性值类型是原始类型和引用类型</li><li>原始类型直接赋值（注意null）</li><li>引用类型判断是对象还是数组，<strong>创建对应的空对象或空数组</strong>，递归调用函数，将值赋值进去</li></ol><pre><code class="js">/** * 深度克隆 * @param   origin 被拷贝的原对象 * @param   target 拷贝出来的对象 * @return         拷贝出来的对象 */function deepClone(origin, target) {  if(typeof(origin) !== &#39;object&#39; || origin) {    return origin;  }  target = target || {};  for(let prop in origin) {   //使用 for-in    if(origin.hasOwnProperty(prop)) { //不是原型链上的      if(typeof(origin[prop]) === &#39;object&#39; &amp;&amp; origin[prop] ) { //是对象        // 先判断是不是数组        if(origin[prop] instanceof Array) {          target[prop] = [];          deepClone(origin[prop], target[prop]);        } else {          target[prop] = {};          deepClone(origin[prop], target[prop]);        }      }       else {        target[prop] = origin[prop];      }    }  }  return target;}</code></pre><h3 id="深拷贝-BFS"><a href="#深拷贝-BFS" class="headerlink" title="深拷贝 - BFS"></a>深拷贝 - BFS</h3><pre><code class="js">// 如果是对象/数组，返回一个空的对象/数组，// 都不是的话直接返回原对象function getEmptyArrOrObj(item) {  let itemType = Object.prototype.toString.call(item)   if(itemType === &#39;[object Array]&#39;) {    return []  }  if(itemType === &#39;[object Object]&#39;) {    return {}  }  return item}function deepCopyBFS(origin) {  const queue = []  const map = new Map() // 记录出现过的对象，处理环  let target = getEmptyArrOrObj(origin)  if(target !== origin) {    // 说明origin是一个对象或数组，需要拷贝子代    queue.push([origin, target]);    map.set(origin, target)  }  while(queue.length) {    let [ori, tar] = queue.shift(); // 出队    for(let key in ori) {      if(ori.hasOwnProperty(key)) { // 不在原型上        if(map.get(ori[key])) { // 处理环          tar[key] = map.get(ori[key])          continue        }        tar[key] = getEmptyArrOrObj(ori[key]);        if(tar[key] !== ori[key]) {          queue.push(ori[key], tar[key])          map.set(ori[key], tar[key])        }      }    }  }  return target}</code></pre><h3 id="深拷贝-DFS"><a href="#深拷贝-DFS" class="headerlink" title="深拷贝 - DFS"></a>深拷贝 - DFS</h3><pre><code class="js">function deepCopyDFS(origin){    let stack = [];    let map = new Map(); // 记录出现过的对象，用于处理环    let target = getEmptyArrOrObj(origin);    if(target !== origin){        stack.push([origin, target]);        map.set(origin, target);    }    while(stack.length){        let [ori, tar] = stack.pop();        for(let key in ori){      if(ori.hasOwnProperty(key)) { // 不在原型上        // 处理环状        if(map.get(ori[key])){          tar[key] = map.get(ori[key]);          continue;        }        tar[key] = getEmptyArrOrObj(ori[key]);        if(tar[key] !== ori[key]){          stack.push([ori[key], tar[key]]);          map.set(ori[key], tar[key]);        }      }        }    }    return target;}</code></pre><p><a href="./deepCopy.js">测试上面的两个 deepCopy</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/柯里化</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="curry"><a href="#curry" class="headerlink" title="curry"></a>curry</h1><p>柯里化（英语：Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。</p><p>实现一个add方法，使计算结果能够满足如下预期：</p><pre><code class="js">add(1)(2)(3) = 6add(1, 2)(3) = 10</code></pre><p>实现方法： 做一个闭包，返回一个函数，这个函数每次执行会改写闭包里面记录参数的数组。当这个函数判断参数个数够了，就去执行它。</p><pre><code class="js">function curry(func) {    // 存储已传入参数    let _args = []    // 做一个闭包    function _curry(...args) {        // 把参数合并        _args = _args.concat(args)        // 如果参数够了就执行        if (_args.length &gt;= func.length) {            const result = func(..._args)            _args = []            return result;        }        // 继续返回此函数         else {            return _curry        }    }    return _curry}</code></pre><pre><code class="js">// 测试代码function add1(a, b, c) {    return a + b + c}let testAdd = curry(add1)console.log(testAdd(1)(2)(3))console.log(testAdd(1, 2)(3))console.log(testAdd(1)(2, 3))</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/手写Promise</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E6%89%8B%E5%86%99Promise/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E6%89%8B%E5%86%99Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>先看看Promise是怎么用的</p><pre><code class="js">new MyPromise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve(1)  }, 0)}).then(value =&gt; {  console.log(value)})</code></pre><p>在Promise的构造器中传入一个函数，这个函数有两个参数 resolve和reject，这两个参数都是Promise的回调函数，不需要自己写，在需要的时候调用就可以了，他们分别是成功的回调resolve和失败的回调reject。</p><h3 id="简易版-Promise"><a href="#简易版-Promise" class="headerlink" title="简易版 Promise"></a>简易版 Promise</h3><p><strong>第一步</strong>，先来搭建构建函数的大体框架</p><pre><code class="js">const PENDING = &#39;pending&#39;const RESOLVED = &#39;resolved&#39;const REJECTED = &#39;rejected&#39;function MyPromise(fn){  const that = this  that.state = PENDING  that.value = null  that.resolvedCallbacks = []  that.rejectedCallbacks = []  // 待完善 resolve 和 reject 函数  // 待完善执行 fn 函数}</code></pre><ul><li>首先创建三个常量用于表示状态，对于经常使用的一些值应该通过常量来管理，便于开发及后期维护</li><li>在函数体内部首先创建常量that，因为代码可能会异步执行，用于获取正确的this对象</li><li>一开始Promise的状态是 pending</li><li>value 变量用于保存resolve或者reject中传入的值</li><li>resolvedCallbacks和rejectedCallback用于保存then中的回调，因为当执行完Promise时状态可能还是等待中，这时候应该把then中的回调保存起来用于状态改变时使用</li></ul><p><strong>第二步</strong>，完善resolve和reject函数，添加在 MyPromise 函数体内部</p><pre><code class="js">function resolve(value) {  if(that.state === PENDING) {    that.state = RESOLVED    that.value = value    that.resolvedCallbacks.map(cb =&gt; cb(that.value))  }}function reject(value) {  if(that.state === PENDING){    that.state = REJECTED    that.value = value;    that.rejectedCallbacks.map(cb =&gt; cb(that.value));  }}</code></pre><ul><li>首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态</li><li>将当前状态更改为对应状态，并且将传入的值赋值给 value</li><li>遍历回调数组并执行</li></ul><p><strong>第四步</strong>，实现如何执行 Promise 中传入的函数了</p><pre><code class="js">try {  fn(resolve, reject)} catch (e) {  reject(e)}</code></pre><ul><li>实现很简单，执行传入的参数并且将之前两个函数当做参数传进去</li><li>要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数</li></ul><p><strong>第五步</strong>，实现较为复杂的 then 函数。</p><p>then函数是在Promise构造器中成功状态下调用的resolve方法的回调。</p><p>then函数是可以接收两个参数的，一个是用户自定义的成功处理，另一个是用户自定义的错误处理，第二个参数可不传。</p><pre><code class="js">MyPromise.prototype.then = function(onFulfilled, onRejected) {  const that = this  //对传入的两个参数做判断，如果不是函数将其转为函数  onFulfilled =     typeof onFulfilled === &#39;function&#39;    ? onFulfilled     : v =&gt; v  // onFulfilled = v =&gt; v  onRejected =     typeof onRejected === &#39;function&#39;    ? onRejected    : r =&gt; {      throw r    }  if(that.state === PENDING) {    that.resolvedCallbacks.push(onFulfilled)    that.rejectedCallbacks.push(onRejected)  }  else if(that.state === RESOLVED) {    onFulfilled(that.value)  }  else {    onRejected(that.value)  }}</code></pre><ul><li>首先判断两个参数是否为函数类型，因为这两个参数是可选参数</li><li>当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码<pre><code class="js">// 该代码目前在简单版中会报错// 只是作为一个透传的例子Promise.resolve(4).then().then((value) =&gt; console.log(value))</code></pre></li><li>接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数，比如如下代码就会进入等待态的逻辑</li></ul><h3 id="pormise完整代码"><a href="#pormise完整代码" class="headerlink" title="pormise完整代码"></a><a href="./promise.js">pormise完整代码</a></h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/异步编程</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="promise与setTimeout-判断执行顺序"><a href="#promise与setTimeout-判断执行顺序" class="headerlink" title="promise与setTimeout 判断执行顺序"></a>promise与setTimeout 判断执行顺序</h3><p>promise和setTimeout都会将事件放入异步队列，但setTimeout即便是写0，也会有4ms的延迟</p><pre><code class="js">console.log(&#39;begin&#39;);setTimeout(() =&gt; {  console.log(&#39;setTimeout 1&#39;);  Promise.resolve()    .then(() =&gt; {      console.log(&#39;promise 1&#39;);      setTimeout(() =&gt; {          console.log(&#39;setTimeout2&#39;);      });    })    .then(() =&gt; {      console.log(&#39;promise 2&#39;);    });  new Promise(resolve =&gt; {    console.log(&#39;a&#39;);    resolve();  }).then(() =&gt; {    console.log(&#39;b&#39;);  });}, 0);console.log(&#39;end&#39;);</code></pre><p>答案</p><pre><code>beginendsetTimeout 1apromise 1bpromise 2setTimeout2</code></pre><h3 id="async函数的使用"><a href="#async函数的使用" class="headerlink" title="async函数的使用"></a>async函数的使用</h3><pre><code class="js">function repeat(func, times, wait) {}// 输入const repeatFunc = repeat(alert, 4, 3000);// 输出// 会alert4次 helloworld, 每次间隔3秒repeatFunc(&#39;hellworld&#39;);// 会alert4次 worldhellp, 每次间隔3秒repeatFunc(&#39;worldhello&#39;)</code></pre><p>我自己的实现，没有成功。这种实现是setTimeout新建了两个，然而只清理了一个。</p><pre><code class="js">function repeat(func, times, wait) {  var timer = null;  var count = 0;  return function(...args) {    timer = setInterval(function() {      func.apply(null, args);      count ++;      console.log(&#39;count&#39;, count, &quot;times&quot;, times)      if( count &gt;= times) {        clearInterval(timer);      }    }, wait);  }}// 输入const repeatFunc = repeat(console.log, 4, 3000);// 输出// 会alert4次 helloworld, 每次间隔3秒repeatFunc(&#39;hellworld&#39;);// 会alert4次 worldhellp, 每次间隔3秒repeatFunc(&#39;worldhello&#39;);</code></pre><p>正确解法：使用 async/await来实现</p><pre><code class="js">async function wait(seconds) {    return new Promise((res) =&gt; {        setTimeout(res, seconds);    });}function repeat(func, times, s) {    return async function (...args) {        for (let i = 0; i &lt; times; i++) {            func.apply(null, args);            await wait(s);        }    };}let log = console.loglet repeatFunc = repeat(log,4,3000)repeatFunc(&#39;HelloWorld&#39;)repeatFunc(&#39;WorldHello&#39;)</code></pre><h3 id="async执行练习"><a href="#async执行练习" class="headerlink" title="async执行练习"></a>async执行练习</h3><ul><li>await后面的才是异步的，之前都是同步的</li></ul><pre><code class="js">async function async1() {  console.log(&#39;async1 start&#39;);  // 2  await async2();  console.log(&#39;async1 end&#39;);    // 6}async function async2() {       console.log(&#39;async2&#39;);        // 3}console.log(&#39;script start&#39;);    //  1setTimeout(function() {  console.log(&#39;setTimeout&#39;);    // 8}, 0);async1();new Promise(function(resolve) {  console.log(&#39;promise1&#39;);      // 4    resolve();  }).then(function() {      console.log(&#39;promise2&#39;);  // 7  });console.log(&#39;script end&#39;);      // 5</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/实现一个sleep函数</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsleep%E5%87%BD%E6%95%B0/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsleep%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="实现一个-sleep-函数"><a href="#实现一个-sleep-函数" class="headerlink" title="实现一个 sleep 函数"></a>实现一个 sleep 函数</h2><p>比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><pre><code class="js">const sleep = time =&gt;{    new Promise((resolve) =&gt; {        setTimeout(resolve, time)    })}sleep(1000).then(() =&gt; {    console.log(1)})</code></pre><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><pre><code class="js">function *sleep(time) {    yield new Promise(resolve =&gt; {        setTimeout(resolve, time)    })}sleep(1000).next().value.then(() =&gt; {    console.log(1)})</code></pre><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><pre><code class="js">async function sleep(time, func) {    await new Promise(resolve =&gt; setTimeout(resolve, time))    return func()}sleep(1000, () =&gt; {    console.log(1)})</code></pre><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><pre><code class="js">function sleep(callback,time) {  if(typeof callback === &#39;function&#39;)    setTimeout(callback,time)}function output(){  console.log(1);}sleep(output,1000);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/实现flatten函数</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E5%AE%9E%E7%8E%B0flatten%E5%87%BD%E6%95%B0/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E5%AE%9E%E7%8E%B0flatten%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="实现-flatten-函数"><a href="#实现-flatten-函数" class="headerlink" title="实现 flatten 函数"></a>实现 flatten 函数</h2><pre><code class="js">let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]]</code></pre><h3 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h3><p>每次拿数组的第一个元素，当判断第一个元素是数组的时候，使用<code>arrs.unshift(...item)</code>来</p><pre><code class="js">function flatten(arr) {    let arrs =[...arr]    let newArr = [];    while (arrs.length) {        let item = arrs.shift()        if(Array.isArray(item)){            arrs.unshift(...item)           }else {            newArr.push(item)        }    }    return newArr}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/使用Promise封装一个AJAX</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E4%BD%BF%E7%94%A8Promise%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAAJAX/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E4%BD%BF%E7%94%A8Promise%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAAJAX/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-Promise-封装一个-AJAX"><a href="#使用-Promise-封装一个-AJAX" class="headerlink" title="使用 Promise 封装一个 AJAX"></a>使用 Promise 封装一个 AJAX</h1><h3 id="ajax-的-xhr-对象的-7-个事件"><a href="#ajax-的-xhr-对象的-7-个事件" class="headerlink" title="ajax 的 xhr 对象的 7 个事件"></a>ajax 的 xhr 对象的 7 个事件</h3><ul><li>onloadstart<ul><li>开始send触发</li></ul></li><li>onprogress<ul><li>从服务器上下载数据每50ms触发一次</li></ul></li><li>onload<ul><li>得到响应</li></ul></li><li>onerror<ul><li>服务器异常</li></ul></li><li>onloadend<ul><li>请求结束，无论成功失败</li></ul></li><li>onreadystatechange<ul><li>xhr.readyState改变使触发</li></ul></li><li>onabort<ul><li>调用xhr.abort时触发</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code class="js">const ajax = (obj) =&gt; {    return new Promise((resolve, reject) =&gt; {        let method = obj.method || &#39;GET&#39;        // 创建 xhr        let xhr        if(window.XMLHTTPRequest) {            xhr = new XMLHTTPRequest();        } else {            xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)        }        // 超时        xhr.ontimeout = function () {            reject({                errorType: &#39;timeout_error&#39;,                xhr: xhr            });        }        // 报错        xhr.onerror = function () {            reject({                errorType: &#39;onerror&#39;,                xhr: xhr            })        }        // 监听 statuschange        xhr.onreadystatechange = function() {            if(xhr.readState === 4) {                if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) {                    resolve(xhr.responseText)                } else {                    reject({                        errorType: &#39;onerror&#39;,                        xhr: xhr                    })                }            }        }        // 发送请求        if(method === &#39;POST&#39;) {            xhr.open(&#39;POST&#39;, obj.url, true);            xhr.responseType = &#39;json&#39;;            xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);            xhr.send(JSON.parse(obj.data));        } else {            let query = &#39;&#39;            for(let key in obj.data) {                query += `&amp;${encodeURIComponent(key)}=${encodeURIComponent(obj.data[key])}`            }            // The substring() method returns the part of the string between the start and end indexes, or to the end of the string.            query.substring(1)            xhr.open(&#39;GET&#39;, obj.url, + &#39;?&#39; + query, true);            xhr.send()        }    })}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/作用域</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<pre><code class="js">function func() {  function a () {    console.log(b)  }  a();  const b = &#39;bbb&#39;}func()</code></pre><p>上面代码会输出什么？</p><p>答案：</p><blockquote><p> ReferenceError: Cannot access ‘b’ before initialization</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/两任务并行</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E4%B8%A4%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/%E4%B8%A4%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>要求任务并行完成，同时并行的任务不能超过两个。</p><pre><code class="js">class Scheduler {  add(promiseCreator) {    // 需要实现  }}const timeout = time =&gt;  new Promise(resolve =&gt; {    console.log(&#39;in timeout:&#39;, time)    setTimeout(resolve, time)  })const scheduler = new Scheduler()const addTask = (time, order) =&gt; {  scheduler.add(() =&gt; timeout(time)).then(() =&gt; console.log(order))}addTask(1000, &#39;1&#39;)addTask(500, &#39;2&#39;)addTask(300, &#39;3&#39;)addTask(400, &#39;4&#39;)// output: 2 3 1 4// 一开始，1、2 两个任务进入队列// 500ms 时，2 完成，输出 2，任务 3 进队// 800ms 时，3 完成，输出 3，任务 4 进队// 1000ms 时，1 完成，输出 1// 1200ms 时，4 完成，输出 4</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/this指向</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/this%E6%8C%87%E5%90%91/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/this%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><h3 id="头条一面"><a href="#头条一面" class="headerlink" title="头条一面"></a>头条一面</h3><p>请分别写出下面题目的答案。</p><pre><code class="js">function Foo() {    getName = function() {        console.log(1);    };    return this;}Foo.getName = function() {    console.log(2);};Foo.prototype.getName = function() {    console.log(3);};var getName = function() {    console.log(4);};function getName() {    console.log(5);}//请写出以下输出结果：Foo.getName();      //-&gt; 2    Foo对象上的getName() ，这里不会是3，因为只有Foo的实例对象才会是3，Foo上面是没有3的getName();          //-&gt; 4    window上的getName，console.log(5)的那个函数提升后，在console.log(4)的那里被重新赋值Foo().getName();    //-&gt; 1    在Foo函数中，getName是全局的getName，覆盖后输出 1getName();          //-&gt; 1    window中getName();new Foo.getName();  //-&gt; 2    Foo后面不带括号而直接 &#39;.&#39;，那么点的优先级会比new的高，所以把 Foo.getName 作为构造函数new Foo().getName();//-&gt; 3    此时是Foo的实例，原型上会有输出3这个方法</code></pre><h3 id="箭头函数中的this-判断"><a href="#箭头函数中的this-判断" class="headerlink" title="箭头函数中的this 判断"></a>箭头函数中的this 判断</h3><p>箭头函数里面的this是继承它作用域父级的this， 即声明箭头函数处的this</p><pre><code class="js">let a = {  b: function() {     console.log(this)   },  c: () =&gt; {    console.log(this)  }}a.b()   // aa.c()   // windowlet d = a.bd()     // window</code></pre><h3 id="this判断-下面输出为多少？"><a href="#this判断-下面输出为多少？" class="headerlink" title="this判断 下面输出为多少？"></a>this判断 下面输出为多少？</h3><pre><code class="js">var name1 = 1;function test() {    let name1 = &#39;kin&#39;;    let a = {        name1: &#39;jack&#39;,        fn: () =&gt; {      var name1 = &#39;black&#39;      console.log(this.name1)    }  }    return a;}test().fn() // ?</code></pre><p>答案： 输出1 </p><p>因为fn处绑定的是箭头函数，箭头函数并不创建this，它只会从自己的作用域链的上一层继承this。这里它的上一层是test()，非严格模式下test中this值为window。 </p><ul><li>如果在绑定fn的时候使用了function，那么答案会是 ‘jack’</li><li>如果第一行的 var 改为了 let，那么答案会是 undefind， 因为let不会挂到window上</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/reduce案例</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/reduce%E6%A1%88%E4%BE%8B/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/reduce%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[var array = [{    selector: 'sss',    rules: 'rrrr'},{    selector: 'sss2',    rules: 'rrr3'}];function transform(array, key, value) {    return array.reduce((obj, item) => {        obj[item[key]] = (obj[item[key]] || []).concat(item[value]);        return obj;    }, {});}var tree = transform(array, 'selector', 'rules' );console.log(tree)]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/reduce实现map</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/reduce%E5%AE%9E%E7%8E%B0map/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/reduce%E5%AE%9E%E7%8E%B0map/</url>
    
    <content type="html"><![CDATA[<h1 id="用reduce实现map的功能"><a href="#用reduce实现map的功能" class="headerlink" title="用reduce实现map的功能"></a>用reduce实现map的功能</h1><pre><code class="js">Array.prototype.map = function (callback) {    const array = this;    return array.reduce((acc, cur, index) =&gt; {        acc.push(callback(cur, index, array))        return acc    }, [])}</code></pre><p>测试：</p><pre><code class="js">var m = [1,2,3,4,5].map(function (v, i, arr) {    return v + v});console.log(m)</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/README</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/README/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/README/</url>
    
    <content type="html"><![CDATA[<h1 id="编程题与分析题"><a href="#编程题与分析题" class="headerlink" title="编程题与分析题"></a>编程题与分析题</h1><p>链接可能不够完整，直接看对应目录</p><ul><li><a href="bind、apply实现.md">bind、apply实现</a></li><li><a href="DOM树遍历.md">DOM树遍历</a></li><li><a href="README.MD">README</a></li><li><a href="this指向.md">this指向</a></li><li><a href="异步编程.md">异步编程</a></li><li><a href="深浅拷贝.md">深浅拷贝</a></li><li><a href="类型判断.md">类型判断</a></li><li><a href="观察者模式.md">观察者模式</a></li><li><a href="闭包.md">闭包</a></li><li><a href="防抖节流.md">防抖节流</a></li><li><a href="手写Promise.md">手写Promise</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/PromiseAll</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/PromiseAll/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/PromiseAll/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p>Promise.all 接收一个 promise 对象的数组作为参数，当这个数组里的所有 promise 对象全部变为resolve或 有 reject 状态出现的时候，它才会去调用 .then 方法,它们是并发执行的。</p><h3 id="Promise-all-简介"><a href="#Promise-all-简介" class="headerlink" title="Promise.all 简介"></a>Promise.all 简介</h3><p>Promise.all(promiseArray) 方法是 Promise 对象上的静态方法，该方法的作用是将多个 Promise 对象实例包装，生成并返回一个新的 Promise 实例。</p><p>参数：promiseArray，是一个 Promise 实例数组</p><pre><code class="js">var p1 = Promise.resolve(1),    p2 = Promise.reject(2),    p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) {    //then方法不会被执行    console.log(results);}).catch(function (e){    //catch方法将会被执行，输出结果为：2    console.log(2);});</code></pre><p>promise 数组中所有的 promise 实例都变为resolve 的时候，该方法才会返回，并将所有结果传递 results 数组中。promise 数组中任何一个 promise 为 reject 的话，则整个 Promise.all 调用会立即终止，并返回一个 reject 的新的 promise 对象。</p><h3 id="总结-promise-all-的特点"><a href="#总结-promise-all-的特点" class="headerlink" title="总结 promise.all 的特点"></a>总结 promise.all 的特点</h3><ol><li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象，</li><li>如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</li><li>如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</li><li>只要有一个失败，状态就变为 rejected，返回值将直接传递给回调<br>all() 的返回值也是新的 Promise 对象</li></ol><h3 id="实现-Promise-all-方法"><a href="#实现-Promise-all-方法" class="headerlink" title="实现 Promise.all 方法"></a>实现 Promise.all 方法</h3><pre><code class="js">function promiseAll(promises) {  return new Promise(function(resolve, reject) {    if(isArray(promises)) {        return reject(new Error(&#39;Promises must be an array&#39;))    }    var resolvedCount = 0;    var promiseNum = promises.length;    var resloveValue = [];    for(let i = 0; i &lt; promiseNum; i++) {        Promise.resolve(promises[i]).then((value) =&gt; {            resloveValue[i] = value;            resolvedCount++;            if(resolvedCount === promiseNum) {                return resloveValue;            }        }, (reason) =&gt; {            return reject(reason);        })    }  })}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/promise</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/promise/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/promise/</url>
    
    <content type="html"><![CDATA[const PENDING = 'pending'const RESOLVED = 'resolved'const REJECTED = 'rejected'function MyPromise(fn){  const that = this  that.state = PENDING  that.value = null  that.resolvedCallbacks = []  that.rejectedCallbacks = []    function resolve(value) {    if(that.state === PENDING) {      that.state = RESOLVED      that.value = value      that.resolvedCallbacks.map(cb => cb(that.value))    }  }    function reject(value) {    if(that.state === PENDING){      that.state = REJECTED      that.value = value;      that.rejectedCallbacks.map(cb => cb(that.value));    }  }  try {    fn(resolve, reject)  } catch (e) {    reject(e)  }}MyPromise.prototype.then = function(onFulfilled, onRejected) {  const that = this  //对传入的两个参数做判断，如果不是函数将其转为函数  onFulfilled =     typeof onFulfilled === 'function'    ? onFulfilled     : v => v  // onFulfilled = v => v  onRejected =     typeof onRejected === 'function'    ? onRejected    : r => {      throw r    }    if(that.state === PENDING) {    that.resolvedCallbacks.push(onFulfilled)    that.rejectedCallbacks.push(onRejected)  }  else if(that.state === RESOLVED) {    onFulfilled(that.value)  }  else {    onRejected(that.value)  }}new MyPromise((resolve, reject) => {  setTimeout(() => {    resolve('成功的回调数据')  }, 1000)}).then(value => {  console.log('Promise.then:  ', value)})]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/name的值是多少</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/name%E7%9A%84%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/name%E7%9A%84%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="下面的代码会输出什么？"><a href="#下面的代码会输出什么？" class="headerlink" title="下面的代码会输出什么？"></a>下面的代码会输出什么？</h2><pre><code class="js">function A(name) {  this.name = name || &#39;Tom&#39;  this.msg = &quot;use &#39;this.&#39; set in function&quot;}function B() {};B.prototype = A;var b = new B();console.log(b.name);console.log(b.msg);</code></pre><p>答案是：</p><pre><code>Aundefined</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>b.name</code>返回 <code>A</code>，是因为<code>b</code>上面没有<code>name</code>属性，他就会沿着原型链向上查找，然而 <code>b.__proto__</code> 为<code>函数A</code>，每一个函数都有一个属性为name，其值是函数的名字。</p><pre><code class="js">function abc() { /* 这是一个名为&#39;abc&#39;的函数 */ }abc.name // -&gt; &#39;abc&#39;</code></pre><p><code>b.msg</code> 为什么是<code>undefined</code>哪？ 因为<code>b.__proto__</code> 是 <code>函数A</code>，那怎么修改才能拿到<code>msg</code>哪？</p><pre><code class="js">B.prototype = new A();</code></pre><p>修改后的输出：</p><pre><code>TomVM731:12 use &#39;this.&#39; set in function</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/deepCopy</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/deepCopy/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/deepCopy/</url>
    
    <content type="html"><![CDATA[function getEmpty(o){if(Object.prototype.toString.call(o) === '[object Object]'){return {};}if(Object.prototype.toString.call(o) === '[object Array]'){return [];}return o;}function deepCopyBFS(origin){let queue = [];let map = new Map(); // 记录出现过的对象，用于处理环let target = getEmpty(origin);if(target !== origin){queue.push([origin, target]);map.set(origin, target);}while(queue.length){let [ori, tar] = queue.shift();for(let key in ori){// 处理环状if(map.get(ori[key])){tar[key] = map.get(ori[key]);continue;}tar[key] = getEmpty(ori[key]);if(tar[key] !== ori[key]){queue.push([ori[key], tar[key]]);map.set(ori[key], tar[key]);}}}return target;}function deepCopyDFS(origin){let stack = [];let map = new Map(); // 记录出现过的对象，用于处理环let target = getEmpty(origin);if(target !== origin){stack.push([origin, target]);map.set(origin, target);}while(stack.length){let [ori, tar] = stack.pop();for(let key in ori){// 处理环状if(map.get(ori[key])){tar[key] = map.get(ori[key]);continue;}tar[key] = getEmpty(ori[key]);if(tar[key] !== ori[key]){stack.push([ori[key], tar[key]]);map.set(ori[key], tar[key]);}}}return target;}// test[deepCopyBFS, deepCopyDFS].forEach(deepCopy=>{console.log(deepCopy({a:1}));console.log(deepCopy([1,2,{a:[3,4]}]))console.log(deepCopy(function(){return 1;}))console.log(deepCopy({x:function(){return "x";},val:3,arr: [1,{test:1}]}))let circle = {};circle.child = circle;console.log(deepCopy(circle));})]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/debounce-demo</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/debounce-demo/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/debounce-demo/</url>
    
    <content type="html"><![CDATA[// 频繁触发时，清楚对应的定时器，然后再开一个定时器，delay秒后执行function debounce(handler, delay){  delay = delay || 300;  var timer = null;  return function(){    var _self = this,        _args = arguments;    clearTimeout(timer);    timer = setTimeout(function(){      handler.apply(_self, _args);    }, delay);  }}// 不希望被频繁调用的函数function add(counterName) {  console.log(counterName + ":  " + this.index ++);}// 需要的上下文对象let counter = {  index: 0}// 防抖的自增函数，绑定上下文对象counterlet db_add = debounce(add, 10).bind(counter)// 每隔500ms频繁调用3次自增函数，但因为防抖的存在，这3次内只调用一次setInterval(function() {  db_add("someCounter1");  db_add("someCounter2");  db_add("someCounter3");}, 500)/** * 预期效果： *  * 每隔500ms，输出一个自增的数 * 即打印：    someCounter3:  0    someCounter3:  1    someCounter3:  2    someCounter3:  3 */]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/compose</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/compose/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/compose/</url>
    
    <content type="html"><![CDATA[<h2 id="函数式编程-compose"><a href="#函数式编程-compose" class="headerlink" title="函数式编程 compose"></a>函数式编程 compose</h2><p>实现以下功能：</p><pre><code class="js">compose([a, b, c])(&#39;参数&#39;)=&gt;a( b( c(&#39;参数&#39;) ) )</code></pre><pre><code class="js">function compose(funcs) {  var len = funcs.length;  var index = len - 1;  for(let i = 0; i &lt; len; i ++) {    if(typeof funcs[i] !== &#39;function&#39;) {      throw new TypeError(&#39;Expected function&#39;);    }  }  return function (...args) {    let result =  funcs[index](...args) // 第一次    while(--index &gt;= 0) {      result = funcs[index](result)    }    return result;  }}</code></pre><p>测试：</p><pre><code class="js">function a (str) {  return `a ${str}`}function b (str) {  return `b ${str}`}function c (str) {  return `c ${str}`}const abc = compose([a, b, c])abc(&#39;huyao&#39;)</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编程题与分析题/bind、apply实现</title>
    <link href="/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/bind%E3%80%81apply%E5%AE%9E%E7%8E%B0/"/>
    <url>/uncategorized/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90%E9%A2%98/bind%E3%80%81apply%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="自封装bind方法"><a href="#自封装bind方法" class="headerlink" title="自封装bind方法"></a>自封装bind方法</h3><ul><li>因为bind的使用方法是 某函数.bind(某对象，…剩余参数)<ul><li>所以需要在Function.prototype 上进行编程</li></ul></li><li>将传递的参数中的某对象和剩余参数使用apply的方式在一个回调函数中执行即可</li><li>要在第一层获取到被绑定函数的this，因为要拿到那个函数用apply</li></ul><pre><code class="js">/** * 简单版本  */Function.prototype.myBind = (that, ...args) =&gt; {  const funcThis = this;  return function(..._args) {    return funcThis.apply(that, args.concat(_args));  }}Function.prototype.mybind = function(ctx) {    var _this = this;    var args = Array.prototype.slice.call(arguments, 1);    return function() {        return _this.apply(ctx, args.concat(args, Array.prototype.slice.call(arguments)))    }}</code></pre><pre><code class="js">/** * 自封装bind方法 * @param  {对象} target [被绑定的this对象， 之后的arguments就是被绑定传入参数] * @return {[function]}  [返回一个新函数，这个函数就是被绑定了this的新函数] */Function.prototype.myBind = function (target){    target = target || window;    var self = this;    var args = [].slice.call(arguments, 1);    var temp = function(){};    var F = function() {        var _args = [].slice.call(arguments, 0);        return self.apply(this instanceof temp ? this: target, args.concat(_args));    }    temp.prototype = this.prototype;    //维护原型关系    F.prototype = new temp();    return F;}</code></pre><h3 id="自封装一个apply"><a href="#自封装一个apply" class="headerlink" title="自封装一个apply"></a>自封装一个apply</h3><ul><li>首先要先原型上即 Function.prototype上编程</li><li>需要拿到函数的引用， 在这里是 this</li><li>让 传入对象.fn = this</li><li>执行 传入对象.fn(传入参数)</li><li>返回执行结果</li></ul><pre><code class="js">Function.prototype.myApply = function(context) {  if (typeof this !== &#39;function&#39;) {    throw new TypeError(&#39;Error&#39;)  }  context = context || window  context.fn = this  let result  // 处理参数和 call 有区别  if (arguments[1]) {    result = context.fn(...arguments[1])  } else {    result = context.fn()  }  delete context.fn  return result}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Web安全/SQL注入</title>
    <link href="/uncategorized/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/uncategorized/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，后台执行SQL语句时直接把前端传入的字段拿来做SQL查询。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li>永远不要信任用户的输入。</li><li>永远不要使用动态拼装sql</li><li>不要把机密信息直接存放</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Web安全/README</title>
    <link href="/uncategorized/Web%E5%AE%89%E5%85%A8/README/"/>
    <url>/uncategorized/Web%E5%AE%89%E5%85%A8/README/</url>
    
    <content type="html"><![CDATA[<h1 id="web安全"><a href="#web安全" class="headerlink" title="web安全"></a>web安全</h1><p>安全性主要分为两大块。<br>私密性：不被非法获取和利用。<br>可靠性：不丢失、不损坏、不被篡改</p><h3 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h3><ul><li><a href="./XSS.md">XSS</a>    跨站脚本攻击</li><li><a href="./CSRF.md">CSRF</a>  跨站请求伪造</li><li><a href="./SQL注入.md">SQL注入</a></li><li>点击劫持</li><li>中间人攻击</li></ul><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ul><li>基本概念</li><li>攻击原理</li><li>防御措施</li></ul><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ul><li>用户身份被盗用</li><li>用户密码泄露</li><li>用户资料被盗取</li><li>网站数据库泄露</li></ul><h3 id="同源政策及其规避方法"><a href="#同源政策及其规避方法" class="headerlink" title="同源政策及其规避方法"></a>同源政策及其规避方法</h3><p>同源要求</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul><p>限制范围</p><ul><li>cookie、localstorage和 indexDB无法读取</li><li>DOM 无法获得</li><li>Ajax 请求不能发送</li></ul><p>参考链接： <a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策</a></p><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p><p>对于这种攻击方式，推荐防御的方法有两种。</p><ul><li>X-FRAME-OPTIONS</li><li>JS 防御</li></ul><h3 id="X-FRAME-OPTIONS"><a href="#X-FRAME-OPTIONS" class="headerlink" title="X-FRAME-OPTIONS"></a>X-FRAME-OPTIONS</h3><p><code>X-FRAME-OPTIONS</code> 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。</p><p>该响应头有三个值可选，分别是</p><ul><li><code>DENY</code>，表示页面不允许通过<code>iframe</code>的方式展示</li><li><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过<code>iframe</code>的方式展示</li><li><code>ALLOW-FROM</code>，表示页面可以在指定来源的<code>iframe</code>中展示</li></ul><h3 id="JS防御"><a href="#JS防御" class="headerlink" title="JS防御"></a>JS防御</h3><p>对于某些低版本浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。</p><pre><code class="html">&lt;head&gt;  &lt;style id=&quot;click-jack&quot;&gt;    html {      display: none !important;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    if (self == top) {      var style = document.getElementById(&#39;click-jack&#39;)      document.body.removeChild(style)    } else {      top.location = self.location    }  &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。</p><p>通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。</p><p>当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Web安全/CSRF</title>
    <link href="/uncategorized/Web%E5%AE%89%E5%85%A8/CSRF/"/>
    <url>/uncategorized/Web%E5%AE%89%E5%85%A8/CSRF/</url>
    
    <content type="html"><![CDATA[<h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h1><p>（Cross Site Request Forgy）<br>打开同一浏览器时其他的网站对本网站造成的影响。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。<br><img src="../img/csrf.png" srcset="/img/loading.gif" alt="原理"></p><p>举个例子，用户同时打开了A网站和钓鱼网站。 假设A网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口。</p><pre><code class="html">&lt;img src=&quot;http://www.domain.com/xxx?comment=&#39;attack&#39;&quot;/&gt;</code></pre><h2 id="CSRF攻击原理"><a href="#CSRF攻击原理" class="headerlink" title="CSRF攻击原理"></a>CSRF攻击原理</h2><ol><li>用户登录A网站</li><li>A网站确认身份（给客户端cookie）</li><li>B网站页面向A网站发起请求（带上A网站身份）</li></ol><h2 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h2><ol><li><p>Get 请求不对数据进行修改</p></li><li><p>不让第三方网站访问到用户 Cookie</p></li><li><p>阻止第三方网站请求接口</p></li><li><p>请求时附带验证信息，比如验证码或者 Token</p><ul><li>SameSite</li><li>可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</li><li>Token验证</li><li>cookie是发送时自动带上的，而不会主动带上Token，所以在每次发送时主动发送Token</li><li>Referer验证</li><li>对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。</li><li>隐藏令牌</li><li>主动在HTTP头部中添加令牌信息</li></ul></li></ol><p>禁止第三方网站带cookies</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#SameSite_Cookies" target="_blank" rel="noopener">same-site</a>属性。 设置只有同一站点的请求才能携带cookie</p><h2 id="CSRF蠕虫"><a href="#CSRF蠕虫" class="headerlink" title="CSRF蠕虫"></a>CSRF蠕虫</h2><p>如果某个用户打开了被攻击网页，并且用户同时访问了攻击者的网页。<br>那么攻击者的网页就会使用用户的身份发送一些请求，并且常用用户的身份发布一些评论或文章，里面包含攻击者的网页链接。如果其他用户看到了这个用户的这条评论，都甚至可以不点击，其他用户也会被盗用身份发送一些恶意请求。这样病毒的传播就会越来越快，影响越来越大。</p><h2 id="CSRF攻击危害"><a href="#CSRF攻击危害" class="headerlink" title="CSRF攻击危害"></a>CSRF攻击危害</h2><ul><li>利用用户登录态</li><li>用户不知情</li><li>完成业务请求</li><li></li><li>盗取用户资金</li><li>冒充用户发帖背锅</li><li>损坏网站名誉</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack/模块化</title>
    <link href="/uncategorized/webpack/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/uncategorized/webpack/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>随着前端项目复杂性不断提高，JS的代码量变的越来越大，必须做拆分。但如果仅是拆成几个 js 文件，然后在用<code>script</code>标签去引入这些文件又会使导致以下几个问题：</p><ul><li>影响加载速度<ul><li>JS文件变多，加载JS文件数量过多导致页面加载速度编码</li></ul></li><li>代码的引入次序<ul><li>使用script标签引入JS时还必须控制JS的顺序。在单个JS文件编写的时候，如果要使用其他的JS文件中的一些变量和函数，不能直观的知道这个变量或函数是在哪个文件定义的。</li></ul></li><li>命名空间污染<ul><li>JS虽然拆开了，但实际上在浏览器运行时就像把所有文件都何在一起了一样</li></ul></li></ul><p>模块化可以解决上面的问题，但是模块化后的代码是使用<code>import</code>或<code>export</code>这样的写法来实现的，浏览器不能识别，所以需要一个打包工具。</p><ul><li><a href="https://webpack.js.org/concepts/modules/#what-is-a-webpack-module" target="_blank" rel="noopener">What is webpack moudule</a></li><li><a href="https://webpack.js.org/concepts/modules/#supported-module-types" target="_blank" rel="noopener">Supported Module Types</a></li><li><a href="https://webpack.js.org/api/module-methods/" target="_blank" rel="noopener">Module Methods</a></li><li><a href="https://webpack.js.org/api/module-variables/" target="_blank" rel="noopener">Module Variables</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack/安装</title>
    <link href="/uncategorized/webpack/%E5%AE%89%E8%A3%85/"/>
    <url>/uncategorized/webpack/%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-webpack"><a href="#安装-webpack" class="headerlink" title="安装 webpack"></a>安装 webpack</h2><p>在项目中安装</p><pre><code>npm install webpack webpack-cli --save-dev</code></pre><p>是否全局安装？</p><p>如果电脑上有两个项目，一个 webpack3 打包，一个 webpack4 打包。安装后可能导致你webpack3的项目无法打包，所以一般都是项目内安装。</p><h3 id="webpack-cli"><a href="#webpack-cli" class="headerlink" title="webpack-cli"></a>webpack-cli</h3><p>使得可以在命令行里使用webpack</p><h3 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h3><p>项目内安装webpack后，直接在终端输入<code>webpack -v</code>是不可以的，但是使用<code>npx webpack -v</code>就可以。</p><pre><code>$ webpack -v&gt; bash: webpack: command not found$ npx webpack -v&gt; 4.35.0</code></pre><p>这是因为<code>npx</code>这个命令可以帮助我们在当前项目的<code>node_modules</code>中查找对应的包。</p><h3 id="安装制定版本webpack"><a href="#安装制定版本webpack" class="headerlink" title="安装制定版本webpack"></a>安装制定版本webpack</h3><p><code>npm install webpack@4.16.5 -D</code> 在包名后加‘@’再加版本号<br>查看某包信息，可以运行 <code>npm info webpack</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack/webpack配置文件</title>
    <link href="/uncategorized/webpack/webpack%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/uncategorized/webpack/webpack%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="webpack配置文件"><a href="#webpack配置文件" class="headerlink" title="webpack配置文件"></a>webpack配置文件</h2><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>webpack.config.js是webpack的默认打包配置文件。也可以<code>npx webpack --config 配置文件名</code>手动设置</p><pre><code class="js">/** * Wepack配置接口 */const path = require(&#39;path&#39;); module.exports = {    // 打包模式    mode: &quot;production&quot;,    // 入口    entry: &quot;./index.js&quot;,    // 出口    output: {        filename: &#39;bundle.js&#39;,        // path 后必须是一个绝对位置        path: path.resolve(__dirname, &#39;bundle&#39;)    }}</code></pre><p>其中<code>entry: &quot;./index.js&quot;</code>是一个简写，</p><pre><code>entry: {    main: &quot;./index.js&quot;}</code></pre><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p>打包模式，有生产环境与发布环境两种，默认是发布环境。</p><ul><li>production<ul><li>代码被压缩为一行</li></ul></li><li>development<ul><li>代码不被压缩</li></ul></li></ul><p>当没有显示制定时会输出下面内容：</p><blockquote><p>WARNING in configuration</p><p>The ‘mode’ option has not been set, webpack will fallback to ‘production’ for this value. Set ‘mode’ option to ‘development’ or ‘production’ to enable defaults for each environment.<br>You can also set it to ‘none’ to disable any default behavior. Learn more: <a href="https://webpack.js.org/configuration/mode/" target="_blank" rel="noopener">https://webpack.js.org/configuration/mode/</a></p></blockquote><h3 id="多入口"><a href="#多入口" class="headerlink" title="多入口"></a>多入口</h3><p>最后都会讲其写入到html的script标签中</p><pre><code class="js">entry:{    main: &#39;a/index.js&#39;,    sub: &#39;b/main.js&#39;}// 多个入口是不可打包为同一个JS的，output: {    filename: &#39;[name].js&#39;}</code></pre><h3 id="为打包出的JS加前缀"><a href="#为打包出的JS加前缀" class="headerlink" title="为打包出的JS加前缀"></a>为打包出的JS加前缀</h3><p>比如静态资源都放在CDN上，那么希望打包出srcipt的src是一个http地址<br>可这样做：</p><pre><code>output: {    publicPath: &#39;http://cdn.cn&#39;    filename: &#39;[name].js&#39;}</code></pre><h3 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h3><p>devtool就是去配置sourcemap，方便调试，能准确定位到代码错误</p><ul><li>cheap<ul><li>定位到行，不定位到列（提示性能）</li></ul></li><li>module<ul><li>把依赖模块中的代码一并做映射</li></ul></li><li>eval<ul><li>使用eval形式做sourcemap映射</li></ul></li><li>inline<ul><li>行内的映射关系</li></ul></li></ul><p>最好的配置：</p><pre><code class="js">// 开发时devtool: &#39;cheap-module-eval-source-map&#39;,// 线上环境：devtool: &#39;cheap-module-source-map&#39;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack/README</title>
    <link href="/uncategorized/webpack/README/"/>
    <url>/uncategorized/webpack/README/</url>
    
    <content type="html"><![CDATA[<h3 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h3><p><code>webpack</code>是一个前端模块化打包工具，最开始它只能打包JS文件，但是随着webpack的发展，他还能打包如CSS、图片等文件。主要由入口，出口，loader，plugins四个部分。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a><a href="模块化.md">模块化</a></h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="安装.md">安装</a></h3><h3 id="webpack基本配置文件"><a href="#webpack基本配置文件" class="headerlink" title="webpack基本配置文件"></a><a href="webpack配置文件.md">webpack基本配置文件</a></h3><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a><a href="loader.md">Loader</a></h3><h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a><a href="./package-lock.json.md">package-lock.json</a></h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack/plugins</title>
    <link href="/uncategorized/webpack/plugins/"/>
    <url>/uncategorized/webpack/plugins/</url>
    
    <content type="html"><![CDATA[<h1 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h1><p>使用<code>plugins</code>让打包变的便捷，可以在webpack打包的某时刻帮做一些事情，他很像一个生命周期函数</p><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>html-webpack-plugin 会在打包结束后，自动生成一个html文件,并把打包生成的js自动引入到HTML中。<br>可以给这个html制定一个模板</p><pre><code class="js">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)// 插件plugins: [    new HtmlWebpackPlugin({        template: &#39;src/index.html&#39;    })],</code></pre><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a><a href="https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="noopener">clean-webpack-plugin</a></h3><p>帮助打包时先清空dist目录</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack/package-lock.json</title>
    <link href="/uncategorized/webpack/package-lock.json/"/>
    <url>/uncategorized/webpack/package-lock.json/</url>
    
    <content type="html"><![CDATA[<h1 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h1><p>概括很简单，就是锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致。</p><p>根据官方文档，这个package-lock.json 是在 <code>npm install</code>时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。</p><p>它有什么用呢？因为npm是一个用于管理package之间依赖关系的管理器，它允许开发者在pacakge.json中间标出自己项目对npm各库包的依赖。你可以选择以如下方式来标明自己所需要库包的版本</p><p>这里举个例子：</p><pre><code class="json">&quot;dependencies&quot;: {    &quot;@types/node&quot;: &quot;^8.0.33&quot;,},</code></pre><p>这里面的 向上标号^是定义了向后（新）兼容依赖，指如果 types/node的版本是超过8.0.33，并在大版本号（8）上相同，就允许下载最新版本的 types/node库包，例如实际上可能运行npm install时候下载的具体版本是8.0.35。</p><p>大多数情况这种向新兼容依赖下载最新库包的时候都没有问题，可是因为npm是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。这时候用户就很头疼了：在完全相同的一个nodejs的代码库，在不同时间或者不同npm下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容。</p><p>因此npm最新的版本就开始提供自动生成package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。</p><p><a href="https://docs.npmjs.com/files/package-lock.json" target="_blank" rel="noopener">package-lock.json | 官方文档</a></p><h3 id="semver-语义化版本号变更"><a href="#semver-语义化版本号变更" class="headerlink" title="semver 语义化版本号变更"></a>semver 语义化版本号变更</h3><p><code>^</code> 是npm默认的版本符号, 当你使用npm install –save时, npm会自动在package中添加^加上版本号. 例如: npm install –save angular会在package.json中添加”angular”: “^1.3.15”.这个符号会告诉npm可以安装1.3.15或者一个大于它的版本, 但是要是主版本1下的版本.</p><p><code>~</code> 同样被用来做npm得版本控制, 例如<del>1.3.15, 代表了npm可以安装1.3.15或者更高的版本, 与^的区别在于, ~的版本只能开始于次版本号1.3. 它们的作用域不同. 你可以通过npm config set save-prefix=’</del>‘将~设置为默认符号.</p><p><code>&gt;</code>符号主要是用来指定可以安装beta版本.</p><p><a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">semver版本号 | 官方文档</a></p><p><code>devDependencies</code> 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack/loader</title>
    <link href="/uncategorized/webpack/loader/"/>
    <url>/uncategorized/webpack/loader/</url>
    
    <content type="html"><![CDATA[<h1 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h1><p>当打包到非JS文件的时候，webpack会在<code>module</code>中配置里查找，然后根据<code>rules</code>中的<code>test</code>选择一个loader来处理。</p><h2 id="打包静态资源"><a href="#打包静态资源" class="headerlink" title="打包静态资源"></a>打包静态资源</h2><h3 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h3><h4 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h4><p>当发现是图片，使用 file-loader来打包<br>file-loader做的事：</p><ul><li>将图片移到dist目录下</li><li>给图片改个名字</li><li>将名字返回给引入模块的变量中</li></ul><pre><code class="js">module: {    rules: [{        test: /\.jpg$/,        use: {            loader: &#39;file-loader&#39;        }    }]},</code></pre><h4 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h4><p>让图片打包出来的名字与拓展名与原来一样<br><code>&#39;[name].[ext]&#39;</code> 这种语法叫 <code>placehoder</code> 即占位符</p><pre><code class="js">rules: [{    test: /\.jpg$/,    use: {        loader: &#39;file-loader&#39;,        // option 为配置参数        options: {            // 图片打包出来的名字和后缀原来的一样            name: &#39;[name]_[hash].[ext]&#39;        }    }}]</code></pre><h4 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h4><p>将文件打包为Base64编码，当图片特别小（1~2k）的时候适用。</p><p>但是大图片不使用，可以给它加上一个<code>limit</code>来限制</p><pre><code class="js">rules: [{    test: /\.(jpg|png|gif)$/,    use: {        loader: &#39;url-loader&#39;,        // option 为配置参数        options: {            limit: 2048        }    }}]</code></pre><h3 id="打包样式"><a href="#打包样式" class="headerlink" title="打包样式"></a>打包样式</h3><pre><code class="js">{    test: /\.css$/,    // 一种文件多个Loader就使用数组    use: [        &#39;style-loader&#39;, &#39;css-loader&#39;    ]}</code></pre><ul><li><code>css-loader</code> 能帮我们分析出几个CSS文件之间的关系</li><li><code>style-loader</code> 在得到 css-loader 生成的文件后，style-loader会将这段样式挂在到 header 标签中</li></ul><h4 id="使用sass"><a href="#使用sass" class="headerlink" title="使用sass"></a><a href="https://webpack.js.org/loaders/sass-loader/" target="_blank" rel="noopener">使用sass</a></h4><p>loader是<strong>有顺序</strong>的，顺序是：从数组的最后一个依次向前处理。</p><pre><code class="js">use: [    &quot;style-loader&quot;, // creates style nodes from JS strings    &quot;css-loader&quot;, // translates CSS into CommonJS    &quot;sass-loader&quot; // compiles Sass to CSS, using Node Sass by default]</code></pre><h4 id="厂商前缀-postcss-loader"><a href="#厂商前缀-postcss-loader" class="headerlink" title="厂商前缀 postcss-loader"></a><a href="https://webpack.js.org/loaders/postcss-loader/" target="_blank" rel="noopener">厂商前缀 postcss-loader</a></h4><pre><code class="js">use: [    &quot;style-loader&quot;, // creates style nodes from JS strings    &quot;css-loader&quot;, // translates CSS into CommonJS    &quot;postcss-loader&quot; // compiles Sass to CSS, using Node Sass by default]</code></pre><p>它可以进行配置，要创建一个<code>postcss.config.js</code>文件 </p><pre><code class="js">module.exports = {    plugins: [        require(&#39;autoprefixer&#39;)    ]}</code></pre><p><code>autoprefixer</code>这个插件可以帮我们添加厂商前缀</p><h4 id="importLoaders"><a href="#importLoaders" class="headerlink" title="importLoaders"></a>importLoaders</h4><p>在sass文件中又 使用<code>@import</code>的方式去引入了其他文件，可能就会导致在打包时直接走 css-loader，而不会去走下面的两个loader</p><p><code>importLoaders</code>就是让<code>@import</code>方式引入方式的文件也走下面的两个loader</p><pre><code class="js">use: [    &quot;style-loader&quot;,    {        loader: &quot;css-loader&quot;,        options:{             importLoaders: 2        }     },     &quot;sass-loader&quot;,    &quot;postcss-loader&quot;]</code></pre><h4 id="CSS-modules"><a href="#CSS-modules" class="headerlink" title="CSS modules"></a>CSS modules</h4><p>css-loader直接将其打包注入到header中，可能造成CSS的干扰。即一个文件中引入了一个CSS，其他地方都会受到影响</p><p>解决方法是配置<code>modules</code>：</p><pre><code class="js">{    loader: &quot;css-loader&quot;,    options:{         importLoaders: 2,        modules: true    } },</code></pre><p>引入样式时使用 <code>style.className</code> 方式：</p><pre><code class="js">import style form &#39;./style.sass&#39;// 添加样式const img = new Image();img.src = girl;img.classList.add(style.girl)</code></pre><h4 id="打包字体"><a href="#打包字体" class="headerlink" title="打包字体"></a>打包字体</h4><p>打包时如果有字体文件的话打包又会报错，因为不认识字体文件。而对字体文件的打包只需要<code>file-loader</code>就可以了</p><pre><code class="js">{    test: /\.(eot|ttf|svg)$/,    use: {        loader: &#39;file-loader&#39;    }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue/README</title>
    <link href="/uncategorized/Vue/README/"/>
    <url>/uncategorized/Vue/README/</url>
    
    <content type="html"><![CDATA[<h3 id="v-bind和v-model的区别"><a href="#v-bind和v-model的区别" class="headerlink" title="v-bind和v-model的区别"></a>v-bind和v-model的区别</h3><p>1.v-bind用来绑定数据和属性以及表达式，缩写为’：’<br>2.v-model使用在表单中，实现双向数据绑定的，在表单元素外使用不起作用</p><h3 id="什么是-mvvm？"><a href="#什么是-mvvm？" class="headerlink" title="什么是 mvvm？"></a>什么是 mvvm？</h3><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><h3 id="mvvm-和-mvc-区别？"><a href="#mvvm-和-mvc-区别？" class="headerlink" title="mvvm 和 mvc 区别？"></a>mvvm 和 mvc 区别？</h3><p>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。</p><h3 id="vue-的优点是什么？"><a href="#vue-的优点是什么？" class="headerlink" title="vue 的优点是什么？"></a>vue 的优点是什么？</h3><ul><li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li><li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。</li><li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li></ul><h3 id="请详细说下你对-vue-生命周期的理解？"><a href="#请详细说下你对-vue-生命周期的理解？" class="headerlink" title="请详细说下你对 vue 生命周期的理解？"></a>请详细说下你对 vue 生命周期的理解？</h3><p>答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p><ul><li>创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。</li><li>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</li><li>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</li><li>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</li></ul><h3 id="组件之间的传值？"><a href="#组件之间的传值？" class="headerlink" title="组件之间的传值？"></a>组件之间的传值？</h3><ol><li>父组件与子组件传值</li></ol><pre><code class="html">//父组件通过标签上面定义传值&lt;template&gt;    &lt;Main :obj=&quot;data&quot;&gt;&lt;/Main&gt;&lt;/template&gt;&lt;script&gt;    //引入子组件    import Main form &quot;./main&quot;    exprot default{        name:&quot;parent&quot;,        data(){            return {                data:&quot;我要向子组件传递数据&quot;            }        },        //初始化组件        components:{            Main        }    }&lt;/script&gt;//子组件通过props方法接受数据&lt;template&gt;    &lt;div&gt;{{data}}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    exprot default{        name:&quot;son&quot;,        //接受父组件传值        props:[&quot;data&quot;]    }&lt;/script&gt;</code></pre><ol start="2"><li>子组件向父组件传递数据</li></ol><pre><code class="html">//子组件通过$emit方法传递参数&lt;template&gt;   &lt;div v-on:click=&quot;events&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    //引入子组件    import Main form &quot;./main&quot;    exprot default{        methods:{            events:function(){            }        }    }&lt;/script&gt;//&lt;template&gt;    &lt;div&gt;{{data}}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    exprot default{        name:&quot;son&quot;,        //接受父组件传值        props:[&quot;data&quot;]    }&lt;/script&gt;</code></pre><h3 id="active-class-是哪个组件的属性？"><a href="#active-class-是哪个组件的属性？" class="headerlink" title="active-class 是哪个组件的属性？"></a>active-class 是哪个组件的属性？</h3><p>vue-router 模块的 router-link 组件。</p><h3 id="嵌套路由怎么定义？"><a href="#嵌套路由怎么定义？" class="headerlink" title="嵌套路由怎么定义？"></a>嵌套路由怎么定义？</h3><p>在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。<br>index.html，只有一个路由出口</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    &lt;!-- router-view 路由出口, 路由匹配到的组件将渲染在这里 --&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;</code></pre><p>main.js，路由的重定向，就会在页面一加载的时候，就会将 home 组件显示出来，因为重定向指向了 home 组件，redirect 的指向与 path 的必须一致。children 里面是子路由，当然子路由里面还可以继续嵌套子路由。</p><pre><code class="js">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter)//引入两个组件import home from &quot;./home.vue&quot;import game from &quot;./game.vue&quot;//定义路由const routes = [    { path: &quot;/&quot;, redirect: &quot;/home&quot; },//重定向,指向了home组件    {        path: &quot;/home&quot;, component: home,        children: [            { path: &quot;/home/game&quot;, component: game }        ]    }]//创建路由实例const router = new VueRouter({routes})new Vue({    el: &#39;#app&#39;,    data: {    },    methods: {    },    router})</code></pre><p>home.vue，点击显示就会将子路由显示在出来，子路由的出口必须在父路由里面，否则子路由无法显示。</p><h3 id="路由之间跳转？"><a href="#路由之间跳转？" class="headerlink" title="路由之间跳转？"></a>路由之间跳转？</h3><ul><li>声明式（标签跳转） <code>&lt;router-link :to=&quot;index&quot;&gt;</code></li><li>编程式（ js 跳转） <code>router.push(&#39;index&#39;)</code></li></ul><h3 id="懒加载（按需加载路由）（常考）"><a href="#懒加载（按需加载路由）（常考）" class="headerlink" title="懒加载（按需加载路由）（常考）"></a>懒加载（按需加载路由）（常考）</h3><p>webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。</p><ul><li>不进行页面按需加载引入方式：</li></ul><pre><code class="js">import  home   from &#39;../../common/home.vue&#39;</code></pre><ul><li>进行页面按需加载的引入方式：</li></ul><pre><code class="js">const  home = r =&gt; require.ensure( [], () =&gt; r (require(&#39;../../common/home.vue&#39;)))</code></pre><h3 id="vuex-是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex-是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex 是什么？怎么使用？哪种功能场景使用它？"></a>vuex 是什么？怎么使用？哪种功能场景使用它？</h3><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p><pre><code class="js">// 新建 store.jsimport vue from &#39;vue&#39;import vuex form &#39;vuex&#39;vue.use(vuex)export default new vuex.store({    //...code})//main.jsimport store from &#39;./store&#39;...</code></pre><h3 id="vue-router-有哪几种导航钩子"><a href="#vue-router-有哪几种导航钩子" class="headerlink" title="vue-router 有哪几种导航钩子?"></a>vue-router 有哪几种导航钩子?</h3><p>三种</p><ul><li>全局导航钩子<ul><li>router.beforeEach(to, from, next),</li><li>router.beforeResolve(to, from, next),</li><li>router.afterEach(to, from ,next)</li></ul></li><li>组件内钩子<ul><li>beforeRouteEnter,</li><li>beforeRouteUpdate,</li><li>beforeRouteLeave</li></ul></li><li>单独路由独享组件<ul><li>beforeEnter</li></ul></li></ul><h3 id="自定义指令-v-check-v-focus-的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数"><a href="#自定义指令-v-check-v-focus-的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数" class="headerlink" title="自定义指令(v-check, v-focus) 的方法有哪些? 它有哪些钩子函数? 还有哪些钩子函数参数"></a>自定义指令(v-check, v-focus) 的方法有哪些? 它有哪些钩子函数? 还有哪些钩子函数参数</h3><ul><li>全局定义指令：在 vue 对象的 directive 方法里面有两个参数, 一个是指令名称, 另一个是函数。</li><li>组件内定义指令：directives</li><li>钩子函数: bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新)</li><li>钩子函数参数： el、binding</li></ul><h3 id="说出至少-4-种-vue-当中的指令和它的用法"><a href="#说出至少-4-种-vue-当中的指令和它的用法" class="headerlink" title="说出至少 4 种 vue 当中的指令和它的用法"></a>说出至少 4 种 vue 当中的指令和它的用法</h3><p>v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定)</p><h3 id="vue-的双向绑定的原理是什么-常考"><a href="#vue-的双向绑定的原理是什么-常考" class="headerlink" title="vue 的双向绑定的原理是什么(常考)"></a>vue 的双向绑定的原理是什么(常考)</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>具体步骤：<br>第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p><p>第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p><p>第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</p><ul><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个 update()方法</li><li>待属性变动 dep.notice()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</li></ul><p>第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</p><h2 id="vuex-相关"><a href="#vuex-相关" class="headerlink" title="vuex 相关"></a>vuex 相关</h2><h3 id="vuex-有哪几种属性"><a href="#vuex-有哪几种属性" class="headerlink" title="vuex 有哪几种属性"></a>vuex 有哪几种属性</h3><p>有 5 种，分别是 state、getter、mutation、action、module</p><h3 id="vuex-的-store-特性是什么"><a href="#vuex-的-store-特性是什么" class="headerlink" title="vuex 的 store 特性是什么"></a>vuex 的 store 特性是什么</h3><ul><li>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data</li><li>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</li><li>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</li></ul><h3 id="vuex-的-getter-特性是什么"><a href="#vuex-的-getter-特性是什么" class="headerlink" title="vuex 的 getter 特性是什么"></a>vuex 的 getter 特性是什么</h3><ul><li>getter 可以对 state 进行计算操作，它就是 store 的计算属性</li><li>虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用</li><li>如果一个状态只在一个组件内使用，是可以不用 getters</li></ul><h3 id="vuex-的-mutation-特性是什么"><a href="#vuex-的-mutation-特性是什么" class="headerlink" title="vuex 的 mutation 特性是什么"></a>vuex 的 mutation 特性是什么</h3><ul><li>action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态</li><li>action 可以包含任意异步操作</li></ul><h3 id="vue-中-ajax-请求代码应该写在组件的-methods-中还是-vuex-的-action-中"><a href="#vue-中-ajax-请求代码应该写在组件的-methods-中还是-vuex-的-action-中" class="headerlink" title="vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中"></a>vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中</h3><p>如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里</p><p>如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回</p><h3 id="不用-vuex-会带来什么问题"><a href="#不用-vuex-会带来什么问题" class="headerlink" title="不用 vuex 会带来什么问题"></a>不用 vuex 会带来什么问题</h3><ul><li>可维护性会下降，你要修改数据，你得维护 3 个地方</li><li>可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的</li><li>增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背</li></ul><h3 id="vuex-原理"><a href="#vuex-原理" class="headerlink" title="vuex 原理"></a>vuex 原理</h3><p>vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux,MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统，</p><p>vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件；</p><h3 id="使用-Vuex-只需执行-Vue-use-Vuex-，并在-Vue-的配置中传入一个-store-对象的示例，store-是如何实现注入的？美团"><a href="#使用-Vuex-只需执行-Vue-use-Vuex-，并在-Vue-的配置中传入一个-store-对象的示例，store-是如何实现注入的？美团" class="headerlink" title="使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？美团"></a>使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？<a href="https://tech.meituan.com/vuex_code_analysis.html" target="_blank" rel="noopener">美团</a></h3><p>Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的$store 中。因此在 Vue Component 任意地方都能够通过 this.$store 访问到该 store。</p><h3 id="state-内部支持模块配置和模块嵌套，如何实现的？美团"><a href="#state-内部支持模块配置和模块嵌套，如何实现的？美团" class="headerlink" title="state 内部支持模块配置和模块嵌套，如何实现的？美团"></a>state 内部支持模块配置和模块嵌套，如何实现的？<a href="https://tech.meituan.com/vuex_code_analysis.html" target="_blank" rel="noopener">美团</a></h3><p>在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如 dispatch(‘submitOrder’, payload)这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。</p><h3 id="在执行-dispatch-触发-action-commit-同理-的时候，只需传入-type-payload-，action-执行函数中第一个参数-store-从哪里获取的？美团"><a href="#在执行-dispatch-触发-action-commit-同理-的时候，只需传入-type-payload-，action-执行函数中第一个参数-store-从哪里获取的？美团" class="headerlink" title="在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？美团"></a>在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？<a href="https://tech.meituan.com/vuex_code_analysis.html" target="_blank" rel="noopener">美团</a></h3><p>store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如 dispatch(‘submitOrder’, payload)的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到 { dispatch, commit, state, rootState } 等数据。</p><h3 id="Vuex-如何区分-state-是外部直接修改，还是通过-mutation-方法修改的？美团"><a href="#Vuex-如何区分-state-是外部直接修改，还是通过-mutation-方法修改的？美团" class="headerlink" title="Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？美团"></a>Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？<a href="https://tech.meituan.com/vuex_code_analysis.html" target="_blank" rel="noopener">美团</a></h3><p>Vuex 中修改 state 的唯一渠道就是执行 commit(‘xx’, payload) 方法，其底层通过执行 this._withCommit(fn) 设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。</p><h3 id="调试时的”时空穿梭”功能是如何实现的？美团"><a href="#调试时的”时空穿梭”功能是如何实现的？美团" class="headerlink" title="调试时的”时空穿梭”功能是如何实现的？美团"></a>调试时的”时空穿梭”功能是如何实现的？<a href="https://tech.meituan.com/vuex_code_analysis.html" target="_blank" rel="noopener">美团</a></h3><p>devtoolPlugin 中提供了此功能。因为 dev 模式下所有的 state change 都会被记录下来，’时空穿梭’ 功能其实就是将当前的 state 替换为记录中某个时刻的 state 状态，利用 store.replaceState(targetState) 方法将执行 this._vm.state = state 实现。</p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="axios-是什么？怎么使用？描述使用它实现登录功能的流程"><a href="#axios-是什么？怎么使用？描述使用它实现登录功能的流程" class="headerlink" title="axios 是什么？怎么使用？描述使用它实现登录功能的流程"></a>axios 是什么？怎么使用？描述使用它实现登录功能的流程</h3><p>axios 是请求后台资源的模块。 npm i axios -S</p><p>如果发送的是跨域请求，需在配置文件中 config/index.js 进行配置</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript/README</title>
    <link href="/uncategorized/TypeScript/README/"/>
    <url>/uncategorized/TypeScript/README/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持。</p><p>TypeScript 只会进行静态检查，编译为 js 之后，并没有什么检查的代码被插入进来。如果编译时发现有错误，就会报错，但还是会生成编译结果。</p><h3 id="TS优势"><a href="#TS优势" class="headerlink" title="TS优势"></a>TS优势</h3><ul><li>TypeScript 增加了代码的可读性和可维护性<ul><li>类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了</li><li>可以在编译阶段就发现大部分错误，这总比在运行时候出错好</li><li>增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</li></ul></li><li>TypeScript 非常包容<ul><li>TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可</li><li>即使不显式的定义类型，也能够自动做出类型推论</li><li>可以定义从简单到复杂的几乎一切类型</li><li>即使 TypeScript 编译报错，也可以生成 JavaScript 文件</li><li>兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取</li></ul></li><li>TypeScript 拥有活跃的社区<ul><li>大部分第三方库都有提供给 TypeScript 的类型定义文件</li></ul></li><li>TypeScript 的缺点<ul><li>有一定的学习成本</li><li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本</li><li>集成到构建流程需要一些工作量</li><li>可能和一些库结合的不是很完美</li></ul></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><code>boolean</code></li><li><code>number</code></li><li><code>string</code></li><li><code>undefind</code></li><li><code>list</code></li><li><code>Tuple</code><ul><li>合并了不同类型的对象的数组</li></ul></li><li><code>enum</code><ul><li>用于取值被限定在一定范围内的场景</li><li>未手动赋值的枚举项会接着上一个枚举项递增</li><li>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的</li><li>如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</li><li>常数枚举<ul><li>是使用 const enum 定义的枚举类型，不能包含计算成员</li></ul></li><li>外部枚举<ul><li>使用 declare enum 定义的枚举类型</li><li>外部枚举与声明语句一样，常出现在声明文件中</li></ul></li></ul></li><li><code>any</code><ul><li>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</li><li>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</li></ul></li><li><code>void</code><ul><li>可以用 void 表示没有任何返回值的函数</li><li>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null</li></ul></li></ul><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p><p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</p><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p><pre><code>let myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><pre><code class="ts">let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><h4 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="headerlink" title="访问联合类型的属性或方法"></a>访问联合类型的属性或方法</h4><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法。</p><pre><code class="ts">function getLength(something: string | number): number {    return something.length;}// index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.//   Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre><p>length 不是 string 和 number 的共有属性，只有string有，所以会报错。</p><p>联合类型的变量在被<strong>赋值</strong>的时候，会根据类型推论的规则推断出一个类型。推断后访问该类型没有的属性就会报错。</p><h3 id="对象的类型"><a href="#对象的类型" class="headerlink" title="对象的类型"></a>对象的类型</h3><p>除了可用于<a href="https://ts.xcatliu.com/advanced/class-and-interfaces.html#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">对类的一部分行为进行抽象</a>以外，也常用于对<code>对象的形状（Shape）</code>进行描述。</p><ul><li>普通接口<ul><li>定义的变量比接口<strong>少了</strong>或是<strong>多了</strong>一些属性是不允许的</li></ul></li><li>可选属性<ul><li>在属性后面加<code>?</code>表示该属性为可选属性</li></ul></li><li>任意属性<ul><li><code>[propName: string]: 类型;</code></li><li>注意：一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</li></ul></li><li>只读属性<ul><li>在属性名前加<code>readonly</code>，则该属性只能在创建的时候被赋值</li></ul></li></ul><h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><ul><li><p>类型 + 方括号 表示法</p><ul><li><code>let fibonacci: number[] = [1, 1, 2, 3, 5];</code></li><li><code>let fibonacci: (number | string)[] = [1, &#39;1&#39;, 2, 3, 5];</code></li></ul></li><li><p>数组泛型<code>Array&lt;elemType&gt;</code> 来表示数组</p><ul><li>let fibonacci: Array<number> = [1, 1, 2, 3, 5];</li></ul></li><li><p>在数组中的<code>any</code></p><ul><li><code>let list: any[] = [&#39;yaoyao&#39;, 25, { a: &#39;str&#39; }];</code></li></ul></li><li><p>用接口表示数组</p><ul><li>NumberArray 表示：只要 index 的类型是 number，那么值的类型必须是 number<pre><code class="ts">interface NumberArray {</code></pre></li></ul><p> [index: number]: number;<br>}<br>let fibonacci: NumberArray = [1, 1, 2, 3, 5];</p><pre><code></code></pre></li><li><p>类数组</p><ul><li>类数组（Array-like Object）不是数组类型，比如 <code>arguments</code></li><li>事实上常见的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection<pre><code class="ts">function sum() {let args: IArguments = arguments;}</code></pre></li></ul></li></ul><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><ul><li><p>声明式</p><ul><li>一个函数有输入和输出，需要把输入和输出都考虑到。并且输入多余的（或者少于要求的）参数，是不被允许的<pre><code class="ts">function sum(x:number, y:number): number {return x + y;}</code></pre></li></ul></li><li><p>函数表达式</p><ul><li>TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 不要和ES6的箭头函数搞混了<pre><code class="ts">let mySum : (x: number, y: number) =&gt; number= function (x: number, y: number): number {return x + y;};</code></pre></li></ul></li><li><p>用接口定义函数的形状</p><pre><code class="ts">interface SearchFunc {(source: string, subString: string): boolean;}let mySerch : SearchFunc= function(source: string, subString: string): boolean { return source.search(subString) !== -1;};</code></pre></li><li><p>可选参数</p><ul><li>用<code>?</code>表示可选的参数<pre><code class="ts">function buildName(firstName: string, lastName?: string) {if (lastName) {   return firstName + &#39; &#39; + lastName;} else {   return firstName;}}</code></pre></li></ul></li><li><p>参数默认值</p><ul><li>TypeScript 会将添加了默认值的参数识别为可选参数<pre><code class="ts">function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {return firstName + &#39; &#39; + lastName;}</code></pre></li></ul></li><li><p>剩余参数</p><ul><li>事实上，剩余参数是一个数组。所以我们可以用数组的类型来定义它<pre><code class="ts">function push(array: any[], ...items: any[]) {items.forEach(function(item) {   array.push(item);});}let a = [];push(a, 1, 2, 3);</code></pre></li></ul></li><li><p>重载</p><ul><li>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理</li><li>通常做法：重复定义了多次函数，前几次都是函数定义，最后一次是函数实现。</li><li>TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。<pre><code class="ts">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string {if (typeof x === &#39;number&#39;) {   return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));} else if (typeof x === &#39;string&#39;) {   return x.split(&#39;&#39;).reverse().join(&#39;&#39;);}}</code></pre></li></ul></li></ul><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p><p>语法： <code>&lt;类型&gt;值</code> 或 <code>值 as 类型</code>，在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种。</p><pre><code class="ts">// 获取长度例子：function getLength(something: string|number): number {  if((&lt;string&gt;something).length) {  //可能是number，所以断言    return (&lt;string&gt;something).length  } else {    return something.toString().length;  }}</code></pre><p>注意： 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</p><h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><p>通常我们会把声明语句放到一个单独的文件中，声明文件必需以 <code>.d.ts</code> 为后缀。</p><pre><code class="ts">// src/jQuery.d.tsdeclare var jQuery: (selector: string) =&gt; any;</code></pre><p>更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p><p>@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：<code>npm install @types/jquery --save-dev</code></p><p>可以在<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">这个页面</a>搜索你需要的声明文件。</p><h4 id="书写声明文件"><a href="#书写声明文件" class="headerlink" title="书写声明文件"></a>书写声明文件</h4><ul><li>以<code>npm install @types/xxx --save-dev</code>安装的，则不需要任何配置。</li><li>如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 src 目录下</li><li>如果没有生效，可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件</li><li>语法<ul><li>declare var/let/const <ul><li>声明全局变量，一般用const</li></ul></li><li>declare function <ul><li>声明全局方法的<strong>类型</strong></li></ul></li><li>declare class <ul><li>声明全局类，只定义不实现</li></ul></li><li>declare enum <ul><li>声明全局枚举类型</li></ul></li><li>declare namespace <ul><li>它用来表示全局变量是一个对象，包含很多子属性。</li><li>可嵌套定义</li></ul></li><li>interface 和 type<ul><li>声明全局类型</li></ul></li></ul></li><li>防止命名冲突<ul><li>暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故应该将他们放到 namespace 下。在使用这个 interface 的时候，也应该加上 命名空间 前缀了</li></ul></li><li>npm 包<ul><li>已存在配置<ul><li>与该 npm 包绑定在一起。</li><li>发布到了 <code>@types</code> 里。</li></ul></li><li>自己为它写声明文件<ul><li>创建一个 types 目录，专门用来管理自己写的声明文件，将 foo 的声明文件放到 types/foo/index.d.ts 中。</li></ul></li><li><code>export</code><ul><li>在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明。</li></ul></li></ul></li></ul><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p><p>在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库</a>的定义文件中定义了JS的内置对象。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名用来给一个类型起个新名字。类型别名常用于联合类型。</p><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>类型别名与字符串字面量类型都是使用 type 进行定义。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</li><li>对象（Object）：类的实例，通过 new 生成</li><li>面向对象（OOP）的三大特性：封装、继承、多态</li><li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li><li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li><li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。</li><li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li><li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法</li><li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li><li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul><h4 id="TS中的类"><a href="#TS中的类" class="headerlink" title="TS中的类"></a>TS中的类</h4><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li></ul><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p><ul><li>抽象类是不允许被实例化</li><li>抽象类中的抽象方法必须被子类实现</li></ul><h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><p>有时候<strong>不同类之间可以有一些共有的特性，这时候就把特性提取成接口（interfaces）</strong>，用 implements 关键字来实现。 </p><ul><li>一个类可实现多个接口</li><li>接口与接口之间可以是继承关系</li><li>接口也可以继承类</li><li>混合类型（有时候，一个函数还可以有自己的属性和方法）</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用了。</p><pre><code class="ts">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre><p>定义泛型的时候，可以一次定义多个类型参数：</p><pre><code class="ts">function swap&lt;T, U&gt; (tuple:[T, U]) : [U, T] {  return [tuple[1], tuple[0]];}swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]</code></pre><ul><li>泛型约束<ul><li>即函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法，这时，我们可以对泛型进行约束。<strong>即让泛型继承一个接口</strong></li><li>多个类型参数之间也可以相互约束，如下例：其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。</li></ul></li><li>泛型接口<ul><li>在使用泛型接口的时候，需要定义泛型的类型</li></ul></li><li>泛型类</li><li>泛型参数的默认类型<ul><li>当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</li></ul></li></ul><h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型。</p><pre><code class="ts">interface Alarm {    price: number;    alert(s: string): string;}interface Alarm {    weight: number;    alert(s: string, n: number): string;}</code></pre><p>相当于：</p><pre><code class="ts">interface Alarm {    price: number;    weight: number;    alert(s: string): string;    alert(s: string, n: number): string;}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript/interface与type</title>
    <link href="/uncategorized/TypeScript/interface%E4%B8%8Etype/"/>
    <url>/uncategorized/TypeScript/interface%E4%B8%8Etype/</url>
    
    <content type="html"><![CDATA[<h1 id="Typescript-中的-interface-和-type"><a href="#Typescript-中的-interface-和-type" class="headerlink" title="Typescript 中的 interface 和 type"></a>Typescript 中的 interface 和 type</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul><li>都可以描述一个对象或者函数</li><li>都允许拓展（extends）</li></ul><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h3><ul><li>type 声明的方式可以定义组合类型，交叉类型，原始类型。<pre><code class="js">// 基本类型别名type Name = string</code></pre></li></ul><p>// 联合类型<br>interface Dog {<br>    wong();<br>}<br>interface Cat {<br>    miao();<br>}</p><p>type Pet = Dog | Cat<br>// 具体定义数组每个位置的类型<br>type PetList = [Dog, Pet]</p><pre><code> - type 语句中还可以使用 typeof 获取实例的 类型进行赋值```js// 当你想获取一个变量的类型时，使用 typeoflet div = document.createElement(&#39;div&#39;);type B = typeof div</code></pre><ul><li>其他操作<pre><code class="js">type StringOrNumber = string | number;  type Text = string | { text: string };  type NameLookup = Dictionary&lt;string, Person&gt;;  type Callback&lt;T&gt; = (data: T) =&gt; void;  type Pair&lt;T&gt; = [T, T];  type Coordinates = Pair&lt;number&gt;;  type Tree&lt;T&gt; = T | { left: Tree&lt;T&gt;, right: Tree&lt;T&gt; };</code></pre></li></ul><h3 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h3><ul><li>interface 能够声明合并<pre><code class="js">interface User {name: stringage: number}</code></pre></li></ul><p>interface User {<br>  sex: string<br>}</p><p>/*<br>User 接口为 {<br>  name: string<br>  age: number<br>  sex: string<br>}<br>*/</p><p> ```</p><ul><li>一个函数，如果想使用<code>函数名.值</code>的方式，只能 interface</li></ul><p> 参考：<a href="https://juejin.im/post/5c2723635188252d1d34dc7d" target="_blank" rel="noopener">https://juejin.im/post/5c2723635188252d1d34dc7d</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React/高阶组件</title>
    <link href="/uncategorized/React/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
    <url>/uncategorized/React/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是高阶组件，它有哪些运用？"><a href="#什么是高阶组件，它有哪些运用？" class="headerlink" title="什么是高阶组件，它有哪些运用？"></a>什么是高阶组件，它有哪些运用？</h3><p>高阶组件就是一个函数，接收一个组件，经过处理后返回后的新的组件；<br>高阶组件，不是真正意义上的组件，其实是一种模式；<br>可以对逻辑代码进行抽离，或者添加某个共用方法；<br>eg：</p><ul><li>react-redux ：connect就是一个高阶组件,接收一个component,并返回一个新的componet,处理了监听store和后续的处理；</li><li>react-router ：withrouter 为一个组件注入 history对象；</li></ul><h3 id="高阶组件和父组件的区别？"><a href="#高阶组件和父组件的区别？" class="headerlink" title="高阶组件和父组件的区别？"></a>高阶组件和父组件的区别？</h3><p>高阶组件可以重写传入组件的state,function,props;可以对代码逻辑进行抽离，重写；<br>父组件只是控制子组件的view层；</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React/VDOM</title>
    <link href="/uncategorized/React/VDOM/"/>
    <url>/uncategorized/React/VDOM/</url>
    
    <content type="html"><![CDATA[<ul><li>VDOM 是什么？为什么会存在VDOM？</li><li>VDOM如何应用，核心API是什么</li><li>介绍diff算法</li></ul><h3 id="VDOM是什么？为什么会存在VDOM？"><a href="#VDOM是什么？为什么会存在VDOM？" class="headerlink" title="VDOM是什么？为什么会存在VDOM？"></a>VDOM是什么？为什么会存在VDOM？</h3><p>在MVVM开发方式中，页面的变化都是用数据去驱动的，而数据更新后，到底要去改那一块的DOM哪？<br>虽然可以先删除那个部分再按照当前新的数据去重新生成一个新的页面或生成那一个部分（jQuery做法），但是这样肯定非常耗费性能的。<br>而且JS操作DOM是非常复杂，JS操作DOM越多，控制与页面的耦合度就越高，代码越难以维护。</p><p>虚拟DOM，即用JS对象来描述DOM树结构，Diff算法则是找旧VDOM与新的VDOM的最小差异，然后再把差异渲染出来</p><p><img src="../img/domtree.png" srcset="/img/loading.gif" alt="DOM"><br><img src="../img/vdon.png" srcset="/img/loading.gif" alt="vdom"></p><p>描述一个DOM节点</p><ul><li>tag 标签名</li><li>attrs DOM属性键值对</li><li>childen DOM字节点数组 或 文本内容</li></ul><p><a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">如何理解虚拟 DOM?-zhihu</a></p><h3 id="为什么DOM操作慢？-因为属性太多了"><a href="#为什么DOM操作慢？-因为属性太多了" class="headerlink" title="为什么DOM操作慢？ 因为属性太多了"></a>为什么DOM操作慢？ 因为属性太多了</h3><p><img src="../img/domattr.png" srcset="/img/loading.gif" alt="domattr"></p><h3 id="vdom如何应用，核心API是什么"><a href="#vdom如何应用，核心API是什么" class="headerlink" title="vdom如何应用，核心API是什么"></a>vdom如何应用，核心API是什么</h3><ul><li>创建虚拟节点<ul><li>h(‘标签名’, {…属性…}, […子元素…])</li><li>h(‘标签名’, {…属性…}, ‘文本内容’)</li></ul></li><li>将VNode添加到一个DOM元素内<ul><li>patch(DOM_obj, vnode);</li></ul></li><li>用一个新的vnode来和旧的vnode进行比较，得出新旧dom的差异</li><li>patch(vnode, newVnode)</li></ul><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>对比Vdom树差异的算法<br><a href="https://segmentfault.com/a/1190000000606216" target="_blank" rel="noopener">React 的 diff 算法</a></p><h4 id="同层比对"><a href="#同层比对" class="headerlink" title="同层比对"></a>同层比对</h4><p>新旧状态的比对时采用同层比对，当发现某节点不一致了直接替换该节点的子树。而不管它的子树是不是真的改动了。</p><h4 id="key值的使用"><a href="#key值的使用" class="headerlink" title="key值的使用"></a>key值的使用</h4><p>在列表循环的时候React会要求每一个列表项有一个<strong>独一无二</strong>，<strong>稳定的key值</strong>，它的目的是为了当状态改变时新旧状态的每一个列表项能够对应起来，方便比对。</p><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。<br> Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系</p><h4 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h4><p>调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React/setState</title>
    <link href="/uncategorized/React/setState/"/>
    <url>/uncategorized/React/setState/</url>
    
    <content type="html"><![CDATA[<h1 id="深入-setState-机制"><a href="#深入-setState-机制" class="headerlink" title="深入 setState 机制"></a><a href="https://github.com/sisterAn/blog/issues/26" target="_blank" rel="noopener">深入 setState 机制</a></h1><h3 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h3><p>考虑到性能问题，setState使用一个<strong>队列机制</strong>来更新state。<br>当执行setState时，会将需要更新的state<strong>浅合并</strong>后放入状态队列，不会立即更新state。而如果不使用setState，而直接修改state的值就不会放入状态队列，下一次调用setState对状态队列进行更新的时候可能会造成不可预知的错误。</p><p>例子：</p><pre><code class="js">// 假设 state.count === 0this.setState({count: state.count + 1});this.setState({count: state.count + 1});this.setState({count: state.count + 1});// state.count === 1, 而不是 3</code></pre><p>本质上等同于：</p><pre><code class="js">// 假设 state.count === 0Object.assign(state,    {count: state.count + 1},    {count: state.count + 1},    {count: state.count + 1})// {count: 1}</code></pre><p><strong>解决方法</strong>为： <strong>传递一个签名为 (state, props) =&gt; newState 的函数作为参数。</strong> 向setState中传入函数时，这个函数不会被浅合并，一定会执行，是一个原子性更新操作。</p><pre><code class="js">// 正确用法this.setState((prevState, props) =&gt; ({    count: prevState.count + props.increment}))</code></pre><h3 id="setState-循环调用风险"><a href="#setState-循环调用风险" class="headerlink" title="setState 循环调用风险"></a>setState 循环调用风险</h3><p>但，如果在<code>shouldComponentUpdate</code>或<code>componentWillUpdate</code> 方法里调用 this.setState 方法，就会造成崩溃。<br><img src="../img/setStateCercle.png" srcset="/img/loading.gif" alt=""></p><h3 id="何时同步？何时异步？"><a href="#何时同步？何时异步？" class="headerlink" title="何时同步？何时异步？"></a>何时同步？何时异步？</h3><p>如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。<br>所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。而这一切都是因为一个非常核心的概念–事务</p><pre><code class="js">class Example extends React.Component {  constructor() {    super();    this.state = {      val: 0    };  }  componentDidMount() {    this.setState({val: this.state.val + 1});    console.log(this.state.val);    // 第 1 次 log    this.setState({val: this.state.val + 1});    console.log(this.state.val);    // 第 2 次 log    setTimeout(() =&gt; {      this.setState({val: this.state.val + 1});      console.log(this.state.val);  // 第 3 次 log      this.setState({val: this.state.val + 1});      console.log(this.state.val);  // 第 4 次 log    }, 0);  }  render() {    return null;  }};答案是 0 0 2 3</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React/Redux</title>
    <link href="/uncategorized/React/Redux/"/>
    <url>/uncategorized/React/Redux/</url>
    
    <content type="html"><![CDATA[<h3 id="redux简介"><a href="#redux简介" class="headerlink" title="redux简介"></a>redux简介</h3><p>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，<code>action，store，reducer</code></p><p>工作流程是： </p><ul><li>view用actionCreator创建一个action,里面可能包含一些数据</li><li>使用store的dispatch方法将acion传入store</li><li>store将action与旧的state转发给reducer</li><li>reducer深拷贝state,并返回一个新的state给store</li><li>store接收并更新state</li><li>使用store.subscribe订阅更新,重新render组件</li></ul><h3 id="reducer为什么是纯函数？"><a href="#reducer为什么是纯函数？" class="headerlink" title="reducer为什么是纯函数？"></a>reducer为什么是纯函数？</h3><p>从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。<br><img src="../img/pureRedux.png" srcset="/img/loading.gif" alt=""></p><p>阅读源码可以看到，Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。</p><p>Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同（也就是Javascript对象浅比较）。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。</p><p>深比较在真实的应用当中代价昂贵，因为通常js的对象都很大，同时需要比较的次数很多。</p><p>因此一个有效的解决方法是作出一个规定：无论何时发生变化时，开发者都要创建一个新的对象，然后将新对象传递出去。同时，当没有任何变化发生时，开发者发送回旧的对象。也就是说，新的对象代表新的state。  使用了新的策略之后，你能够比较两个对象通过使用!==比较两个对象的存储位置而不是比较两个对象的所有属性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React/README</title>
    <link href="/uncategorized/React/README/"/>
    <url>/uncategorized/React/README/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="VDOM"><a href="#VDOM" class="headerlink" title="VDOM"></a><a href="VDOM.md">VDOM</a></h2><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a><a href="Redux.md">Redux</a></h2><h2 id="React中性能优化"><a href="#React中性能优化" class="headerlink" title="React中性能优化"></a><a href="React中性能优化.md">React中性能优化</a></h2><h2 id="React与Vue区别"><a href="#React与Vue区别" class="headerlink" title="React与Vue区别"></a><a href="react与vue区别.md">React与Vue区别</a></h2><h3 id="React-的工作原理"><a href="#React-的工作原理" class="headerlink" title="React 的工作原理"></a>React 的工作原理</h3><p>React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 “diffing” 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。</p><h3 id="使用-React-有何优点"><a href="#使用-React-有何优点" class="headerlink" title="使用 React 有何优点"></a>使用 React 有何优点</h3><ul><li>JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的</li><li>支持服务端渲染，可改进SEO和性能</li><li>易于测试</li><li>React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用</li></ul><h3 id="react生命周期函数"><a href="#react生命周期函数" class="headerlink" title="react生命周期函数"></a>react生命周期函数</h3><p>一、初始化阶段：</p><ul><li>getDefaultProps<ul><li>获取实例的默认属性</li></ul></li><li>getInitialState<ul><li>获取每个实例的初始化状态</li></ul></li><li>componentWillMount<ul><li>组件即将被装载、渲染到页面上</li><li>多用于根组件中的应用程序配置</li></ul></li><li>render<ul><li>组件在这里生成虚拟的DOM节点</li></ul></li><li>componentDidMount<ul><li>组件真正在被装载之后</li><li>在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据（发送请求）；如果需要设置事件监听，也可以在这完成</li></ul></li></ul><p>二、运行中状态：</p><ul><li>componentWillReceiveProps<ul><li>组件将要接收到属性的时候调用</li></ul></li><li>shouldComponentUpdate<ul><li>是一个改善性能的地方，组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了）</li></ul></li><li>componentWillUpdate<ul><li>组件即将更新不能修改属性和状态</li></ul></li><li>render<ul><li>组件重新描绘</li></ul></li><li>componentDidUpdate<ul><li>组件已经更新</li><li>响应 prop 或 state 的改变</li></ul></li></ul><p>三、销毁阶段：</p><ul><li>componentWillUnmount<ul><li>组件即将销毁</li><li>在这你可以取消网络请求，或者移除所有与组件相关的事件监听器</li></ul></li></ul><h3 id="当你调用setState的时候，发生了什么事？"><a href="#当你调用setState的时候，发生了什么事？" class="headerlink" title="当你调用setState的时候，发生了什么事？"></a>当你调用setState的时候，发生了什么事？</h3><ul><li>将传递给 setState 的对象合并到组件的当前状态，触发所谓的调和过程（Reconciliation）</li><li>然后生成新的DOM树并和旧的DOM树使用Diff算法对比</li><li>根据对比差异对界面进行最小化重渲染</li></ul><h3 id="setState第二个参数的作用"><a href="#setState第二个参数的作用" class="headerlink" title="setState第二个参数的作用"></a>setState第二个参数的作用</h3><p>因为setState是一个异步的过程，所以说执行完setState之后不能立刻更改state里面的值。如果需要对state数据更改监听，setState提供第二个参数，就是用来监听state里面数据的更改，当数据更改完成，调用回调函数。</p><h3 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h3><p>setState它是一个异步函数，他会合并多次修改，降低diff算法的比对频率。这样也会提升性能。</p><p>因为 this.props 和 this.state 的<strong>更新是异步的</strong>，<strong>不能依赖它们的值</strong>去计算下一个 state。</p><h3 id="react中key的作用"><a href="#react中key的作用" class="headerlink" title="react中key的作用"></a>react中key的作用</h3><p>key是React中用于追踪哪些列表中元素被修改、删除或者被添加的辅助标识。在diff算法中，key用来判断该元素节点是被移动过来的还是新创建的元素，减少不必要的元素重复渲染。</p><h3 id="sass和less的区别"><a href="#sass和less的区别" class="headerlink" title="sass和less的区别"></a>sass和less的区别</h3><p>定义变量的符号不同，less是用@，sass使用$<br>变量的作用域不同，less在全局定义，就作用在全局，在代码块中定义，就作用于整哥代码块。而sass只作用域全局。</p><h3 id="react生命周期中，最适合与服务端进行数据交互的是哪个函数"><a href="#react生命周期中，最适合与服务端进行数据交互的是哪个函数" class="headerlink" title="react生命周期中，最适合与服务端进行数据交互的是哪个函数"></a>react生命周期中，最适合与服务端进行数据交互的是哪个函数</h3><p><code>componentDidMount</code>：在这个阶段，<strong>实例和dom已经挂载完成，可以进行相关的dom操作</strong>。</p><h3 id="react中组件传值"><a href="#react中组件传值" class="headerlink" title="react中组件传值"></a>react中组件传值</h3><p>父传子（组件嵌套浅）：父组件定义一个属性，子组件通过this.props接收。</p><p>子传父：父组件定义一个属性，并将一个回调函数赋值给定义的属性，然后子组件进行调用传过来的函数，并将参数传进去，在父组件的回调函数中即可获得子组件传过来的值。</p><h3 id="在constructor中绑定事件函数的this指向"><a href="#在constructor中绑定事件函数的this指向" class="headerlink" title="在constructor中绑定事件函数的this指向"></a>在constructor中绑定事件函数的this指向</h3><p>把一个对象的方法赋值给一个变量会造成this的丢失，所以需要绑定this，把绑定放在构造函数中可以保证只绑定一次函数，如果放在render函数中绑定this的话每次渲染都会去绑定一次this，那样是很耗费性能的。</p><h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h3><p>当父组件被重新渲染时即render函数执行时，子组件就会默认被重新渲染，但很多时候是不需要重新渲染每一个子组件的。这时就可以使用 shouldComponentUpdate 来判断是否真的需要重新渲染子组件。仅仅一个判断，就可以节约很多的消耗。<br>所以对于父组件发生变化而子组件不变的情况，使用shouldComponentUpdate会提升性能。</p><pre><code class="js">shouldComponentUpdate(nextProps, nextState) {    if(nextProps.content === this.props.content) {        return false;    } else {        return true;    }}</code></pre><h3 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h3><p><code>PureComponent</code>内部帮我们实现了<code>shouldComponentUpdate</code>的比较，其他和Component一样。但是在shouldComponentUpdate进行的是一个<strong>浅比较</strong>，看看官方文档是怎么说的。</p><p>浅比较只比较第一层的基本类型和引用类型值是否相同</p><p>如果数据结构比较复杂，那么可能会导致一些问题，要么当你知道改变的时候调用<code>forceUpdate</code>,要么使用<code>immutable</code>来包装你的state</p><h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>无状态组件就是使用定义函数的方式来定义组件，这种组件相比于使用类的方式来定义的组件(有状态组件)，少了很多初始化过程，更加精简，所以要是可以使用无状态组件应当尽可能的使用无状态组件，会大幅度提升效率</p><h3 id="refs-作用"><a href="#refs-作用" class="headerlink" title="refs 作用"></a>refs 作用</h3><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的API。</p><h3 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么"></a>(在构造函数中)调用 super(props) 的目的是什么</h3><p><strong>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。</strong><br>传递 props 给 super() 的原因则是让子类中能用 constructor 访问 this.props。</p><h3 id="展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><a href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同" class="headerlink" title="展示组件(Presentational component)和容器组件(Container component)之间有何不同"></a>展示组件(Presentational component)和容器组件(Container component)之间有何不同</h3><ul><li>展示组件关心组件看起来是什么。<ul><li>展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</li></ul></li><li>容器组件则更关心组件是如何运作的。<ul><li>容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</li></ul></li></ul><h3 id="类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><a href="#类组件-Class-component-和函数式组件-Functional-component-之间有何不同" class="headerlink" title="类组件(Class component)和函数式组件(Functional component)之间有何不同"></a>类组件(Class component)和函数式组件(Functional component)之间有何不同</h3><ul><li>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</li><li>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</li></ul><h3 id="状态-state-和属性-props-之间有何不同"><a href="#状态-state-和属性-props-之间有何不同" class="headerlink" title="状态(state)和属性(props)之间有何不同"></a>状态(state)和属性(props)之间有何不同</h3><p><code>State</code>是一种数据结构，用于组件挂载时所需的默认值。State可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</p><p><code>props</code>是组件的配置。props由父组件传递给子组件，就子组件而言，props是不可变的。组件不能改变自身props，但是可以把其他子组件的props防止一起管理。<br>props也不仅仅是数据，回调函数也可以通过props传递。</p><h3 id="客户端渲染与服务端渲染"><a href="#客户端渲染与服务端渲染" class="headerlink" title="客户端渲染与服务端渲染"></a>客户端渲染与服务端渲染</h3><p>客户端渲染即普通的React项目渲染方式。<br>客户端渲染流程：</p><ol><li>浏览器发送请求</li><li>服务器返回HTML</li><li>浏览器发送bundle.js请求</li><li>服务器返回bundle.js</li><li>浏览器执行bundle.js中的React代码</li></ol><p>CSR带来的问题：</p><ol><li>首屏加载时间过长</li><li>SEO 不友好</li></ol><p>因为时间在往返的几次网络请求中就耽搁了，而且因为CSR返回到页面的HTML中没有内容，就只有一个root空元素，页面内容是靠js渲染出来的，爬虫在读取网页时就抓不到信息，所以SEO不友好</p><p>SSR带来的问题：</p><ol><li>React代码在服务器端执行，很大的消耗了服务器的性能</li></ol><h3 id="React-同构时页面加载流程"><a href="#React-同构时页面加载流程" class="headerlink" title="React 同构时页面加载流程"></a>React 同构时页面加载流程</h3><ol><li>服务端运行React代码渲染出HTML</li><li>浏览器加载这个无交互的HTML代码</li><li>浏览器接收到内容展示</li><li>浏览器加载JS文件</li><li>JS中React代码在浏览器中重新执行</li></ol><h3 id="应该在-React-组件的何处发起-Ajax-请求"><a href="#应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="应该在 React 组件的何处发起 Ajax 请求"></a>应该在 React 组件的何处发起 Ajax 请求</h3><p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。<br>更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。</p><h3 id="受控组件-controlled-component"><a href="#受控组件-controlled-component" class="headerlink" title="受控组件(controlled component)"></a>受控组件(controlled component)</h3><p>一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。</p><p>在 HTML 中，类似 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值。</p><h3 id="除了在构造函数中绑定-this，还有其它方式吗"><a href="#除了在构造函数中绑定-this，还有其它方式吗" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗"></a>除了在构造函数中绑定 this，还有其它方式吗</h3><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p><h3 id="怎么阻止组件的渲染"><a href="#怎么阻止组件的渲染" class="headerlink" title="怎么阻止组件的渲染"></a>怎么阻止组件的渲染</h3><p>在组件的 render 方法中返回 null 并不会影响触发组件的生命周期方法</p><h3 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h3><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式。</p><ul><li>Hash 模式</li><li>History 模式</li></ul><h4 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h4><p><code>www.test.com/#/</code> 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 <a href="http://www.test.com。" target="_blank" rel="noopener">www.test.com。</a></p><pre><code class="js">window.addEventListener(&#39;hashchange&#39;, () =&gt; {  // ... 具体逻辑})</code></pre><h4 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h4><p>History 模式是 HTML5 新推出的功能，主要使用 <code>history.pushState</code> 和 <code>history.replaceState</code> 改变 URL。</p><p>通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</p><pre><code class="js">// 新增历史记录history.pushState(stateObject, title, URL)// 替换当前历史记录history.replaceState(stateObject, title, URL)</code></pre><p>当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件</p><pre><code class="js">window.addEventListener(&#39;popstate&#39;, e =&gt; {  // e.state 就是 pushState(stateObject) 中的 stateObject  console.log(e.state)})</code></pre><h4 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h4><ul><li>Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL</li><li>History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串</li><li>Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候</li></ul><h3 id="Vue-和-React区别"><a href="#Vue-和-React区别" class="headerlink" title="Vue 和 React区别"></a>Vue 和 React区别</h3><p>改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用 setState 来改变状态，并且使用这个 API 也有一些坑点。<br> Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。</p><p>React 需要使用 JSX，Vue 使用了模板语法</p><h3 id="高阶组件-HOC-higher-order-component"><a href="#高阶组件-HOC-higher-order-component" class="headerlink" title="高阶组件 HOC (higher order component)"></a>高阶组件 HOC (higher order component)</h3><p>高阶组件是一个以组件为参数并返回一个新组件的函数。</p><p>HOC 允许你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p><pre><code class="js">function add(a, b) {    return a + b}</code></pre><p>现在如果我想给这个 add 函数添加一个输出结果的功能，那么你可能会考虑我直接使用 console.log 不就实现了么。说的没错，但是如果我们想做的更加优雅并且容易复用和扩展，我们可以这样去做：</p><pre><code class="js">function withLog (fn) {    function wrapper(a, b) {        const result = fn(a, b)        console.log(result)        return result    }    return wrapper}const withLogAdd = withLog(add)withLogAdd(1, 2)</code></pre><p>这个做法在函数式编程里称之为高阶函数，大家都知道 React 的思想中是存在函数式编程的，高阶组件和高阶函数就是同一个东西。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。</p><h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><p>React 其实自己实现了一套事件机制，首先我们考虑一下以下代码：</p><pre><code class="js">const Test = ({ list, handleClick }) =&gt; ({    list.map((item, index) =&gt; (        &lt;span onClick={handleClick} key={index}&gt;{index}&lt;/span&gt;    ))})</code></pre><p>事实当然不是，JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的<strong>事件都统一绑定在了<code>document</code>上</strong>。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p><p>另外冒泡到 document 上的事件也不是原生浏览器事件，而是<strong>React自己实现的合成事件</strong>（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。</p><p>那么实现合成事件的目的好处有两点，分别是：</p><ul><li>合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力</li><li>对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React/React中性能优化</title>
    <link href="/uncategorized/React/React%E4%B8%AD%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/uncategorized/React/React%E4%B8%AD%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000006254212" target="_blank" rel="noopener">React性能优化</a></p><p><a href="https://segmentfault.com/a/1190000008925295" target="_blank" rel="noopener">React进阶—性能优化</a></p><h3 id="为什么使用Virtual-DOM，直接操作DOM的弊端是什么？"><a href="#为什么使用Virtual-DOM，直接操作DOM的弊端是什么？" class="headerlink" title="为什么使用Virtual DOM，直接操作DOM的弊端是什么？"></a>为什么使用Virtual DOM，直接操作DOM的弊端是什么？</h3><p>操作DOM是非常昂贵的，因为一个普通的DOM上有非常多的属性和方法，页面的性能问题很多都是由DOM操作引起的。</p><p>VDOM的意义在于实现了对DOM的抽象，从而配合Diff算法来比对新旧状态切换时页面需要更新的最小DOM范围。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React/React与Vue区别</title>
    <link href="/uncategorized/React/React%E4%B8%8EVue%E5%8C%BA%E5%88%AB/"/>
    <url>/uncategorized/React/React%E4%B8%8EVue%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="React与Vue区别"><a href="#React与Vue区别" class="headerlink" title="React与Vue区别"></a>React与Vue区别</h1><ul><li>上手<ul><li>vue - easy 官方做了很多,CSS script</li><li>react ，上手偏难，</li></ul></li><li>数据绑定<ul><li>vue model双向的</li><li>react是单向的</li></ul></li><li>模板<ul><li>vue H5模板</li><li>react JSX</li></ul></li><li>api<ul><li>vue 多，计算属性，watch 这种神器</li><li>react 少，更多功能留给社区，比如写个函数还有bind以下</li></ul></li><li>应用<ul><li>vue 适合面向用户的，复杂度稍低一些的</li><li>react 复杂的</li></ul></li><li>测试<ul><li>react 函数式编程利于测试</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React/react-router</title>
    <link href="/uncategorized/React/react-router/"/>
    <url>/uncategorized/React/react-router/</url>
    
    <content type="html"><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>React中路由主要有两种方式：</p><ul><li>hash路由</li><li>history路由</li></ul><p><a href="https://blog.csdn.net/qq_36223144/article/details/83247008" target="_blank" rel="noopener">react-router原理</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React/PureComponent与Component区别</title>
    <link href="/uncategorized/React/PureComponent%E4%B8%8EComponent%E5%8C%BA%E5%88%AB/"/>
    <url>/uncategorized/React/PureComponent%E4%B8%8EComponent%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="何时使用Component还是PureComponent？"><a href="#何时使用Component还是PureComponent？" class="headerlink" title="何时使用Component还是PureComponent？"></a><a href="https://segmentfault.com/a/1190000014979065" target="_blank" rel="noopener">何时使用Component还是PureComponent？</a></h1><p>参考链接：<a href="https://segmentfault.com/a/1190000014979065" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014979065</a></p><p>PureComponent通过prop和state的浅比较来实现shouldComponentUpdate，某些情况下可以用PureComponent提升性能</p><p>所谓浅比较(shallowEqual)，即react源码中的一个函数，然后根据下面的方法进行是不是PureComponent的判断，帮我们做了本来应该我们在shouldComponentUpdate中做的事情</p><pre><code class="js">if (this._compositeType === CompositeTypes.PureClass) {    shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);}</code></pre><pre><code class="js">shouldComponentUpdate(nextProps, nextState) {    return (nextState.person !== this.state.person);}</code></pre><h3 id="什么时候不该用？"><a href="#什么时候不该用？" class="headerlink" title="什么时候不该用？"></a>什么时候不该用？</h3><p>PureComponent中的判断逻辑是浅比较，如果当状态更新时是一个引用对象内部的更新，那么这个时候是不适用的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS/核心模块/process</title>
    <link href="/uncategorized/NodeJS/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/process/"/>
    <url>/uncategorized/NodeJS/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/process/</url>
    
    <content type="html"><![CDATA[<h1 id="process"><a href="#process" class="headerlink" title="process"></a><a href="http://nodejs.cn/api/process.htm" target="_blank" rel="noopener">process</a></h1><h3 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h3><p>cwd()方法可以获得当前执行的路径。和linux下的cwd一样</p><h3 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h3><p><code>process.argv</code> 属性返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数。</p><ul><li>数组第一个元素为：node所安装的路径</li><li>数组第二个元素为：当前执行文件的路径</li><li>剩余元素为执行node命令时传入的参数</li></ul><h3 id="process-argv0"><a href="#process-argv0" class="headerlink" title="process.argv0"></a>process.argv0</h3><p>保存了process.argv数组的第一个值的<em>引用</em>，不常用</p><h3 id="process-execArgv"><a href="#process-execArgv" class="headerlink" title="process.execArgv"></a>process.execArgv</h3><p>process.execArgv 属性返回当Node.js进程被启动时，Node.js特定的命令行选项（位于node后，文件名之前）。 这些选项在process.argv属性返回的数组中不会出现。</p><h3 id="process-execPath"><a href="#process-execPath" class="headerlink" title="process.execPath"></a>process.execPath</h3><p>返回启动 Node.js 进程的可执行文件的绝对路径名。基本就是 process.argv 的第一个参数</p><h3 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h3><p>process.env 属性返回包含用户环境的对象。</p><h4 id="process-env-PATH"><a href="#process-env-PATH" class="headerlink" title="process.env.PATH"></a>process.env.PATH</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS/核心模块/path</title>
    <link href="/uncategorized/NodeJS/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/path/"/>
    <url>/uncategorized/NodeJS/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/path/</url>
    
    <content type="html"><![CDATA[<h1 id="path"><a href="#path" class="headerlink" title="path"></a>path</h1><p>path 模块提供用于处理文件路径和目录路径的实用工具。</p><h3 id="normalize、join、resolve"><a href="#normalize、join、resolve" class="headerlink" title="normalize、join、resolve"></a>normalize、join、resolve</h3><ul><li><p>path.normalize() 方法规范化给定的 path，解析 ‘..’ 和 ‘.’ 片段。</p><pre><code class="js">path.normalize(&#39;/foo/bar//baz/asdf/quux/..&#39;);// 返回: &#39;/foo/bar/baz/asdf&#39;</code></pre></li><li><p>path.join方法使用平台特定分隔符作为定界符将所有给定的path片段连接在一起，然后生成规范的路径</p></li></ul><pre><code class="js">path.join(&#39;/foo&#39;, &#39;bar&#39;, &#39;baz/asdf&#39;, &#39;..&#39;) // 返回: &#39;/foo/bar/baz/asdf&#39;</code></pre><ul><li>path.resolve([…paths])把一个相对路径解析成一个绝对路径。<pre><code class="js">[path.join([...paths])](path.resolve(&#39;wwwroot&#39;, &#39;static_files/png/&#39;, &#39;../gif/image.gif&#39;);// 如果当前工作目录是 /home/myself/node，// 则返回 &#39;/home/myself/node/wwwroot/static_files/gif/image.gif&#39;)</code></pre></li></ul><h3 id="basename、dirname、extname"><a href="#basename、dirname、extname" class="headerlink" title="basename、dirname、extname"></a>basename、dirname、extname</h3><ul><li>basename<ul><li>文件名.拓展名</li></ul></li><li>dirname<ul><li>所在的文件夹</li></ul></li><li>extname<ul><li>拓展名是什么<pre><code>┌─────────────────────┬────────────┐│          dir        │    base    │├──────┬              ├──────┬─────┤│ root │              │ name │ ext │&quot;  /    home/user/dir / file  .txt &quot;└──────┴──────────────┴──────┴─────┘</code></pre></li></ul></li></ul><h3 id="parse-与-format"><a href="#parse-与-format" class="headerlink" title="parse 与 format"></a>parse 与 format</h3><ul><li>parse是将字符串形式的文件路径给解析成一个包含 root, dir, base, name, ext属性的对象</li><li>format则是将这个对象代表的路径转成字符串形式，与parse相反</li></ul><p>如果有了一个路径指向修改其中的一个内容，那么就可以使用parse转成对象然后修改后使用format在转成一个新路径。</p><p>当为 pathObject 提供属性时，注意以下组合，其中一些属性优先于另一些属性：</p><ul><li>如果提供了 pathObject.dir，则忽略 pathObject.root。</li><li>如果 pathObject.base 存在，则忽略 pathObject.ext 和 pathObject.name。</li></ul><h3 id="sep、delimiter、win32、posix"><a href="#sep、delimiter、win32、posix" class="headerlink" title="sep、delimiter、win32、posix"></a>sep、delimiter、win32、posix</h3><ul><li>sep提供平台特定的路径片段分隔符：<ul><li>Windows 上是 \；POSIX 上是 /</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS/模块机制</title>
    <link href="/uncategorized/NodeJS/%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    <url>/uncategorized/NodeJS/%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h1><h2 id="CommonJS模块规范"><a href="#CommonJS模块规范" class="headerlink" title="CommonJS模块规范"></a>CommonJS模块规范</h2><p>模块引用</p><pre><code class="js">var math = require(&#39;math&#39;);</code></pre><p>模块定义<br>上下文提供exports对象用于导出当前模块的方法和变量，并且他是唯一的导出出口</p><p>exports实际上是module.exports，而module.exports就是以一个暴露给外部的对象。</p><ul><li>exports.some就是给这个对象上添加属性</li><li>直接使用 module.exports = {…} 则可以让外部直接获取到这个对象，相当与为exports换了一个引用，如果在这之前使用exports.some会把之前的覆盖</li></ul><h3 id="CommonJS-用法"><a href="#CommonJS-用法" class="headerlink" title="CommonJS 用法"></a>CommonJS 用法</h3><pre><code class="js">// a.jsmodule.exports = {    a: 1}// or exports.a = 1// b.jsvar module = require(&#39;./a.js&#39;)module.a // -&gt; log 1</code></pre><p>原理</p><pre><code class="js">var module = require(&#39;./a.js&#39;)module.a // 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，// 重要的是 module 这里，module 是 Node 独有的一个变量module.exports = {    a: 1}// module 基本实现var module = {  id: &#39;xxxx&#39;, // 我总得知道怎么去找到他吧  exports: {} // exports 就是个空对象}// 这个是为什么 exports 和 module.exports 用法相似的原因var exports = module.exports var load = function (module) {    // 导出的东西    var a = 1    module.exports = a    return module.exports};// 然后当我 require 的时候去找到独特的// id，然后将要使用的东西用立即执行函数包装下，over</code></pre><h2 id="Node的模块实现"><a href="#Node的模块实现" class="headerlink" title="Node的模块实现"></a>Node的模块实现</h2><p>在Node中引入模块，需要经历3个步骤</p><ul><li>路径分析</li><li>文件定位</li><li>编译执行</li></ul><p>在node中，模块分为两类：一类是node提供的模块称为<strong>核心模块</strong>，一类是用户编写的成为<strong>文件模块</strong>。</p><ul><li>核心模块在编译中编译成了二进制文件。在Node进程启动时，部分核心模块就被直接加载入内存。所以这部分核心模块引入时就<strong>省了文件定位和编译执行</strong>这两个步骤，并且在路径分析中优先判断，它的加载速度是最快的。</li><li>文件模块是运行时动态加载。需要完整的路径分析、文件定位、编译执行</li></ul><h3 id="优先从缓存加载"><a href="#优先从缓存加载" class="headerlink" title="优先从缓存加载"></a>优先从缓存加载</h3><p>Node对引入的模块都回进行缓存，而且缓存的是编译执行后的对象。</p><p>不管是核心模块还是文件模块，require()都一律采用缓存优先的方式。</p><h3 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="headerlink" title="路径分析和文件定位"></a>路径分析和文件定位</h3><p>模块标识符分析</p><ul><li>核心模块</li><li>路径形式的文件模块</li><li>自定义模块<ul><li>node_modules下</li><li>查找最费时</li></ul></li></ul><p>文件定位</p><ul><li>文件拓展名分析<ul><li>如果省略拓展名，回按 .js  .node  .json的次序依次尝试</li><li>如果.node  .json的话，加上拓展名会加快一点速度</li><li>同步配合缓存，可大幅缓解单线程中阻塞式调用的缺陷</li></ul></li><li>目录分析和包<ul><li>如果没有文件名，会将Index当作默认文件名</li></ul></li></ul><h3 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h3><ul><li>.js文件<ul><li>通过fs同步读取后编译执行</li></ul></li><li>.node<ul><li>这是用C/C++编写的拓展文件，通过dlopen()方法加载最后编译生成的文件</li></ul></li><li>.json<ul><li>用JSON.parse()解析返回结果</li></ul></li><li>其余拓展名<ul><li>当作.js文件处理</li></ul></li></ul><p>每一个编译成功的模块都会将其文件路径索引缓存在Module._cache对象上，以提高二次引入性能</p><h4 id="js模块的编译"><a href="#js模块的编译" class="headerlink" title="js模块的编译"></a>js模块的编译</h4><p>在编译的过程中，Node对获取的JS文件进行了头尾包装。这也是每个模块都能访问到 require、exports、module、<strong>filename、</strong>dirname的原因</p><pre><code class="js">(funciton(exports, require, module, __filename, __dirname) {  /* 自己写的代码  */});</code></pre><p>这样使得模块文件间都进行了作用域隔离，不用担心变量污染全局。</p><p>为moudle.exports赋值，exports对象是通过形参的方式传入，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。</p><pre><code class="js">exports = function() {  // my class}var change = function(a) {  a = 100;}var a = 10;change(a);console.log(a); // =&gt; 10</code></pre><p>如果要达到require引入一个类的效果，请赋值给 module.exports对象。这个迂回的方案不改变形参的引用。</p><h4 id="C-C-模块的编译"><a href="#C-C-模块的编译" class="headerlink" title="C/C++ 模块的编译"></a>C/C++ 模块的编译</h4><p>Node调用process.dlopen()方法进行加载和执行。</p><p>实际上 .node模块并不需要编译，因为它是编写C/C++模块之后编译生成的，所以这里只有加载和执行的过程。在执行的过程中，模块exports对象与.node模块产生练习，然后返回给调用者。</p><h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p>Node的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块其实分为C/C++编写的和Javascript编写的两部分，其中C/C++文件存放在Node项目的src目录下，Javascript文件存放在lib目录下。</p><h2 id="C-C-拓展模块"><a href="#C-C-拓展模块" class="headerlink" title="C/C++拓展模块"></a>C/C++拓展模块</h2><h2 id="模块调用栈"><a href="#模块调用栈" class="headerlink" title="模块调用栈"></a>模块调用栈</h2><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a><a href="./nmp.md">npm</a></h2><h2 id="前后端公用模块"><a href="#前后端公用模块" class="headerlink" title="前后端公用模块"></a>前后端公用模块</h2><h3 id="模块侧重点"><a href="#模块侧重点" class="headerlink" title="模块侧重点"></a>模块侧重点</h3><p>前端瓶颈在于带宽，后端瓶颈在于CPU和内存等资源。前端需要通过网络加载代码，后端则从磁盘加载，二者加载速度不再同一量级上。</p><p>node的模块引入几乎都是同步的，但前端模块若是也采用同步方式来引入必会在用户体验上造成很大的问题，即UI初始化实际过长</p><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>Asynchronous Moudle Definition “异步模块定义”<br>AMD需要在声明的时候指定所有的依赖，通过形参传递依赖到模块内容中。</p><p>定义如下</p><pre><code class="js">define(id?, dependencies, factory);</code></pre><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>与AMD主要区别在于定于模块与依赖引入部分。</p><p>CMD支持动态引入</p><pre><code class="js">define(funtion(require, exports, moudle) {  // The module code goes here})</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS/异步IO</title>
    <link href="/uncategorized/NodeJS/%E5%BC%82%E6%AD%A5IO/"/>
    <url>/uncategorized/NodeJS/%E5%BC%82%E6%AD%A5IO/</url>
    
    <content type="html"><![CDATA[<h1 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h1><h2 id="为什么要异步I-O"><a href="#为什么要异步I-O" class="headerlink" title="为什么要异步I/O"></a>为什么要异步I/O</h2><h3 id="用户体验，快！"><a href="#用户体验，快！" class="headerlink" title="用户体验，快！"></a>用户体验，快！</h3><p>使用阻塞式加载两个资源时间为 M + N</p><p>使用异步I/O加载两个资源时间为： max(M, N)</p><h3 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h3><p>假设有一堆不相关的任务需要完成，主流有两种</p><ul><li>单线程串行依次执行</li><li>多线程并行执行</li></ul><p>多线程的代价在于创建线程和执行线程上下文切换的开销较大。在复杂业务中，多线程编程经常面临锁、状态同步等问题，这是多线程的主要诟病。</p><p>单线程顺序执行比较符合思考顺序，而且易于表达。但串行执行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS/README</title>
    <link href="/uncategorized/NodeJS/README/"/>
    <url>/uncategorized/NodeJS/README/</url>
    
    <content type="html"><![CDATA[<h1 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h1><h2 id="NodeJS-特点"><a href="#NodeJS-特点" class="headerlink" title="NodeJS 特点"></a>NodeJS 特点</h2><ul><li>非阻塞式的异步I/O<ul><li>Node.js中采用了非阻塞型I/O机制，因此在执行了访问文件的代码之后，Nodejs不会阻塞在那里等待文件获取完成，而是把这件事交给底层操作系统，使用回调函数的方式来处理异步的IO，立即转而执行其它的代码，</li></ul></li><li>事件轮询<ul><li>Nodejs接收到的事件会放到事件队列中，而不是立即执行它，当NodeJS当前代码执行完后他会检查事件队列中是否有事件，如果有，他会取出来依次执行</li></ul></li><li>单线程<ul><li>Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的</li><li>优点：不会死锁、不用像多线程那样处处在意同步问题、没有线程切换带来的性能上的开销</li><li>缺点：多核CPU需单独开子线程、错误会使得整个应用退出、大量计算会占用CPU从而无法调用异步I/O</li></ul></li><li>擅长I/O密集型<ul><li>主要体现在Node利用事件轮询的方式处理事件，而不是单开一个线程来为每一个请求服务</li></ul></li><li>不擅长CPU密集型业务<ul><li>由于Node单线程，如果长时间运行计算将导致CPU不能释放，使得后续I/O无法发起。（解决办法是分解大型运算为多个小任务，不阻塞I/O发起）</li></ul></li></ul><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>与在浏览器端不同，浏览器端将希望全局访问的对象挂到window上，而nodejs则将希望全局访问的对象挂到global对象上</p><ul><li>CommonJS</li><li>Buffer、process、console</li><li>timer定时器相关</li></ul><h3 id="setImmediate-、setTimeout-fn-0-与-process-nextTick"><a href="#setImmediate-、setTimeout-fn-0-与-process-nextTick" class="headerlink" title="setImmediate()、setTimeout(fn, 0) 与 process.nextTick()"></a>setImmediate()、setTimeout(fn, 0) 与 process.nextTick()</h3><p>两个都是传入一个回调函数，当同步事件执行完之后马上执行。</p><p>执行顺序依次是：</p><ul><li>process.nextTick()<ul><li>将回调函数加入到 当前执行栈的尾部，任务队列之前</li></ul></li><li>setTimeout(fn, 0)<ul><li>回调函数加入到 任务队列尾部。即使是0，也会又4ms的延时</li></ul></li><li>setImmediate()<ul><li>将回调函数插入到任务队列的最末尾，也不会造成阻塞，但不妨碍其他的异步事件</li></ul></li></ul><pre><code class="js">setImmediate(() =&gt; {  console.log(&#39;setImmediate&#39;);})setTimeout(() =&gt; {  console.log(&#39;setImmediate&#39;);}, 0)process.nextTick(() =&gt; {  console.log(&#39;next&#39;);})</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS/npm</title>
    <link href="/uncategorized/NodeJS/npm/"/>
    <url>/uncategorized/NodeJS/npm/</url>
    
    <content type="html"><![CDATA[<h1 id="包与npm"><a href="#包与npm" class="headerlink" title="包与npm"></a>包与npm</h1><h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><p>包实际上是一个存档文件，及一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。完全符合CommonJS规范的包目录应该包含如下这些文件。</p><ul><li>package.json<ul><li>包描述文件</li></ul></li><li>bin<ul><li>存放可执行二进制文件的目录</li></ul></li><li>lib<ul><li>用于存放JavaScript代码目录</li></ul></li><li>doc<ul><li>用于存放文档的目录</li></ul></li><li>test<ul><li>用于存放单元测试用例的代码</li></ul></li></ul><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>CommonJS为起定义了一些必需的字段。</p><ul><li>name<ul><li>包名。唯一的，避免对外发布时命名冲突</li></ul></li><li>description<ul><li>包简介</li></ul></li><li>version<ul><li>版本号</li></ul></li><li>keywords<ul><li>关键词数组，用于做分类搜索</li></ul></li><li>maintainers<ul><li>包维护者列表</li></ul></li></ul><p>权限认证</p><ul><li>contributors<ul><li>贡献者列表</li></ul></li><li>bugs<ul><li>一个可以反馈bug的页面或邮件</li></ul></li><li>licenses<ul><li>包所使用的许可证列表</li></ul></li><li>repositories<ul><li>托管源代码的文件位置</li></ul></li><li><strong>dependencies</strong><ul><li>当前包所依赖的包列表</li></ul></li><li>directories<ul><li>包目录说明</li></ul></li><li>implements<ul><li>实现规范的列表</li></ul></li><li>scripts<ul><li>脚本说明对象</li><li>被包管理器永安里安装、编译、测试、卸载包</li></ul></li></ul><p>补充</p><ul><li>author<ul><li>包作者</li></ul></li><li>bin<ul><li>一些包作者希望包可以作为命令行工具使用。配置好bin字段后，可通过 <code>npm install ... -g</code>将脚本添加到执行路径</li></ul></li><li>main<ul><li>模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。</li></ul></li><li>devDependencies<ul><li>一些模块只在开发时需要依赖。可配置这个属性</li></ul></li></ul><h3 id="npm-常用功能"><a href="#npm-常用功能" class="headerlink" title="npm 常用功能"></a>npm 常用功能</h3><ul><li><p>查看帮助</p><ul><li>npm -v</li><li>npm</li><li>npm &lt;cmd&gt; -h<ul><li>quick help on &lt;cmd&gt;</li></ul></li><li>npm -l<ul><li>display full usage info</li></ul></li><li>npm faq</li><li>npm help &lt;term&gt;</li></ul></li><li><p>安装依赖</p><ul><li>npm install …<ul><li>他会在当前目录下创建 node_moudles，然后在下面创建 … 目录，接着将包解压到这个目录下</li></ul></li><li>npm install … -g <ul><li>全局模块安装。并不意味着可以从任何地方require()来引入它</li><li>-给 其实是将一个包安装为全局可用的可执行命令。他根据包描述文件中 bin 字段配置，将实际脚本链接到与Node可执行文件相同的路径下</li></ul></li><li>从本地安装</li><li>本地安装只需指明npm指明package.json文件所在的位置即可</li></ul></li></ul><p>npm钩子命令<br>package.json中script字段的提出就是让包在安装或者卸载等过程中提供钩子机制</p><pre><code class="js">&quot;script&quot;: {  &quot;preinstall&quot;: &quot;xxx.js&quot;,  &quot;install&quot;: &quot;xxx.js&quot;,  &quot;uninstall&quot;: &quot;xxx.js&quot;,  &quot;test&quot;: &quot;xxx.js&quot;}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/正则</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><ol><li>使用一个正则表达式字面量<pre><code class="js">const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi;</code></pre></li><li>调用RegExp对象的构造函数<pre><code class="js">const regex = new RegExp(pattern, [, flags])</code></pre></li></ol><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><ul><li>^ 匹配输入的开始</li><li>$ 匹配输入的结束</li><li>* 0次或多次  {0，} </li><li>+ 1次或多次  {1，}</li><li>? <ul><li>0次或者1次 {0,1}。</li><li>用于先行断言</li><li>如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪<ul><li>对 “123abc” 用 /\d+/ 将会返回 “123”，</li><li>用 /\d+?/,那么就只会匹配到 “1”。</li></ul></li></ul></li><li>. 匹配除换行符之外的任何单个字符</li><li>(x)  匹配 ‘x’ 并且记住匹配项</li><li>(?:x)  匹配 ‘x’ 但是不记住匹配项</li><li>x(?=y)  配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。</li><li>x(?!y)  匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。</li><li>x|y  匹配‘x’或者‘y’。</li><li>{n}  重复n次</li><li>{n, m}  匹配至少n次，最多m次</li><li>[xyz]   代表 x 或 y 或 z</li><li>[^xyz]  不是 x 或 y 或 z</li><li>\d  数字</li><li>\D  非数字</li><li>\s  空白字符，包括空格、制表符、换页符和换行符。</li><li>\S  非空白字符</li><li>\w  单词字符（字母、数字或者下划线）  [A-Za-z0-9_]</li><li>\W  非单字字符。[^A-Za-z0-9_]</li><li>\3  表示第三个分组</li><li>\b   词的边界<ul><li>/\bm/匹配“moon”中得‘m’；</li></ul></li><li>\B   非单词边界</li></ul><h3 id="使用正则表达式的方法"><a href="#使用正则表达式的方法" class="headerlink" title="使用正则表达式的方法"></a>使用正则表达式的方法</h3><ul><li>exec    一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。</li><li>test    一个在字符串中测试是否匹配的RegExp方法，它返回true或false。</li><li>match    一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。</li><li>search    一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</li><li>replace    一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</li><li>split    一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>匹配结尾的数字</p><pre><code class="js">/\d+$/g</code></pre><p>统一空格个数<br>字符串内如有空格，但是空格的数量可能不一致，通过正则将空格的个数统一变为一个。</p><pre><code class="js">let reg = /\s+/gstr.replace(reg, &quot; &quot;);</code></pre><p>判断字符串是不是由数字组成</p><pre><code class="js">str.test(/^\d+$/);</code></pre><p>电话号码正则</p><ul><li>区号必填为3-4位的数字</li><li>区号之后用“-”与电话号码连接电话号码为7-8位的数字</li><li>分机号码为3-4位的数字，非必填，但若填写则以“-”与电话号码相连接<pre><code class="js">/^\d{3,4}-\d{7,8}(-\d{3,4})?$/</code></pre></li></ul><p>手机号码正则表达式<br>正则验证手机号，忽略前面的0，支持130-139，150-159。忽略前面0之后判断它是11位的。</p><pre><code class="js">/^0*1(3|5)\d{9}$/</code></pre><p>使用正则表达式实现删除字符串中的空格</p><pre><code class="js">funtion trim(str) {  let reg = /^\s+|\s+$/g  return str.replace(reg, &#39;&#39;);}</code></pre><p>限制文本框只能输入数字和两位小数点等等</p><pre><code class="js">/^\d*\.\d{0,2}$/</code></pre><p>只能输入小写的英文字母和小数点，和冒号，正反斜杠(：./)</p><pre><code class="js">/^[a-z\.:\/\\]*$/</code></pre><p>替换小数点前内容为指定内容<br>例如：infomarket.php?id=197 替换为 test.php?id=197</p><pre><code class="js">var reg = /^[^\.]+/;var target = &#39;---------&#39;;str = str.replace(reg, target)</code></pre><p>只匹配中文的正则表达式</p><pre><code class="js">/[\u4E00-\u9FA5\uf900-\ufa2d]/ig</code></pre><p>返回字符串的中文字符个数<br>先去掉非中文字符，再返回length属性。</p><pre><code class="js">function cLength(str){  var reg = /[^\u4E00-\u9FA5\uf900-\ufa2d]/g;  //匹配非中文的正则表达式  var temp = str.replace(reg,&#39;&#39;);  return temp.length;}</code></pre><p>正则表达式取得匹配IP地址前三段<br>只要匹配掉最后一段并且替换为空字符串就行了</p><pre><code class="js">function getPreThrstr(str) {  let reg = /\.\d{1,3}$/;  return str.replace(reg,&#39;&#39;);}</code></pre><p>匹配<ul>与</ul>之间的内容</p><pre><code class="js">/&lt;ul&gt;[\s\S]+?&lt;/ul&gt;/i</code></pre><p>用正则表达式获得文件名<br>c:\images\tupian\006.jpg<br>可能是直接在盘符根目录下，也可能在好几层目录下，要求替换到只剩文件名。<br>首先匹配非左右斜线字符0或多个，然后是左右斜线一个或者多个。</p><pre><code class="js">function getFileName(str){  var reg = /[^\\\/]*[\\\/]+/g;  // xxx\ 或是 xxx/  str = str.replace(reg,&#39;&#39;);  return str;}</code></pre><p>绝对路径变相对路径<br>“<a href="http://23.123.22.12/image/somepic.gif&quot;转换为：&quot;/image/somepic.gif&quot;" target="_blank" rel="noopener">http://23.123.22.12/image/somepic.gif&quot;转换为：&quot;/image/somepic.gif&quot;</a></p><pre><code class="js">var reg = /http:\/\/[^\/]+/;str = str.replace(reg,&quot;&quot;);</code></pre><p>用户名正则<br>用于用户名注册，，用户名只 能用 中文、英文、数字、下划线、4-16个字符。</p><pre><code class="js">/^[\u4E00-\u9FA5\uf900-\ufa2d\w]{4,16}$/</code></pre><p>匹配英文地址<br>规则如下:<br>包含 “点”, “字母”,”空格”,”逗号”,”数字”，但开头和结尾不能是除字母外任何字符。</p><pre><code class="js">/^[a-zA-Z][\.a-zA-Z,0-9]*[a-zA-Z]$/</code></pre><p>正则匹配价格<br>开头数字若干位，可能有一个小数点，小数点后面可以有两位数字。</p><pre><code class="js">/^\d+(\.\d{2})?$/</code></pre><p>身份证号码的匹配<br>身份证号码可以是15位或者是18位，其中最后一位可以是X。其它全是数字</p><pre><code class="js">/^(\d{14}|\d{17})(X|x)$/</code></pre><p>单词首字母大写<br>每单词首字大写，其他小写。如blue idea转换为Blue Idea，BLUE IDEA也转换为Blue Idea</p><pre><code class="js">function firstCharUpper(str) {  str = str.toLowerCase();  let reg = /\b(\w)/g;  return str.replace(reg, m =&gt; m.toUpperCase());}</code></pre><p>正则验证日期格式<br>yyyy-mm-dd格式<br>4位数字，横线，1或者2位数字，再横线，最后又是1或者2位数字。</p><pre><code class="js">/^\d{4}-\d{1,2}-\d{1,2}$/</code></pre><p>去掉文件的后缀名<br><a href="http://www.abc.com/dc/fda.asp" target="_blank" rel="noopener">www.abc.com/dc/fda.asp</a> 变为 <a href="http://www.abc.com/dc/fda" target="_blank" rel="noopener">www.abc.com/dc/fda</a></p><pre><code class="js">function removeExp(str) {  return str.replace(/\.\w$/,&#39;&#39;)}</code></pre><p>验证邮箱的正则表达式<br>开始必须是一个或者多个单词字符或者是-，加上@，然后又是一个或者多个单词字符或者是-。然后是点“.”和单词字符和-的组合，可以有一个或者<br>多个组合。</p><pre><code class="js">/^[\w-]+@\w+\.\w+$/</code></pre><p>正则判断标签是否闭合<br>例如：&lt;img xxx=”xxx” 就是没有闭合的标签；</p><p>p的内容，同样也是没闭合的标签。<p>标签可能有两种方式闭合，<img xxx=”xxx” /> 或者是<p> xxx </p>。</p><pre><code class="js">/&lt;([a-z]+)(\s*\w*?\s*=\s*&quot;.+?&quot;)*(\s*?&gt;[\s\S]*?(&lt;\/\1&gt;)+|\s*\/&gt;)/i</code></pre><p>正则判断是否为数字与字母的混合<br>不能小于12位，且必须为字母和数字的混</p><pre><code class="js">/^(([a-z]+[0-9]+)|([0-9]+[a-z]+))[a-z0-9]*$/i</code></pre><p>将阿拉伯数字替换为中文大写形式</p><pre><code class="js">function replaceReg(reg,str){  let arr=[&quot;零&quot;,&quot;壹&quot;,&quot;贰&quot;,&quot;叁&quot;,&quot;肆&quot;,&quot;伍&quot;,&quot;陆&quot;,&quot;柒&quot;,&quot;捌&quot;,&quot;玖&quot;];  let reg = /\d/g;  return str.replace(reg,function(m){return arr[m];})}</code></pre><p>去掉标签的所有属性</p><td style="width: 23px; height: 26px;" align="left">***</td>变成没有任何属性的<td>***</td>思路：非捕获匹配属性，捕获匹配标签，使用捕获结果替换掉字符串。正则如下：```js/(<td)\s(?:\s*\w*?\s*=\s*".+?")*?\s*?(>)/```]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/垃圾回收与内存泄露和优化</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000019584487" target="_blank" rel="noopener">【V8引擎】浅析Chrome V8引擎中的垃圾回收机制和内存泄露优化策略</a></p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h3 id="如何判断回收内容"><a href="#如何判断回收内容" class="headerlink" title="如何判断回收内容"></a>如何判断回收内容</h3><p>如何确定哪些内存需要回收，哪些内存不需要回收，这是垃圾回收期需要解决的最基本问题。我们可以这样假定，<strong>一个对象为活对象当且仅当它被一个根对象 或另一个活对象指向</strong>。根对象永远是活对象，它是被浏览器或V8所引用的对象。被局部变量所指向的对象也属于根对象，因为它们所在的作用域对象被视为根对 象。全局对象（Node中为global，浏览器中为window）自然是根对象。浏览器中的DOM元素也属于根对象。</p><h3 id="V8-回收策略"><a href="#V8-回收策略" class="headerlink" title="V8 回收策略"></a>V8 回收策略</h3><p>新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用 不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）。</p><h3 id="新生代算法"><a href="#新生代算法" class="headerlink" title="新生代算法"></a>新生代算法</h3><p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。<br><img src="../img/gc-new.png" srcset="/img/loading.gif" alt=""></p><h3 id="老生代算法"><a href="#老生代算法" class="headerlink" title="老生代算法"></a>老生代算法</h3><p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p><p>在讲算法前，先来说下什么情况下对象会出现在老生代空间中：</p><ol><li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li><li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li></ol><h2 id="内存泄露和优化"><a href="#内存泄露和优化" class="headerlink" title="内存泄露和优化"></a>内存泄露和优化</h2><h3 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h3><p>存泄露是指程序中已分配的堆内存由于某种原因未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等后果。</p><h3 id="常见的内存泄露的场景"><a href="#常见的内存泄露的场景" class="headerlink" title="常见的内存泄露的场景"></a>常见的内存泄露的场景</h3><ul><li>缓存</li><li>作用域未释放（闭包）</li><li>没有必要的全局变量</li><li>无效的DOM引用</li><li>定时器未清除</li><li>事件监听为空白</li></ul><h3 id="内存泄露优化"><a href="#内存泄露优化" class="headerlink" title="内存泄露优化"></a>内存泄露优化</h3><ol><li>在业务不需要的用到的内部函数，可以重构到函数外，实现解除闭包。</li><li>避免创建过多的生命周期较长的对象，或者将对象分解成多个子对象。</li><li>避免过多使用闭包。</li><li>注意清除定时器和事件监听器。</li><li>nodejs中使用stream或buffer来操作大文件，不会受nodejs内存限制。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/变量类型和类型转换</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="JS-变量类型"><a href="#JS-变量类型" class="headerlink" title="JS 变量类型"></a>JS 变量类型</h3><p>JS中有 6 种原始值，分别是：</p><ol><li>boolean</li><li>number</li><li>string</li><li>undefined</li><li>symbol</li><li>null</li></ol><p>引用类型：</p><ol><li>对象</li><li>数组</li><li>函数</li></ol><h3 id="JS中使用typeof能得到哪些类型？"><a href="#JS中使用typeof能得到哪些类型？" class="headerlink" title="JS中使用typeof能得到哪些类型？"></a>JS中使用typeof能得到哪些类型？</h3><p>其中一个奇怪的 null，虽然是基本变量，但是因为设计的时候<code>null</code>是全0，而对象是<code>000</code>开头，所以有这个误判。</p><ol><li>boolean</li><li>number</li><li>string</li><li>undefined</li><li>symbol</li><li><strong>object</strong></li><li><strong>function</strong></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">bigint</a></li></ol><h3 id="instanceof-能正确判断对象的原理是什么？"><a href="#instanceof-能正确判断对象的原理是什么？" class="headerlink" title="instanceof 能正确判断对象的原理是什么？"></a>instanceof 能正确判断对象的原理是什么？</h3><p>判断一个对象与构造函数是否在一个原型链上</p><pre><code class="javascript">const Person = function() {}const p1 = new Person()p1 instanceof Person // truevar str = &#39;hello world&#39;str instanceof String // falsevar str1 = new String(&#39;hello world&#39;)str1 instanceof String // true</code></pre><h3 id="实现一个类型判断函数"><a href="#实现一个类型判断函数" class="headerlink" title="实现一个类型判断函数"></a>实现一个类型判断函数</h3><ol><li>判断null</li><li>判断基础类型</li><li>使用<code>Object.prototype.toString.call(target)</code>来判断<strong>引用类型</strong></li></ol><p>注意： 一定是使用<code>call</code>来调用，不然是判断的Object.prototype的类型<br>之所以要先判断是否为基本类型是因为：虽然<code>Object.prototype.toString.call()</code>能判断出某值是：number/string/boolean，但是其实在包装的时候是把他们先转成了对象然后再判断类型的。 但是JS中包装类型和原始类型还是有差别的，因为对一个包装类型来说，typeof的值是object</p><pre><code class="javascript">/** * 类型判断 */function getType(target) {  //先处理最特殊的Null  if(target === null) {    return &#39;null&#39;;  }  //判断是不是基础类型  const typeOfT = typeof target  if(typeOfT !== &#39;object&#39;) {    return typeOfT;  }  //肯定是引用类型了  const template = {    &quot;[object Object]&quot;: &quot;object&quot;,    &quot;[object Array]&quot; : &quot;array&quot;,    // 一些包装类型    &quot;[object String]&quot;: &quot;object - string&quot;,    &quot;[object Number]&quot;: &quot;object - number&quot;,    &quot;[object Boolean]&quot;: &quot;object - boolean&quot;  };  const typeStr = Object.prototype.toString.call(target);  return template[typeStr];}</code></pre><h3 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转Boolean</h3><p>以下都为假值，其他所有值都转为 true，包括所有对象（空对象，空数组也转为真）。</p><ul><li>false</li><li>undfined</li><li>null</li><li>‘’</li><li>NaN</li><li>0</li><li>-0</li></ul><h3 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h3><p>对象在转换基本类型时，会调用<code>valueOf</code>， 需要转成字符类型时调用<code>toString</code>。</p><pre><code class="javascript">var a = {  valueOf() {    return 0;  },  toString() {    return &#39;1&#39;;  }}1 + a           // 1&#39;1&#39;.concat(a)   //&quot;11&quot;</code></pre><p>也可以重写 <code>Symbol.toPrimitive</code> ，该方法在转基本类型时调用<strong>优先级最高</strong>。  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive" target="_blank" rel="noopener">Symbol.toPrimitive</a> 指将被调用的指定函数值的属性转换为相对应的原始值。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>运算中其中一方为字符串，那么就会把另一方也转换为字符串<br>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</p><pre><code class="javascript">1 + &#39;1&#39; // &#39;11&#39;true + true // 24 + [1,2,3] // &quot;41,2,3&quot;</code></pre><p>还需要注意这个表达式<code>&#39;a&#39; + + &#39;b&#39;</code></p><pre><code class="js">&#39;a&#39; + + &#39;b&#39; // -&gt; &quot;aNaN&quot;</code></pre><p>因为 + ‘b’ 等于 NaN，所以结果为 “aNaN”，你可能也会在一些代码中看到过 + ‘1’ 的形式来快速获取 number 类型。</p><p><a href="https://blog.csdn.net/qq_37746973/article/details/82491282" target="_blank" rel="noopener">JS类型转换规则总结</a></p><p><a href="https://blog.csdn.net/qq_37746973/article/details/81010057" target="_blank" rel="noopener">JS隐射类型转换</a></p><h3 id="100-问题"><a href="#100-问题" class="headerlink" title="100 + 问题"></a><code>100 +</code> 问题</h3><pre><code class="js">&#39;100&#39; + 100   // &quot;100100&quot;100 + &#39;100&#39;   // &quot;100100&quot;100 + true    // 101100 + false   // 100100 + undefined //NaN100 + null    // 100</code></pre><h3 id="“a-common-string”为什么会有length属性"><a href="#“a-common-string”为什么会有length属性" class="headerlink" title="“a common string”为什么会有length属性"></a>“a common string”为什么会有length属性</h3><p>通过字面量的方式创建：var a = ‘string’;，这时它就是基本类型值；通过构造函数的方式创建：var a = new String(‘string’);这时它是对象类型。</p><p>基本类型是没有属性和方法的，但仍然可以使用对象才有的属性方法。这时因为在对基本类型使用属性方法的时候，后台会隐式的创建这个基本类型的对象，之后再销毁这个对象</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a>== 操作符</h3><p>对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换</p><p>判断流程：</p><ol><li>首先会判断两者类型是否相同。相同的话就是比大小了</li><li>类型不相同的话，那么就会进行类型转换</li><li>会先判断是否在对比 null 和 undefined，是的话就会返回 true</li><li>判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number<pre><code class="js">1 == &#39;1&#39;   ↓1 ==  1</code></pre></li><li>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断<pre><code class="js">&#39;1&#39; == true     ↓&#39;1&#39; ==  1     ↓1  ==  1</code></pre></li><li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断<pre><code class="js">&#39;1&#39; == { a: &#39;b&#39; }     ↓&#39;1&#39; == &#39;[object Object]&#39;</code></pre></li><li>两边都是对象的话，那么只要不是同一对象的不同引用，都为false</li></ol><p>注意，只要出现NaN，就一定是false，因为就连NaN自己都不等于NaN<br>对于NaN，判断的方法是使用全局函数 <code>isNaN()</code></p><h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title="=== 操作符"></a>=== 操作符</h3><p>不转类型，直接判断类型和值是否相同。<br>但是 NaN === NaN 还是false</p><h3 id="等于true还是false"><a href="#等于true还是false" class="headerlink" title="{} 等于true还是false"></a>{} 等于true还是false</h3><pre><code class="js">var a = {};a == true // -&gt; ?a == false // -&gt; ?</code></pre><p>答案是两个都为false<br>因为 a.toString() -&gt; ‘[object Object]’ -&gt; NaN</p><h3 id="1-与-Number-1-有什么区别"><a href="#1-与-Number-1-有什么区别" class="headerlink" title="1 与 Number(1)有什么区别"></a>1 与 Number(1)有什么区别</h3><pre><code class="js">var a = Number(1) // 1var b = new Number(1)  // Number {[[PrimitiveValue]]: 1}typeof (a) // numbertypeof (b) // objecta == b // true</code></pre><ul><li>var a = 1 是一个常量，而 Number(1)是一个函数</li><li>new Number(1)返回的是一个对象</li><li>a==b 为 true 是因为所以在求值过程中，总是会强制转为原始数据类型而非对象，例如下面的代码:</li></ul><pre><code class="js">typeof 123 // &quot;number&quot;typeof new Number(123) // &quot;object&quot;123 instanceof Number // false(new Number(123)) instanceof Number // true123 === new Number(123) // false</code></pre><h3 id="console-log-new-Boolean-false-输出什么-易混淆"><a href="#console-log-new-Boolean-false-输出什么-易混淆" class="headerlink" title="console.log(!!(new Boolean(false))输出什么 [易混淆]"></a>console.log(!!(new Boolean(false))输出什么 [易混淆]</h3><p>true<br>布尔的包装对象 Boolean 的对象实例，对象只有在 null 与 undefined 时，才会认定为布尔的 false 值，布尔包装对象本身是个对象，对象-&gt;布尔 都是 true，所以 new Boolean(false)其实是布尔的 true，看下面这段代码:</p><pre><code class="js">if(new Boolean(false)){    alert(&#39;true!!&#39;);}</code></pre><p>只有使用了 valueOf 后才是真正的转换布尔值，与上面包装对象与原始资料转换说明的相同:</p><pre><code class="js">!!(new Boolean(false))  //true(new Boolean(false)).valueOf() //false</code></pre><h3 id="如何判断一个数据是不是Array"><a href="#如何判断一个数据是不是Array" class="headerlink" title="如何判断一个数据是不是Array"></a>如何判断一个数据是不是Array</h3><ul><li><code>Array.isArray(obj)</code><ul><li>ECMAScript 5种的函数，当使用ie8的时候就会出现问题。</li></ul></li><li><code>obj instanceof Array</code><ul><li>当用来检测在不同的window或iframe里构造的数组时会失败。这是因为每一个iframe都有它自己的执行环境，彼此之间并不共享原型链，所以此时的判断一个对象是否为数组就会失败。此时我们有一个更好的方式去判断一个对象是否为数组。</li></ul></li><li><code>Object.prototype.toString.call(obj) == &#39;[object Array]&#39;</code><ul><li>这个方法比较靠谱</li></ul></li><li><code>obj.constructor === Array</code><ul><li>constructor属性返回对创建此对象的函数的引用</li></ul></li></ul><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>如果是原始类型，他会将原始类型包装为引用类型，然后调用对应方法</p><pre><code class="js">function dd(){}var toString = Object.prototype.toString;toString.call(dd);          //[object Function]toString.call(new Object);  //[object Object]toString.call(new Array);   //[object Array]toString.call(new Date);    //[object Date]toString.call(new String);  //[object String]toString.call(Math);        //[object Math]toString.call(undefined);   //[object Undefined]toString.call(null);        //[object Null]toString.call(123)          //[object Number]toString.call(&#39;abc&#39;)        //[object String]</code></pre><h3 id="obj-toString-和Object-prototype-toString-call-obj"><a href="#obj-toString-和Object-prototype-toString-call-obj" class="headerlink" title="obj.toString() 和Object.prototype.toString.call(obj)"></a>obj.toString() 和Object.prototype.toString.call(obj)</h3><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为toString为Object的原型方法，而Array ，function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…..），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。</p><h3 id="输出以下代码运行结果"><a href="#输出以下代码运行结果" class="headerlink" title="输出以下代码运行结果"></a>输出以下代码运行结果</h3><pre><code class="JS">1 + &quot;1&quot;2 * &quot;2&quot;[1, 2] + [2, 1]&quot;a&quot; + + &quot;b&quot;</code></pre><ul><li>1 + “1”<ul><li>加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来</li><li>所以值为：“11”</li></ul></li><li>2 * “2”<ul><li>乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值</li></ul></li><li>[1, 2] + [2, 1]<ul><li>Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。</li><li>所以两个数组对象的toString方法相加，值为：”1,22,1”</li></ul></li><li>“a” + + “b”<ul><li>后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。</li><li>所以值为：”aNaN”</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/原型链与继承</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h3><ul><li>字面量创建</li><li>构造函数创建</li><li>Object.create()</li></ul><pre><code class="js">var o1 = {name: &#39;value&#39;};var o2 = new Object({name: &#39;value&#39;});var M = function() {this.name = &#39;o3&#39;};var o3 = new M();var P = {name: &#39;o4&#39;};var o4 = Object.create(P)</code></pre><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li>JavaScript 的所有对象中都包含了一个 <code>__proto__</code> 内部属性，这个属性所对应的就是该对象的原型<ul><li>JavaScript 的函数对象，除了原型 <code>__proto__</code> 之外，还预置了 prototype 属性</li><li>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 <code>__proto__</code>。</li></ul></li></ul><p><img src="../img/prototype.png" srcset="/img/loading.gif" alt="原型"></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>任何一个实例对象通过原型链可以找到它对应的原型对象，原型对象上面的实例和方法都是实例所共享的。</p><p>一个对象在查找以一个方法或属性时，他会先在自己的对象上去找，找不到时，他会沿着原型链依次向上查找。</p><p>注意： 函数才有prototype，实例对象只有有<strong>proto</strong>， 而函数有的<strong>proto</strong>是因为函数是Function的实例对象</p><h3 id="instanceof原理"><a href="#instanceof原理" class="headerlink" title="instanceof原理"></a>instanceof原理</h3><p>判断实例对象的<strong>proto</strong>属性与构造函数的prototype是不是用一个引用。如果不是，他会沿着对象的<strong>proto</strong>向上查找的，直到顶端Object。</p><h3 id="判断对象是哪个类的直接实例"><a href="#判断对象是哪个类的直接实例" class="headerlink" title="判断对象是哪个类的直接实例"></a>判断对象是哪个类的直接实例</h3><p>使用<code>对象.construcor</code>直接可判断</p><h3 id="构造函数，new时发生了什么？"><a href="#构造函数，new时发生了什么？" class="headerlink" title="构造函数，new时发生了什么？"></a>构造函数，new时发生了什么？</h3><pre><code class="javascript">   var obj  = {};    obj.__proto__ = Base.prototype;   Base.call(obj);  </code></pre><ol><li>创建一个新的对象 obj;</li><li>将这个空对象的<strong>proto</strong>成员指向了Base函数对象prototype成员对象</li><li>Base函数对象的this指针替换成obj, 相当于执行了Base.call(obj);</li><li>如果构造函数显示的返回一个对象，那么则这个实例为这个返回的对象。 否则返回这个新创建的对象</li></ol><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类的声明</p><pre><code class="js">// 普通写法function Animal() {  this.name = &#39;name&#39;}// ES6class Animal2 {  constructor () {    this.name = &#39;name&#39;;  }}</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="借用构造函数法"><a href="#借用构造函数法" class="headerlink" title="借用构造函数法"></a>借用构造函数法</h3><p>在构造函数中 使用<code>Parent.call(this)</code>的方法继承父类属性。</p><p>原理： 将子类的this使用父类的构造函数跑一遍 </p><p>缺点： Parent原型链上的属性和方法并不会被子类继承</p><pre><code class="js">function Parent() {  this.name = &#39;parent&#39;}function Child() {  Parent.call(this);  this.type = &#39;child&#39;}</code></pre><h3 id="原型链实现继承"><a href="#原型链实现继承" class="headerlink" title="原型链实现继承"></a>原型链实现继承</h3><p>原理：把子类的prototype（原型对象）直接设置为父类的实例</p><p>缺点：因为子类只进行一次原型更改，所以子类的所有实例保存的是同一个父类的值。<br>当子类对象上进行值修改时，如果是修改的原始类型的值，那么会在实例上新建这样一个值；<br>但如果是引用类型的话，他就会去修改子类上唯一一个父类实例里面的这个引用类型，这会影响所有子类实例</p><pre><code class="js">function Parent() {  this.name = &#39;parent&#39;  this.arr = [1,2,3]}function Child() {  this.type = &#39;child&#39;}Child.prototype = new Parent();var c1 = new Child();var c2 = new Child();c1.__proto__ === c2.__proto__</code></pre><h3 id="组合继承方式"><a href="#组合继承方式" class="headerlink" title="组合继承方式"></a>组合继承方式</h3><p>组合构造函数中使用call继承和原型链继承。</p><p>原理： 子类构造函数中使用<code>Parent.call(this);</code>的方式可以继承写在父类构造函数中this上绑定的各属性和方法；<br>使用<code>Child.prototype = new Parent()</code>的方式可以继承挂在在父类原型上的各属性和方法</p><p>缺点：  父类构造函数在子类构造函数中执行了一次，在子类绑定原型时又执行了一次</p><pre><code class="js">function Parent() {  this.name = &#39;parent&#39;  this.arr = [1,2,3]}function Child() {  Parent.call(this);  this.type = &#39;child&#39;}Child.prototype = new Parent();</code></pre><h3 id="组合继承方式-优化1："><a href="#组合继承方式-优化1：" class="headerlink" title="组合继承方式 优化1："></a>组合继承方式 优化1：</h3><p>因为这时父类构造函数的方法已经被执行过了，只需要关心原型链上的属性和方法了</p><pre><code class="js">Child.prototype = Parent.prototype;</code></pre><p>缺点：</p><ul><li>因为原型上有一个属性为<code>constructor</code>，此时直接使用父类的prototype的话那么会导致 实例的constructor为Parent，即不能区分这个实例对象是Child的实例还是父类的实例对象。</li><li>子类不可直接在prototype上添加属性和方法，因为会影响父类的原型</li></ul><p>注意：这个时候instanseof是可以判断出实例为Child的实例的，因为instanceof的原理是沿着对象的<strong>proto</strong>判断是否有一个原型是等于该构造函数的原型的。这里把Child的原型直接设置为了父类的原型，那么: 实例.<strong>proto</strong> === Child.prototype === Child.prototype</p><h3 id="组合继承方式-优化2-添加中间对象【最通用版本】："><a href="#组合继承方式-优化2-添加中间对象【最通用版本】：" class="headerlink" title="组合继承方式 优化2 - 添加中间对象【最通用版本】："></a>组合继承方式 优化2 - 添加中间对象【最通用版本】：</h3><pre><code class="js">function Parent() {  this.name = &#39;parent&#39;  this.arr = [1,2,3]}function Child() {  Parent.call(this);  this.type = &#39;child&#39;}Child.prototype = Object.create(Parent.prototype); //提供__proto__Child.prototype.constrctor = Child;</code></pre><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong></p><h3 id="封装一个原生的继承方法"><a href="#封装一个原生的继承方法" class="headerlink" title="封装一个原生的继承方法"></a>封装一个原生的继承方法</h3><pre><code class="js">/** * 继承 * @param Parent * @param Child */function extendsClass(Parent, Child) {  function F() {}  F.prototype = Parent.prototype  Child.prototype = new F()  Child.prototype.constrctor = Child  return Child}</code></pre><h3 id="ES5-ES6-的继承除了写法以外还有什么区别？"><a href="#ES5-ES6-的继承除了写法以外还有什么区别？" class="headerlink" title="ES5/ES6 的继承除了写法以外还有什么区别？"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20" target="_blank" rel="noopener">ES5/ES6 的继承除了写法以外还有什么区别？</a></h3><ul><li>class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。</li><li>class 声明内部会启用严格模式。</li><li>class 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li><li>class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。</li><li>必须使用 new 调用 class。</li><li>class 内部无法重写类名。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/函数</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="JS运行分三步："><a href="#JS运行分三步：" class="headerlink" title="JS运行分三步："></a>JS运行分三步：</h3><p>语法分析（通篇扫描是否有语法错误），预编译（发生在函数执行的前一刻），解释执行（一行行执行）。</p><h3 id="预编译执行分五步："><a href="#预编译执行分五步：" class="headerlink" title="预编译执行分五步："></a>预编译执行分五步：</h3><p>一、创建AO对象（Activation Object  执行期上下文）</p><p>二、找形参和变量声明，将变量和形参名作为AO属性名，值为undefined.<br>    变量声明提升（变量放到后面也不会报错，只是未定义类型）如：console.log(a);var a=10;结果undenfined;</p><p>三、将实参值和形参统一（传参）</p><p>四、在函数体里面找到函数声明{函数声明整体提升（相当于放到程序最前面）}</p><p>五、值赋予函数体，执行（声明函数和变量的部分直接不看了）</p><h3 id="函数作用域-scope"><a href="#函数作用域-scope" class="headerlink" title="函数作用域[[scope]]"></a>函数作用域[[scope]]</h3><p>每个javascript函数都是一个对象，对象中有的属性可以访问，有的不能，这些属性仅供javascript引擎存取，如[[scope]]。</p><p>[[scope]]就是函数的作用域，其中存储了执行期上下文的集合。</p><p><strong>执行期上下文</strong>： 当函数执行时，会创建一个称为执行期上下文的内部对象（AO）。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行上下文被销毁。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p><code>[[scope]]</code>中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们称这种链式链接为作用域链。查找变量时，要从作用域链的顶部开始查找。Activation Object（AO）到Global Object（GO）。</p><p><img src="../img/function.png" srcset="/img/loading.gif" alt="function"><br><img src="../img/define.png" srcset="/img/loading.gif" alt="a定义"><br><img src="../img/run.png" srcset="/img/loading.gif" alt="a run"><br><img src="../img/bdefine.png" srcset="/img/loading.gif" alt="b define"><br><img src="../img/brun.png" srcset="/img/loading.gif" alt="b run"></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>当内部函数被保存到外部时，将会生成闭包。生成闭包后，内部函数依旧可以访问其所在的外部函数的变量。</p><p>闭包问题的解决方法：立即执行函数、let</p><p>详细解释：</p><p>当函数执行时，会创建一个称为<strong>执行期上下文的内部对象（AO）</strong>，执行期上下文定义了一个函数执行时的环境。</p><p>函数还会获得它所在作用域的<strong>作用域链</strong>，是存储函数能够访问的所有执行期上下文对象的集合，即这个函数中能够访问到的东西都是沿着作用域链向上查找直到全局作用域。</p><p>函数每次执行时对应的执行期上下文都是独一无二的，当函数执行完毕，函数都会失去对这个作用域链的引用，JS的垃圾回收机制是采用引用计数策略，如果一块内存不再被引用了那么这块内存就会被释放。</p><p>但是，当闭包存在时，即内部函数保留了对外部变量的引用时，这个作用域链就不会被销毁，此时内部函数依旧可以访问其所在的外部函数的变量，这就是闭包。</p><p>先看两个例子，两个例子都打印5个5</p><pre><code class="js">for (var i = 0; i &lt; 5; i++) {  setTimeout(function timer() {    console.log(i)  }, i * 100)}</code></pre><pre><code class="js">function test() {   var a = [];   for (var i = 0; i &lt; 5; i++) {         a[i] = function () {            console.log(i);         }   }   return a;}var myArr = test();for(var j=0;j&lt;5;j++){   myArr[j]();}</code></pre><p>解决方法： 使用立即执行函数</p><pre><code class="js">for (var i = 0; i &lt; 5; i++) {   ;(function(i) {      setTimeout(function timer() {         console.log(i)      }, i * 100)   })(i)}</code></pre><pre><code class="js">function test(){   var arr=[];   for(i=0;i&lt;10;i++)   {      (function(j){         arr[j]=function(){         console.log(j);         }      })(i)   }   return arr;}var myArr=test();for(j=0;j&lt;10;j++){   myArr[j]();}</code></pre><h3 id="闭包-封装私有变量"><a href="#闭包-封装私有变量" class="headerlink" title="闭包-封装私有变量"></a>闭包-封装私有变量</h3><pre><code class="js">function Counter() {   let count = 0;   this.plus = function () {      return ++count;   }   this.minus = function () {      return --count;   }   this.getCount = function () {      return count;   }}const counter = new Counter();counter.puls();counter.puls();console.log(counter.getCount())</code></pre><h3 id="作用域与变量声明提升"><a href="#作用域与变量声明提升" class="headerlink" title="作用域与变量声明提升"></a>作用域与变量声明提升</h3><ul><li>在 JavaScript 中，函数声明与变量声明会被 JavaScript 引擎隐式地提升到当前作用域的顶部 </li><li>声明语句中的赋值部分并不会被提升，只有名称被提升</li><li>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</li><li>如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数</li></ul><h3 id="构造函数，new时发生了什么？"><a href="#构造函数，new时发生了什么？" class="headerlink" title="构造函数，new时发生了什么？"></a>构造函数，new时发生了什么？</h3><pre><code class="javascript">   var obj  = {};    obj.__proto__ = Base.prototype;   Base.call(obj);  </code></pre><ol><li>创建一个新的对象 obj;</li><li>将这个空对象的<strong>proto</strong>成员指向了Base函数对象prototype成员对象</li><li>Base函数对象的this指针替换成obj, 相当于执行了Base.call(obj);</li><li>如果构造函数显示的返回一个对象，那么则这个实例为这个返回的对象。 否则返回这个新创建的对象</li></ol><h3 id="函数参数是对象会发生什么问题？"><a href="#函数参数是对象会发生什么问题？" class="headerlink" title="函数参数是对象会发生什么问题？"></a>函数参数是对象会发生什么问题？</h3><pre><code class="javascript">function test(person) {  person.age = 26  person = {    name: &#39;yyy&#39;,    age: 30  }  return person}const p1 = {  name: &#39;hy&#39;,  age: 25}const p2 = test(p1)console.log(p1) // -&gt; {name: &quot;hy&quot;, age: 26}console.log(p2) // -&gt; {name: &quot;yyy&quot;, age: 30}</code></pre><p><code>person = {}</code> 这一步操作就将应用与原来的分离了<br><img src="../img/addressChange.png" srcset="/img/loading.gif" alt="地址改变"></p><h3 id="JavaScript-中，调用函数有哪几种方式？"><a href="#JavaScript-中，调用函数有哪几种方式？" class="headerlink" title="JavaScript 中，调用函数有哪几种方式？"></a>JavaScript 中，调用函数有哪几种方式？</h3><ul><li>方法调用模式 Foo.foo(arg1, arg2);</li><li>函数调用模式 foo(arg1, arg2);</li><li>构造器调用模式 (new Foo())(arg1, arg2);</li><li>call/apply 调用模式 Foo.foo.call(that, arg1, arg2);</li><li>bind 调用模式 Foo.foo.bind(that)(arg1, arg2)();</li></ul><h3 id="如何实现一个new"><a href="#如何实现一个new" class="headerlink" title="如何实现一个new?"></a>如何实现一个new?</h3><pre><code class="js">function _new(func, ...args) {   let obj = Object.create(func.prototype)      // 原型   let res = func.apply(obj, args);             // 初始化对象属性   return (res instanceof Object) ? res : obj;  // 返回值}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/其他题目</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96%E9%A2%98%E7%9B%AE/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="用Array的reduce方法实现map方法（头条一面）"><a href="#用Array的reduce方法实现map方法（头条一面）" class="headerlink" title="用Array的reduce方法实现map方法（头条一面）"></a>用Array的reduce方法实现map方法（头条一面）</h3><h3 id="求一个字符串的字节长度"><a href="#求一个字符串的字节长度" class="headerlink" title="求一个字符串的字节长度"></a>求一个字符串的字节长度</h3><p>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</p><pre><code class="js">function GetBytes(str){  var len = str.length;  var bytes = len;  for(var i=0; i&lt;len; i++){    if (str.charCodeAt(i) &gt; 255) bytes++;  }  return bytes;}alert(GetBytes(&quot;你好,as&quot;));</code></pre><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><p>数组扁平化是指将一个多维数组变为一维数组</p><pre><code class="js">[1, [2, 3, [4, 5]]]  ------&gt;    [1, 2, 3, 4, 5]</code></pre><p>递归法：</p><pre><code class="js">function flatten(arr) {  let res = [];  arr.map(item =&gt; {    if(Array.isArray(item)) {      res = res.concat(flatten(item))    } else {      res.push(item);    }  })  return res;}</code></pre><h3 id="手写原生-ajax"><a href="#手写原生-ajax" class="headerlink" title="手写原生 ajax"></a>手写原生 ajax</h3><p>简单GET请求</p><pre><code class="js">function ajax(url, cb) {  let xhr;  if(window.XMLHttpRequest) {    xhr = new XMLHttpRequest();  } else {    xhr = ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);  }  xhr.onreadystatechange = function() {    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) {      cb(xhr.responseText);    }   }  xhr.open(&#39;GET&#39;, url, true);  xhr.send();}</code></pre><p>POST请求则需要设置<code>RequestHeader</code>告诉后台传递内容的编码方式以及在send方法里传入对应的值</p><pre><code class="js">xhr.open(&quot;POST&quot;, url, true);xhr.setRequestHeader(&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;);xhr.send(&quot;key1=value1&amp;key2=value2&quot;);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/全局内置对象</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h3 id="JS中有那些内置对象"><a href="#JS中有那些内置对象" class="headerlink" title="JS中有那些内置对象"></a>JS中有那些内置对象</h3><ul><li>数据封装类对象 <ul><li>String、Array、Object、Boolean、Number</li></ul></li><li>其他对象<ul><li>Math、Date、RegExp、Error、Function、Arguments</li></ul></li><li>ES6 新增对象<ul><li>Promise、Map、Set、Symbol、Proxy、Reflect</li></ul></li></ul><h3 id="数组Array对象常用方法"><a href="#数组Array对象常用方法" class="headerlink" title="数组Array对象常用方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B" target="_blank" rel="noopener">数组Array对象常用方法</a></h3><p>修改器方法<br>下面的这些方法会<strong>改变调用它们的对象自身的值</strong>：</p><ul><li><p>Array.prototype.pop()</p><ul><li>删除数组的最后一个元素，并返回这个元素。</li></ul></li><li><p>Array.prototype.push()</p><ul><li>在数组的末尾增加一个或多个元素，并返回数组的新长度。</li></ul></li><li><p>Array.prototype.shift()</p><ul><li>删除数组的第一个元素，并返回这个元素。</li></ul></li><li><p>Array.prototype.unshift()</p><ul><li>在数组的开头增加一个或多个元素，并返回数组的新长度。</li></ul></li><li><p>Array.prototype.splice()</p><ul><li>在任意的位置给数组添加或删除任意个元素。</li></ul></li><li><p>Array.prototype.reverse()</p><ul><li>颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。</li></ul></li><li><p>Array.prototype.sort()</p><ul><li>对数组元素进行排序，并返回当前数组。</li></ul></li><li><p>Array.prototype.fill() </p><ul><li>将数组中指定区间的所有元素的值，都替换成某个固定的值。</li></ul></li><li><p>Array.prototype.copyWithin() </p><ul><li>在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。</li></ul></li></ul><p>访问方法<br>下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。</p><ul><li><p>Array.prototype.join()</p><ul><li>连接所有数组元素组成一个字符串。</li></ul></li><li><p>Array.prototype.slice()</p><ul><li>抽取当前数组中的一段元素组合成一个新数组。</li></ul></li><li><p>Array.prototype.concat()</p><ul><li>返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。</li></ul></li><li><p>Array.prototype.includes() </p><ul><li>判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。</li></ul></li><li><p>Array.prototype.indexOf()</p><ul><li>返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。</li></ul></li><li><p>Array.prototype.lastIndexOf()</p><ul><li>返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。</li></ul></li><li><p>Array.prototype.toSource() </p><ul><li>返回一个表示当前数组字面量的字符串。遮蔽了原型链上的 Object.prototype.toSource() 方法。</li></ul></li><li><p>Array.prototype.toString()</p><ul><li>返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。</li></ul></li><li><p>Array.prototype.toLocaleString()</p><ul><li>返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 Object.prototype.toLocaleString() 方法。</li></ul></li></ul><p>迭代方法</p><p>在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的length属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。</p><ul><li><p>Array.prototype.forEach()</p><ul><li>为数组中的每个元素执行一次回调函数。</li></ul></li><li><p>Array.prototype.map()</p><ul><li>返回一个由回调函数的返回值组成的新数组。</li></ul></li><li><p>Array.prototype.reduce()</p><ul><li>从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。</li></ul></li><li><p>Array.prototype.filter()</p><ul><li>将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。</li></ul></li><li><p>Array.prototype.every()</p><ul><li>如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。</li></ul></li><li><p>Array.prototype.some()</p><ul><li>如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。</li></ul></li><li><p>Array.prototype.find() </p><ul><li>找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。</li></ul></li><li><p>Array.prototype.findIndex() </p><ul><li>找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。</li></ul></li><li><p>Array.prototype.keys() </p><ul><li>返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。</li></ul></li><li><p>Array.prototype.entries() </p><ul><li>返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。</li></ul></li></ul><h3 id="字符串常用API"><a href="#字符串常用API" class="headerlink" title="### 字符串常用API"></a>### <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="noopener">字符串常用API</a></h3><ul><li><p>String.prototype.split()</p><ul><li>通过分离字符串成字串，将字符串对象分割成字符串数组。</li></ul></li><li><p>String.prototype.slice(start, end)</p><ul><li>摘取一个字符串区域，返回一个新的字符串。</li></ul></li><li><p>String.prototype.substr(start, len)</p><ul><li>通过指定字符数返回在指定位置开始的字符串中的字符。</li></ul></li><li><p>String.prototype.substring()</p><ul><li>返回在字符串中指定两个下标之间的字符。</li></ul></li><li><p>String.prototype.trim()</p><ul><li>从字符串的开始和结尾去除空格</li></ul></li><li><p>String.prototype.concat()</p><ul><li>连接两个字符串文本，并返回一个新的字符串。</li></ul></li><li><p>String.prototype.match()</p><ul><li>使用正则表达式与字符串相比较。</li></ul></li><li><p>String.prototype.replace()</p><ul><li>被用来在正则表达式和字符串直接比较，然后用新的子串来替换被匹配的子串。</li></ul></li><li><p>String.prototype.search()</p><ul><li>对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标。</li></ul></li><li><p>String.prototype.toString()</p><ul><li>返回用字符串表示的特定对象。重写 Object.prototype.toString 方法。</li></ul></li></ul><h3 id="Set、Map、WeakSet-和-WeakMap-的区别？"><a href="#Set、Map、WeakSet-和-WeakMap-的区别？" class="headerlink" title="Set、Map、WeakSet 和 WeakMap 的区别？"></a>Set、Map、WeakSet 和 WeakMap 的区别？</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a><a href="http://es6.ruanyifeng.com/#docs/set-map#Set" target="_blank" rel="noopener">Set</a></h4><ul><li>表示有没有，成员的值都是唯一的，没有重复的值</li><li>可以接受一个数组（或可迭代的数据结构）作为参数</li><li>注：两个对象总是不相等的</li></ul><p>属性：</p><ul><li>Set.prototype.constructor：构造函数，默认就是Set函数。</li><li>Set.prototype.size：返回Set实例的成员总数。</li></ul><p>方法：</p><ul><li>add(value)：添加某个值，返回 Set 结构本身。<ul><li><code>s.add(1).add(2).add(2)</code>;</li></ul></li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li><li>clear()：清除所有成员，没有返回值。</li></ul><p>遍历方法</p><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回键值对的遍历器</li><li>forEach()：使用回调函数遍历每个成员</li></ul><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a><a href="http://es6.ruanyifeng.com/#docs/set-map#WeakSet" target="_blank" rel="noopener">WeakSet</a></h4><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但与 Set 有几个区别：</p><ul><li>WeakSet 的成员<strong>只能是对象</strong>，而不能是其他类型的值</li><li>WeakSet 中的对象都是弱引用<ul><li>如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存</li><li>垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</li></ul></li><li>WeakSet 不可遍历<ul><li>由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的</li></ul></li><li>WeakSet 结构中没有clear方法。</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="http://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">Map</a></h4><p>类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，<strong>各种类型的值（包括对象）都可以当作Map的键</strong>。</p><p>遍历方法<br>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li>keys()：返回键名的遍历器。</li><li>values()：返回键值的遍历器。</li><li>entries()：返回所有成员的遍历器。</li><li>forEach()：遍历 Map 的所有成员。</li></ul><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a><a href="http://es6.ruanyifeng.com/#docs/set-map#WeakMap" target="_blank" rel="noopener">WeakMap</a></h4><p>WeakMap的设计目的在于: 有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用，而一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放被引用对象占用的内存。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p><p>一个典型应用<strong>场景</strong>是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/作用域</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域相关问题"><a href="#作用域相关问题" class="headerlink" title="作用域相关问题"></a>作用域相关问题</h1><h3 id="下面的代码打印什么内容，为什么？"><a href="#下面的代码打印什么内容，为什么？" class="headerlink" title="下面的代码打印什么内容，为什么？"></a>下面的代码打印什么内容，为什么？</h3><pre><code class="js">// 情况 1 //  情况 2var b = 10;var c = function b() {  b = 20;  console.log(b)}c()// 上面两种都打印：ƒ b() {  b = 20;  console.log(b)}</code></pre><p>b函数（函数表达式定义函数）是一个相当于用const定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错”Uncaught TypeError: Assignment to constant variable.”</p><h3 id="简单改造下面的代码，使之分别打印-10-和-20"><a href="#简单改造下面的代码，使之分别打印-10-和-20" class="headerlink" title="简单改造下面的代码，使之分别打印 10 和 20"></a>简单改造下面的代码，使之分别打印 10 和 20</h3><pre><code class="js">var b = 10;(function b() {  b = 20;  console.log(b)})()</code></pre><p>打印10：</p><pre><code class="js">var b = 10;(function b(b) {  window.b = 20;  console.log(b)})(b)</code></pre><pre><code class="js">var b = 10;(function b() {  b.b = 20;  console.log(b)})()</code></pre><p>打印20：</p><pre><code class="js">var b = 10;(function b(b) {  b = 20;  console.log(b)})()</code></pre><pre><code class="js">var b = 10;(function b() {  var b = 20;  console.log(b)})()</code></pre><h3 id="下面代码输出什么"><a href="#下面代码输出什么" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h3><pre><code class="js">var a = 10;(function () {    console.log(a)    a = 5    console.log(window.a)    var a = 20;    console.log(a)})()</code></pre><p>依次输出：undefined -&gt; 10 -&gt; 20</p><p>解析：</p><p>在立即执行函数中，var a = 20; 语句定义了一个局部变量 a，<strong>由于js的变量声明提升机制</strong>，局部变量a的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印undefined，最后一条语句会打印20。</p><p>由于全局的var 会挂载到window对象下，并且立即执行函数里面有变量提示。<br>‘a = 5;’这条语句执行时，局部的变量a已经声明，因此它产生的效果是对局部的变量a赋值，此时window.a 依旧是最开始赋值的10</p><h3 id="var变量定义提升"><a href="#var变量定义提升" class="headerlink" title="var变量定义提升"></a>var变量定义提升</h3><pre><code class="js">var name = &#39;Tom&#39;;(function() {if (typeof name == &#39;undefined&#39;) {  var name = &#39;Jack&#39;;  console.log(&#39;Goodbye &#39; + name);} else {  console.log(&#39;Hello &#39; + name);}})();</code></pre><p>输出： ‘Goodbye Jack’</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/事件队列</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>参考地址:<a href="https://zhuanlan.zhihu.com/p/41543963" target="_blank" rel="noopener">Event Loop 这个循环你晓得么？(附 GIF 详解)-饿了么前端</a></p><h3 id="任务队列的本质"><a href="#任务队列的本质" class="headerlink" title="任务队列的本质"></a><strong>任务队列的本质</strong></h3><ul><li>所有同步任务都在主线程上执行，形成一个<strong>执行栈</strong>（execution context stack）。</li><li>主线程之外，还存在一个”<strong>任务队列</strong>”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ul><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><ul><li>setTimeOut、setInterval</li><li>DOM 事件</li><li>Promise</li></ul><h3 id="JavaScript-实现异步编程的方法？"><a href="#JavaScript-实现异步编程的方法？" class="headerlink" title="JavaScript 实现异步编程的方法？"></a>JavaScript 实现异步编程的方法？</h3><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promises 对象</li><li>Async 函数[ES7]</li></ul><h3 id="关于-setTimeOut、setImmediate、process-nextTick-的比较"><a href="#关于-setTimeOut、setImmediate、process-nextTick-的比较" class="headerlink" title="关于 setTimeOut、setImmediate、process.nextTick()的比较"></a>关于 setTimeOut、setImmediate、process.nextTick()的比较</h3><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h4><p>将事件插入到了事件队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。<br>当主线程时间执行过长，无法保证回调会在事件指定的时间执行。<br>浏览器端每次setTimeout会有4ms的延迟，当连续执行多个setTimeout，有可能会阻塞进程，造成性能问题。</p><h4 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h4><p>事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行。和setTimeout(fn,0)的效果差不多。<br>服务端node提供的方法。浏览器端最新的api也有类似实现:window.setImmediate,但支持的浏览器很少。</p><h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h4><p>插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。<br>大致流程：当前”执行栈”的尾部–&gt;下一次Event Loop（主线程读取”任务队列”）之前–&gt;触发process指定的回调函数。<br>服务器端node提供的办法。用此方法可以用于处于异步延迟的问题。<br>可以理解为：此次不行，预约下次优先执行。</p><h3 id="浏览器的Tasks、microtasks、-queues-和-schedules"><a href="#浏览器的Tasks、microtasks、-queues-和-schedules" class="headerlink" title="浏览器的Tasks、microtasks、 queues 和 schedules"></a><a href="https://github.com/sisterAn/blog/issues/21" target="_blank" rel="noopener">浏览器的Tasks、microtasks、 queues 和 schedules</a></h3><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise本身是同步的立即执行函数， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。</p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h4><p>Async/Await就是一个自执行的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式。</p><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/事件轮询机制</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="从一道题浅说-JavaScript-的事件循环"><a href="#从一道题浅说-JavaScript-的事件循环" class="headerlink" title="从一道题浅说 JavaScript 的事件循环"></a>从一道题浅说 JavaScript 的事件循环</h1><p>原文链接： <a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7</a></p><p><strong>注：本篇文章运行环境为当前最新版本的谷歌浏览器（72.0.3626.109）</strong></p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>首先我们需要明白以下几件事情：</p><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><p>根据规范，事件循环是通过<a href="https://www.w3.org/TR/html5/webappapis.html#task-queues" target="_blank" rel="noopener">任务队列</a>的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；<strong>每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。</strong> setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。</p><p><img src="https://camo.githubusercontent.com/dd47eccb5d9f224f911f0a1cbdf3fb5c9f3fa24a/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30322f30382f356335643764383530353663372e706e67" srcset="/img/loading.gif" alt="任务队列"></p><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><p>(macro)task（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p><p>浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，<strong>会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染</strong>，流程如下：</p><pre><code>(macro)task-&gt;渲染-&gt;(macro)task-&gt;...</code></pre><p>(macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)</p><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>microtask（又称为微任务），<strong>可以理解是在当前 task 执行结束后立即执行的任务</strong>。也就是说，在当前task任务后，下一个task之前，在渲染之前。</p><p>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。</p><p>microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)</p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops-processing-model" target="_blank" rel="noopener">处理模型</a>是比较复杂的，但关键步骤如下：</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ul><p>流程图如下：</p><p><a href="https://camo.githubusercontent.com/47479c8773d91e8eef4a359eca57bb1361183b9e/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30322f30382f356335643661353238626461662e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/47479c8773d91e8eef4a359eca57bb1361183b9e/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30322f30382f356335643661353238626461662e6a7067" srcset="/img/loading.gif" alt="mark"></a></p><h2 id="Promise和async中的立即执行"><a href="#Promise和async中的立即执行" class="headerlink" title="Promise和async中的立即执行"></a>Promise和async中的立即执行</h2><p>我们知道Promise中的异步体现在<code>then</code>和<code>catch</code>中，所以写在Promise中的代码是被当做同步任务立即执行的。而在async/await中，在出现await出现之前，其中的代码也是立即执行的。那么出现了await时候发生了什么呢？</p><h2 id="await做了什么"><a href="#await做了什么" class="headerlink" title="await做了什么"></a>await做了什么</h2><p>从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。</p><p>很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，<strong>实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。</strong></p><p>这里感谢<a href="https://github.com/chenjigeng" target="_blank" rel="noopener">@chenjigeng</a>的纠正：</p><p>由于因为async await 本身就是promise+generator的语法糖。所以await后面的代码是microtask。所以对于本题中的</p><pre><code class="javascript">async function async1() {    console.log(&#39;async1 start&#39;);    await async2();    console.log(&#39;async1 end&#39;);}</code></pre><p>等价于</p><pre><code class="javascript">async function async1() {    console.log(&#39;async1 start&#39;);    Promise.resolve(async2()).then(() ={                console.log(&#39;async1 end&#39;);        })}</code></pre><h2 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h2><pre><code class="javascript">//请写出输出内容async function async1() {    console.log(&#39;async1 start&#39;);    await async2();    console.log(&#39;async1 end&#39;);}async function async2() {    console.log(&#39;async2&#39;);}console.log(&#39;script start&#39;);  // 1setTimeout(function() {    console.log(&#39;setTimeout&#39;);}, 0)async1();new Promise(function(resolve) {    console.log(&#39;promise1&#39;);    resolve();}).then(function() {    console.log(&#39;promise2&#39;);});console.log(&#39;script end&#39;);/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/</code></pre><p>这道题主要考察的是事件循环中函数执行顺序的问题，其中包括<code>async</code> ，<code>await</code>，<code>setTimeout</code>，<code>Promise</code>函数。下面来说一下本题中涉及到的知识点。</p><p>以上就本道题涉及到的所有相关知识点了，下面我们再回到这道题来一步一步看看怎么回事儿。</p><ol><li><p>首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。所以，上面例子的第一步执行如下图所示：  </p><p><img src="https://camo.githubusercontent.com/15b3ae9733b0b5b6a144f519396ff88eaeca40fb/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30322f30382f356335643639623432316166332e706e67" srcset="/img/loading.gif" alt=""></p></li><li><p>然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 <code>console</code> 语句，直接输出 <code>script start</code>。输出之后，script 任务继续往下执行，遇到 <code>setTimeout</code>，其作为一个宏任务源，则会先将其任务分发到对应的队列中：<br><img src="https://camo.githubusercontent.com/0a6e6cd2cc52d18a0f97ec01659058e830305a45/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30322f30382f356335643639623432353530612e706e67" srcset="/img/loading.gif" alt=""></p></li><li><p>script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出<code>async1 start</code>。<br>遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出<code>async2</code>，然后将await后面的代码也就是<code>console.log(&#39;async1 end&#39;)</code>加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码。<br><img src="https://camo.githubusercontent.com/93ec5469b0846f0f161641fc718005dbe994d190/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30322f31382f356336616435383333376165642e706e67" srcset="/img/loading.gif" alt=""></p></li><li><p>script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 <code>.then</code> 则会被分发到 microtask 的 <code>Promise</code> 队列中去。所以会先输出 <code>promise1</code>，然后执行 <code>resolve</code>，将 <code>promise2</code> 分配到对应队列。<br><img src="https://camo.githubusercontent.com/6f617a237607ce7a71fabcab61d2952a8b412205/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30322f31382f356336616435383334376135652e706e67" srcset="/img/loading.gif" alt=""></p></li><li><p>script任务继续往下执行，最后只有一句输出了 <code>script end</code>，至此，全局任务就执行完毕了。<br>根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。<br>因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， <code>Promise</code> 队列有的两个任务<code>async1 end</code>和<code>promise2</code>，因此按先后顺序输出 <code>async1 end，promise2</code>。当所有的 Microtasks 执行完毕之后，表示第一轮的循环就结束了。</p></li><li><p>第二轮循环开始，这个时候就会跳回async1函数中执行后面的代码，然后遇到了同步任务 <code>console</code> 语句，直接输出 <code>async1 end</code>。这样第二轮的循环就结束了。（也可以理解为被加入到script任务队列中，所以会先与setTimeout队列执行）</p></li><li><p>第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 <code>setTimeout</code>，取出直接输出即可，至此整个流程结束。</p></li></ol><p>下面我会改变一下代码来加深印象。</p><h2 id="变式一"><a href="#变式一" class="headerlink" title="变式一"></a>变式一</h2><p>在第一个变式中我将async2中的函数也变成了Promise函数，代码如下：</p><pre><code class="javascript">async function async1() {    console.log(&#39;async1 start&#39;);    await async2();    console.log(&#39;async1 end&#39;);}async function async2() {    //async2做出如下更改：    new Promise(function(resolve) {    console.log(&#39;promise1&#39;);    resolve();}).then(function() {    console.log(&#39;promise2&#39;);    });}console.log(&#39;script start&#39;);setTimeout(function() {    console.log(&#39;setTimeout&#39;);}, 0)async1();new Promise(function(resolve) {    console.log(&#39;promise3&#39;);    resolve();}).then(function() {    console.log(&#39;promise4&#39;);});console.log(&#39;script end&#39;);</code></pre><p>可以先自己看看输出顺序会是什么，下面来公布结果：</p><pre><code>script startasync1 startpromise1promise3script endpromise2async1 endpromise4setTimeout</code></pre><p>在第一次macrotask执行完之后，也就是输出<code>script end</code>之后，会去清理所有microtask。所以会相继输出<code>promise2</code>， <code>async1 end</code> ，<code>promise4</code>，其余不再多说。</p><h2 id="变式二"><a href="#变式二" class="headerlink" title="变式二"></a>变式二</h2><p>在第二个变式中，我将async1中await后面的代码和async2的代码都改为异步的，代码如下：</p><pre><code class="javascript">async function async1() {    console.log(&#39;async1 start&#39;);    await async2();    //更改如下：    setTimeout(function() {        console.log(&#39;setTimeout1&#39;)    },0)}async function async2() {    //更改如下：    setTimeout(function() {        console.log(&#39;setTimeout2&#39;)    },0)}console.log(&#39;script start&#39;);setTimeout(function() {    console.log(&#39;setTimeout3&#39;);}, 0)async1();new Promise(function(resolve) {    console.log(&#39;promise1&#39;);    resolve();}).then(function() {    console.log(&#39;promise2&#39;);});console.log(&#39;script end&#39;);</code></pre><p>可以先自己看看输出顺序会是什么，下面来公布结果：</p><pre><code>script startasync1 startpromise1script endpromise2setTimeout3setTimeout2setTimeout1</code></pre><p>在输出为<code>promise2</code>之后，接下来会按照加入setTimeout队列的顺序来依次输出，通过代码我们可以看到加入顺序为<code>3 2 1</code>，所以会按3，2，1的顺序来输出。</p><h2 id="变式三"><a href="#变式三" class="headerlink" title="变式三"></a>变式三</h2><p>变式三是我在一篇面经中看到的原题，整体来说大同小异，代码如下：</p><pre><code class="javascript">async function a1 () {    console.log(&#39;a1 start&#39;)    await a2()    console.log(&#39;a1 end&#39;)}async function a2 () {    console.log(&#39;a2&#39;)}console.log(&#39;script start&#39;)setTimeout(() ={    console.log(&#39;setTimeout&#39;)}, 0)Promise.resolve().then(() ={    console.log(&#39;promise1&#39;)})a1()let promise2 = new Promise((resolve) ={    resolve(&#39;promise2.then&#39;)    console.log(&#39;promise2&#39;)})promise2.then((res) ={    console.log(res)    Promise.resolve().then(() ={        console.log(&#39;promise3&#39;)    })})console.log(&#39;script end&#39;)</code></pre><p>无非是在微任务那块儿做点文章，前面的内容如果你都看懂了的话这道题一定没问题的，结果如下：</p><pre><code>script starta1 starta2promise2script endpromise1a1 endpromise2.thenpromise3setTimeout</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/dwqs/blog/issues/61" target="_blank" rel="noopener">从一道题浅说 JavaScript 的事件循环</a></li><li><a href="https://segmentfault.com/a/1190000011296839" target="_blank" rel="noopener">async/await 执行顺序详解</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/事件</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><h3 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h3><p>事件触发有三个阶段：</p><ul><li>window 往事件触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</li></ul><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p><h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>通常使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。第三个参数默认值为 false，决定了注册的事件是捕获事件（ture为）还是冒泡事件。</p><p>一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p><h3 id="target-和-currentTarget"><a href="#target-和-currentTarget" class="headerlink" title="target 和 currentTarget"></a>target 和 currentTarget</h3><p>在了解上述的事件传递的三个阶段后，我们来梳理事件对象中容易混淆的两个属性：target 和 currentTarget 。</p><p>target 是触发事件的某个具体的对象，只会出现在事件机制的目标阶段，即“谁触发了事件，谁就是 target ”。<br>currentTarget 是绑定事件的对象。</p><h3 id="取消默认操作"><a href="#取消默认操作" class="headerlink" title="取消默认操作"></a><a href="https://wiki.jikexueyuan.com/project/brief-talk-js/event-cancellation-and-prevent-bubbles.html" target="_blank" rel="noopener">取消默认操作</a></h3><p>取消默认操作<br>w3c 的方法是 e.preventDefault()，IE 则是使用 e.returnValue = false;</p><pre><code class="js">function cancelHandler(event){    var event = event || window.event;  //用于IE    if(event.preventDefault) event.preventDefault();  //标准技术    if(event.returnValue) event.returnValue = false;  //IE    return false;   //用于处理使用对象属性注册的处理程序  }  </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/this</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/this/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/this/</url>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h3 id="this的指向有哪几种情况？"><a href="#this的指向有哪几种情况？" class="headerlink" title="this的指向有哪几种情况？"></a>this的指向有哪几种情况？</h3><p>this代表函数调用相关联的对象，通常页称之为执行上下文。</p><ol><li>作为函数直接调用，非严格模式下，this指向window，严格模式下，this指向undefined；</li><li>作为某对象的方法调用，this通常指向调用的对象。</li><li>使用apply、call、bind 可以绑定this的指向。</li><li>在构造函数中，this指向新创建的对象</li><li>箭头函数没有单独的this值，this在箭头函数创建时确定，它与声明所在的上下文相同。</li></ol><h3 id="如果对一个函数进行多次-bind，那么上下文会是什么呢？"><a href="#如果对一个函数进行多次-bind，那么上下文会是什么呢？" class="headerlink" title="如果对一个函数进行多次 bind，那么上下文会是什么呢？"></a>如果对一个函数进行多次 bind，那么上下文会是什么呢？</h3><pre><code class="js">let a = {}let fn = function () { console.log(this) }fn.bind().bind(a)() // =&gt; ?</code></pre><p>不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。</p><pre><code class="js">// fn.bind().bind(a) 等于let fn2 = function fn1() {  return function() {    return fn.apply()  }.apply(a)}fn2()</code></pre><h3 id="多个this规则出现时，this最终指向哪里？"><a href="#多个this规则出现时，this最终指向哪里？" class="headerlink" title="多个this规则出现时，this最终指向哪里？"></a>多个this规则出现时，this最终指向哪里？</h3><p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。<br><img src="../img/this.png" srcset="/img/loading.gif" alt="this"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/ServiceWorker</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/ServiceWorker/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/ServiceWorker/</url>
    
    <content type="html"><![CDATA[<h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p><pre><code class="js">// index.jsif (navigator.serviceWorker) {  navigator.serviceWorker    .register(&#39;sw.js&#39;)    .then(function(registration) {      console.log(&#39;service worker 注册成功&#39;)    })    .catch(function(err) {      console.log(&#39;servcie worker 注册失败&#39;)    })}// sw.js// 监听 `install` 事件，回调中缓存所需文件self.addEventListener(&#39;install&#39;, e =&gt; {  e.waitUntil(    caches.open(&#39;my-cache&#39;).then(function(cache) {      return cache.addAll([&#39;./index.html&#39;, &#39;./index.js&#39;])    })  )})// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener(&#39;fetch&#39;, e =&gt; {  e.respondWith(    caches.match(e.request).then(function(response) {      if (response) {        return response      }      console.log(&#39;fetch source&#39;)    })  )})</code></pre><p>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了<br><img src="../img/serviceWorker.png" srcset="/img/loading.gif" alt=""></p><p>在 Cache 中也可以发现我们所需的文件已被缓存<br><img src="../img/cache-worker.png" srcset="/img/loading.gif" alt=""></p><p>当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的<br><img src="../img/reload-worker.png" srcset="/img/loading.gif" alt=""></p><h3 id="好文链接"><a href="#好文链接" class="headerlink" title="好文链接"></a>好文链接</h3><ul><li><a href="https://www.zcfy.cc/article/service-worker-what-are-you-mariko-kosaka-1927.html" target="_blank" rel="noopener">https://www.zcfy.cc/article/service-worker-what-are-you-mariko-kosaka-1927.html</a></li><li><a href="https://juejin.im/post/5ba0fe356fb9a05d2c43a25c" target="_blank" rel="noopener">https://juejin.im/post/5ba0fe356fb9a05d2c43a25c</a></li><li><a href="https://juejin.im/post/5bf3f656e51d45338e084044" target="_blank" rel="noopener">https://juejin.im/post/5bf3f656e51d45338e084044</a></li><li><a href="https://juejin.im/post/5bf3f6b2e51d45360069e527" target="_blank" rel="noopener">https://juejin.im/post/5bf3f6b2e51d45360069e527</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/README</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/README/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/README/</url>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><a href="变量类型和类型转换.md">变量</a></h2><h2 id="this"><a href="#this" class="headerlink" title="this"></a><a href="this.md">this</a></h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><a href="函数.md">函数</a></h2><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a><a href="对象.md">对象</a></h2><h2 id="原型链与继承"><a href="#原型链与继承" class="headerlink" title="原型链与继承"></a><a href="原型链与继承.md">原型链与继承</a></h2><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a><a href="ES6.md">ES6</a></h2><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a><a href="正则.md">正则</a></h2><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a><a href="事件队列.md">事件队列</a></h2><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a><a href="DOM.md">DOM</a></h2><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a><a href="BOM.md">BOM</a></h2><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="eval-是做什么的？"><a href="#eval-是做什么的？" class="headerlink" title="eval 是做什么的？"></a>eval 是做什么的？</h3><p>eval 的功能是把对应的字符串解析成 JS 代码并运行</p><ul><li>eval不安全，若有用户输入会有被攻击风险</li><li>非常耗性能（先解析成 js 语句，再执行）</li></ul><h3 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode" target="_blank" rel="noopener">严格模式的限制</a></h3><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用 with 语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]</li><li>eval 不会在它的外层作用域引入变量</li><li>eval 和 arguments 不能被重新赋值</li><li>arguments 不会自动反映函数参数的变化</li><li>不能使用 arguments.callee</li><li>不能使用 arguments.caller</li><li>禁止 this 指向全局对象</li><li>不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈</li><li>增加了保留字（比如 protected、static 和 interface）</li></ul><h3 id="Javascript-垃圾回收方法"><a href="#Javascript-垃圾回收方法" class="headerlink" title="Javascript 垃圾回收方法"></a>Javascript 垃圾回收方法</h3><p>标记清除（mark and sweep）</p><ul><li>这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”</li><li>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li></ul><p>引用计数(reference counting)</p><ul><li>在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间</li></ul><p>参考链接 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">内存管理-MDN</a></p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><ul><li>JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</li><li>未使用 var 声明的全局变量</li><li>闭包函数(Closures)</li><li>循环引用(两个对象相互引用)</li><li>控制台日志(console.log)</li><li>移除存在绑定事件的 DOM 元素(IE)</li></ul><h3 id="为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？"><a href="#为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？" class="headerlink" title="为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？"></a>为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</h3><p>模块化可以给我们带来以下好处</p><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li></ul><p>实现模块化方式：</p><ul><li>立即执行函数</li><li>AMD 和 CMD</li><li>CommonJS</li><li>ES Module</li></ul><h3 id="setTimeout、setInterval"><a href="#setTimeout、setInterval" class="headerlink" title="setTimeout、setInterval"></a>setTimeout、setInterval</h3><p>常见的定时器函数有 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>，但setTimeout、setInterval并不是到了哪个时间就执行，<strong>而是到了那个时间把任务加入到异步事件队列中</strong>。</p><p>因为 JS 是单线程执行的，如果某些同步代码影响了性能，就会导致 setTimeout 不会按期执行。</p><p>而setInterval可能经过了很多同步代码的阻塞，导致不正确了，可以使用setTimeout每次获取Date值，计算距离下一次期望执行的时间还有多久来动态的调整。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题</p><h3 id="cookie，localStorage，sessionStorage，indexDB"><a href="#cookie，localStorage，sessionStorage，indexDB" class="headerlink" title="cookie，localStorage，sessionStorage，indexDB"></a>cookie，localStorage，sessionStorage，indexDB</h3><table><thead><tr><th align="center">特性</th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">数据生命周期</td><td align="center">一般由服务器生成，可以设置过期时间</td><td align="center">除非被清理，否则一直存在</td><td align="center">页面关闭就清理</td><td align="center">除非被清理，否则一直存在</td></tr><tr><td align="center">数据存储大小</td><td align="center">4K</td><td align="center">5M</td><td align="center">5M</td><td align="center">无限</td></tr><tr><td align="center">与服务端通信</td><td align="center">每次都会携带在 header 中，对于请求性能影响</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><p>从上表可以看到，<code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p><p>对于 <code>cookie</code>，我们还需要注意安全性。</p><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td></tr><tr><td align="center">http-only</td><td align="center">不能通过 JS 访问 Cookie，减少 XSS 攻击</td></tr><tr><td align="center">secure</td><td align="center">只能在协议为 HTTPS 的请求中携带</td></tr><tr><td align="center">same-site</td><td align="center">规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/node事件轮询</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/node%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/node%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h1><p>原文链接： <a href="https://github.com/ljianshu/Blog/issues/54" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a></p><p>本文将会介绍 JS 实现异步的原理，并且了解了在浏览器和 Node 中 Event Loop 其实是不相同的。</p><h2 id="一、线程与进程"><a href="#一、线程与进程" class="headerlink" title="一、线程与进程"></a>一、线程与进程</h2><hr><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>我们经常说JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？</p><p>官方的说法是：<strong>进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位</strong>。这两句话并不好理解，我们先来看张图：<br><img src="https://camo.githubusercontent.com/0194774edbffee2453bf37a17e92b325db680867/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f392f313638333333633134633835643739343f773d34343326683d31363226663d706e6726733d3239343733" srcset="/img/loading.gif" alt=""></p><ul><li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li><li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说<strong>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</strong>；</li><li>工厂的空间是工人们共享的，这象征<strong>一个进程的内存空间是共享的，每个线程都可用这些共享内存</strong>。</li><li>多个工厂之间独立存在。</li></ul><h3 id="2-多进程与多线程"><a href="#2-多进程与多线程" class="headerlink" title="2.多进程与多线程"></a>2.多进程与多线程</h3><ul><li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li><li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li></ul><p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><h2 id="二、浏览器内核"><a href="#二、浏览器内核" class="headerlink" title="二、浏览器内核"></a>二、浏览器内核</h2><hr><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p><p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p><ul><li>GUI 渲染线程</li><li>JavaScript引擎线程</li><li>定时触发器线程</li><li>事件触发线程</li><li>异步http请求线程</li></ul><h3 id="1-GUI渲染线程"><a href="#1-GUI渲染线程" class="headerlink" title="1.GUI渲染线程"></a>1.GUI渲染线程</h3><ul><li>主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。</li><li>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</li><li>该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。</li></ul><h3 id="2-JS引擎线程"><a href="#2-JS引擎线程" class="headerlink" title="2.JS引擎线程"></a>2.JS引擎线程</h3><ul><li>该线程当然是主要负责处理 JavaScript脚本，执行代码。</li><li>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。</li><li>当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。</li></ul><h3 id="3-定时器触发线程"><a href="#3-定时器触发线程" class="headerlink" title="3.定时器触发线程"></a>3.定时器触发线程</h3><ul><li>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。</li><li>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</li></ul><h3 id="4-事件触发线程"><a href="#4-事件触发线程" class="headerlink" title="4.事件触发线程"></a>4.事件触发线程</h3><ul><li>主要负责将准备好的事件交给 JS引擎线程执行。</li></ul><p>比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。</p><h3 id="5-异步http请求线程"><a href="#5-异步http请求线程" class="headerlink" title="5.异步http请求线程"></a>5.异步http请求线程</h3><ul><li>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。</li><li>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</li></ul><h2 id="三、浏览器中的-Event-Loop"><a href="#三、浏览器中的-Event-Loop" class="headerlink" title="三、浏览器中的 Event Loop"></a>三、浏览器中的 Event Loop</h2><hr><h3 id="1-Micro-Task-与-Macro-Task"><a href="#1-Micro-Task-与-Macro-Task" class="headerlink" title="1.Micro-Task 与 Macro-Task"></a>1.Micro-Task 与 Macro-Task</h3><p>浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。<strong>宏任务队列可以有多个，微任务队列只有一个</strong>。</p><ul><li>常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。</li><li>常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。</li></ul><h3 id="2-Event-Loop-过程解析"><a href="#2-Event-Loop-过程解析" class="headerlink" title="2.Event Loop 过程解析"></a>2.Event Loop 过程解析</h3><p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p><p><img src="https://camo.githubusercontent.com/875c5b741e008b6cfbf92958bce1819f6cb51770/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31302f313638333836333633333538363937343f773d33393426683d34343926663d706e6726733d3838343433" srcset="/img/loading.gif" alt=""></p><ul><li><p>一开始执行栈空,我们可以把<strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p></li><li><p>全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p></li><li><p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p></li><li><p><strong>执行渲染操作，更新界面</strong></p></li><li><p>检查是否存在 Web worker 任务，如果有，则对其进行处理</p></li><li><p>上述过程循环往复，直到两个队列都清空</p></li></ul><p>我们总结一下，每一次循环都是一个这样的过程：</p><p><img src="https://camo.githubusercontent.com/877fe5d0b39d2696b12844b04f3d134cc9f957b1/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31302f313638333837376261396161623035363f773d36323826683d31333226663d706e6726733d3530303238" srcset="/img/loading.gif" alt=""></p><p><strong>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</strong></p><p>接下来我们看道例子来介绍上面流程：</p><pre><code class="js">    Promise.resolve().then(()=&gt;{      console.log(&#39;Promise1&#39;)        setTimeout(()=&gt;{        console.log(&#39;setTimeout2&#39;)      },0)    })    setTimeout(()=&gt;{      console.log(&#39;setTimeout1&#39;)      Promise.resolve().then(()=&gt;{        console.log(&#39;Promise2&#39;)          })    },0)</code></pre><p>最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</p><ul><li>一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2</li><li>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li><li>在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li><li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li></ul><h2 id="四、Node-中的-Event-Loop"><a href="#四、Node-中的-Event-Loop" class="headerlink" title="四、Node 中的 Event Loop"></a>四、Node 中的 Event Loop</h2><hr><h3 id="1-Node简介"><a href="#1-Node简介" class="headerlink" title="1.Node简介"></a>1.Node简介</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。</p><p><img src="https://camo.githubusercontent.com/58779606d55020cd7c815402ccdaea48dcd94aec/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31312f313638336438313637346630373665623f773d35343326683d32323326663d706e6726733d3831373535" srcset="/img/loading.gif" alt=""></p><ul><li>V8引擎解析JavaScript脚本。</li><li>解析后的代码，调用Node API。</li><li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li><li>V8引擎再将结果返回给用户。</li></ul><h3 id="2-六个阶段"><a href="#2-六个阶段" class="headerlink" title="2.六个阶段"></a>2.六个阶段</h3><p>其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p><p><img src="https://camo.githubusercontent.com/992acfd5750f98c9a56a9a96e95111bdf7cc7669/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343162643938363063316565393f773d33353926683d33333126663d706e6726733d3130353037" srcset="/img/loading.gif" alt=""></p><p>从上图中，大致看出node中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p><ul><li>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li><li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li>idle, prepare 阶段：仅node内部使用</li><li>poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close 事件回调</li></ul><p>注意：<strong>上面六个阶段都不包括 process.nextTick()</strong>(下文会介绍)</p><p>接下去我们详细介绍<code>timers</code>、<code>poll</code>、<code>check</code>这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</p><h4 id="1-timer"><a href="#1-timer" class="headerlink" title="(1) timer"></a>(1) timer</h4><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。<br>同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p><h4 id="2-poll"><a href="#2-poll" class="headerlink" title="(2) poll"></a>(2) poll</h4><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p><p>1.回到 timer 阶段执行回调</p><p>2.执行 I/O 回调</p><p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p><ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li><li>如果 poll 队列为空时，会有两件事发生<ul><li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li><li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p><h4 id="3-check阶段"><a href="#3-check阶段" class="headerlink" title="(3) check阶段"></a>(3) check阶段</h4><p>setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。<br>我们先来看个例子:</p><pre><code>console.log(&#39;start&#39;)setTimeout(() =&gt; {  console.log(&#39;timer1&#39;)  Promise.resolve().then(function() {    console.log(&#39;promise1&#39;)  })}, 0)setTimeout(() =&gt; {  console.log(&#39;timer2&#39;)  Promise.resolve().then(function() {    console.log(&#39;promise2&#39;)  })}, 0)Promise.resolve().then(function() {  console.log(&#39;promise3&#39;)})console.log(&#39;end&#39;)//start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2</code></pre><ul><li>一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出start end，并将2个timer依次放入timer队列）,会先去执行微任务（<strong>这点跟浏览器端的一样</strong>），所以打印出promise3</li><li>然后进入timers阶段，执行timer1的回调函数，打印timer1，并将promise.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；这点跟浏览器端相差比较大，<strong>timers阶段有几个setTimeout/setInterval都会依次执行</strong>，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于Node与浏览器的 Event Loop 差异，下文还会详细介绍）。</li></ul><h3 id="3-Micro-Task-与-Macro-Task"><a href="#3-Micro-Task-与-Macro-Task" class="headerlink" title="3.Micro-Task 与 Macro-Task"></a>3.Micro-Task 与 Macro-Task</h3><p>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p><ul><li>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。</li><li>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。</li></ul><h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4.注意点"></a>4.注意点</h3><h4 id="1-setTimeout-和-setImmediate"><a href="#1-setTimeout-和-setImmediate" class="headerlink" title="(1) setTimeout 和 setImmediate"></a>(1) setTimeout 和 setImmediate</h4><p>二者非常相似，区别主要在于调用时机不同。</p><ul><li><p>setImmediate 设计在poll阶段完成时执行，即check阶段；</p></li><li><p>setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行</p><p>setTimeout(function timeout () {<br>  console.log(‘timeout’);<br>},0);<br>setImmediate(function immediate () {<br>  console.log(‘immediate’);<br>});</p></li></ul><ul><li>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</li><li>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的<br>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</li><li>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</li></ul><p>但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout</p><pre><code>const fs = require(&#39;fs&#39;)fs.readFile(__filename, () =&gt; {    setTimeout(() =&gt; {        console.log(&#39;timeout&#39;);    }, 0)    setImmediate(() =&gt; {        console.log(&#39;immediate&#39;)    })})// immediate// timeout</code></pre><p>在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</p><h4 id="2-process-nextTick"><a href="#2-process-nextTick" class="headerlink" title="(2) process.nextTick"></a>(2) process.nextTick</h4><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p><pre><code>setTimeout(() =&gt; { console.log(&#39;timer1&#39;) Promise.resolve().then(function() {   console.log(&#39;promise1&#39;) })}, 0)process.nextTick(() =&gt; { console.log(&#39;nextTick&#39;) process.nextTick(() =&gt; {   console.log(&#39;nextTick&#39;)   process.nextTick(() =&gt; {     console.log(&#39;nextTick&#39;)     process.nextTick(() =&gt; {       console.log(&#39;nextTick&#39;)     })   }) })})// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</code></pre><h2 id="五、Node与浏览器的-Event-Loop-差异"><a href="#五、Node与浏览器的-Event-Loop-差异" class="headerlink" title="五、Node与浏览器的 Event Loop 差异"></a>五、Node与浏览器的 Event Loop 差异</h2><hr><p><strong>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务</strong>。<br><img src="https://camo.githubusercontent.com/71b607cd363565c5d61299d31d9fd72b889de645/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343162616431636461373431663f773d3130353126683d33343426663d706e6726733d3932363835" srcset="/img/loading.gif" alt=""></p><p>接下我们通过一个例子来说明两者区别：</p><pre><code>setTimeout(()=&gt;{    console.log(&#39;timer1&#39;)    Promise.resolve().then(function() {        console.log(&#39;promise1&#39;)    })}, 0)setTimeout(()=&gt;{    console.log(&#39;timer2&#39;)    Promise.resolve().then(function() {        console.log(&#39;promise2&#39;)    })}, 0)</code></pre><p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p><p>浏览器端的处理过程如下：</p><p><img src="https://camo.githubusercontent.com/b325e476f0336804b8bdbcd7e4e3674a52dfbd80/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343164363339326538663533373f773d36313126683d33343126663d67696626733d373232393739" srcset="/img/loading.gif" alt=""></p><p>Node端运行结果分两种情况：</p><ul><li>如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li><li>如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。<ul><li>如果是第二个定时器还未在完成队列中，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li><li>如果是第二个定时器已经在完成队列中，则最后的结果为<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code>(下文过程解释基于这种情况下)</li></ul></li></ul><p>1.全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；</p><p>2.首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；</p><p>3.至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2</p><p>Node端的处理过程如下：<br><img src="https://camo.githubusercontent.com/34b3491060826045c67bd57c6dcf97222620a722/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343164356638353436383034373f773d35393826683d33333326663d67696626733d343637363635" srcset="/img/loading.gif" alt=""></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><hr><p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p><ul><li>Node端，microtask 在事件循环的各个阶段之间执行</li><li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>文章于2019.1.16晚，对最后一个例子在node运行结果，重新修改！再次特别感谢<a href="https://juejin.im/user/59c335e95188254f531d0b51" target="_blank" rel="noopener">zy445566</a>和<a href="https://github.com/BuptStEve" target="_blank" rel="noopener">BuptStEve</a>的精彩点评，<strong>由于node版本更新到11，Event Loop运行原理发生了变化，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这点就跟浏览器端一致</strong>。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://imweb.io/topic/58e3bfa845e5c13468f567d5" target="_blank" rel="noopener">浏览器进程？线程？傻傻分不清楚！</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651555331&idx=1&sn=5a063db73329a9d8ea5c38d8eeb50741&chksm=802551c2b752d8d4020514337f9987cc6611ba878525c45507cbb9ceb52b92e060f50e76c48d&mpshare=1&scene=1&srcid=1115P2jpgUGueMlTaRe9UFYu#rd" target="_blank" rel="noopener">事件循环机制的那些事</a></li><li><a href="https://juejin.im/book/5b936540f265da0a9624b04b" target="_blank" rel="noopener">前端性能优化原理与实践</a></li><li><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5be04a8e6fb9a04a072fd2cd#heading-3" target="_blank" rel="noopener">前端面试之道</a></li><li><a href="http://lynnelv.github.io/js-event-loop-nodejs" target="_blank" rel="noopener">深入理解js事件循环机制（Node.js篇）</a></li><li><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener">详解JavaScript中的Event Loop（事件循环）机制</a></li><li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">event-loop-timers-and-nexttick</a></li><li><a href="https://github.com/nodejs/node/pull/22842" target="_blank" rel="noopener">timers: run nextTicks after each immediate and timer</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/ES6</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/ES6/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h3 id="var、let-及-const-区别？"><a href="#var、let-及-const-区别？" class="headerlink" title="var、let 及 const 区别？"></a>var、let 及 const 区别？</h3><ul><li>全局申明的var变量会挂载在window上，而let和const不会</li><li>var声明变量存在变量提升，let和const不会</li><li>let、const 的作用范围是块级作用域，而var的作用范围是函数作用域</li><li>同一作用域下let和const不能声明同名变量，而var可以</li><li>同一作用域下在let和const声明前使用会存在暂时性死区</li><li>const<ul><li>一旦声明必须赋值,不能使用null占位</li><li>声明后不能再修改</li><li>如果声明的是复合类型数据，可以修改其属性</li></ul></li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p> Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。</p><pre><code class="js">let p = new Proxy(target, handler)</code></pre><p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。</p><pre><code class="js">let onWatch = (obj, setBind, getLogger) =&gt; {  let handler = {    set(target, property, value, receiver) {      setBind(value, property)      return Reflect.set(target, property, value)    },    get(target, property, receiver) {      getLogger(target, property)      return Reflect.get(target, property, receiver)    }  }  return new Proxy(obj, handler)}let obj = { a: 1 }let p = onWatch(  obj,  (v, property) =&gt; {    console.log(`监听到属性${property}改变为${v}`)  },  (target, property) =&gt; {    console.log(`&#39;${property}&#39; = ${target[property]}`)  })p.a = 2 // 控制台输出：监听到属性a改变p.a // &#39;a&#39; = 2</code></pre><p>自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p><p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后返回一个新数组，原数组不发生改变。</p><p>map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组</p><pre><code class="js">var arr = [1,2,3];var arr2 = arr.map(item =&gt; item + 1)    arr   //[ 1, 2, 3 ]arr2  // [ 2, 3, 4 ]</code></pre><pre><code class="js">[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)// -&gt; [ 1, NaN, NaN ]</code></pre><ul><li>第一个 parseInt(‘1’, 0) -&gt; 1</li><li>第二个 parseInt(‘2’, 1) -&gt; NaN</li><li>第三个 parseInt(‘3’, 2) -&gt; NaN</li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素</p><p>filter 的回调函数接受三个参数，分别是当前索引元素，索引，原数组</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce 可以将数组中的元素通过回调函数最终转换为一个值。<br>如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码</p><pre><code class="js">const arr = [1, 2, 3]let total = 0for (let i = 0; i &lt; arr.length; i++) {  total += arr[i]}console.log(total) //6 </code></pre><p>但是如果我们使用 reduce 的话就可以将遍历部分的代码优化为一行代码</p><pre><code class="js">const arr = [1, 2, 3]const sum = arr.reduce((acc, current) =&gt; acc + current, 0)console.log(sum)</code></pre><p>对于 reduce 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 reduce 的过程</p><ul><li>首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入</li><li>回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数</li><li>在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入</li><li>所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6。</li></ul><h3 id="Es6中箭头函数与普通函数的区别？"><a href="#Es6中箭头函数与普通函数的区别？" class="headerlink" title="Es6中箭头函数与普通函数的区别？"></a>Es6中箭头函数与普通函数的区别？</h3><ul><li>普通function的声明在变量提升中是最高的，箭头函数没有函数提升</li><li>箭头函数没有属于自己的<code>this</code>，<code>arguments</code></li><li>箭头函数不能作为构造函数，不能被new，没有property</li><li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数</li><li>不可以使用 new 命令，因为：<ul><li>没有自己的 this，无法调用 call，apply</li><li>没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 <code>__proto__</code></li></ul></li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了。</p><ul><li>等待中（pending）</li><li>完成了（resolved）</li><li>拒绝了（rejected）</li></ul><p>当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的。</p><pre><code class="js">new Promise((resolve, reject) =&gt; {  console.log(&#39;new Promise&#39;)  resolve(&#39;success&#39;)})console.log(&#39;finifsh&#39;)// 先打印new Promise， 再打印 finifsh</code></pre><p>Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装。</p><pre><code class="js">Promise.resolve(1)  .then(res =&gt; {    console.log(res) // =&gt; 1    return 2 // 包装成 Promise.resolve(2)  })  .then(res =&gt; {    console.log(res) // =&gt; 2  })</code></pre><p>当然了，Promise 也很好地解决了回调地狱的问题</p><pre><code class="js">ajax(url)  .then(res =&gt; {      console.log(res)      return ajax(url1)  }).then(res =&gt; {      console.log(res)      return ajax(url2)  }).then(res =&gt; console.log(res))</code></pre><p>其实它也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。</p><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>一个函数如果加上 async ，那么该函数就会返回一个 Promise</p><pre><code class="js">async function test() {  return &quot;1&quot;}console.log(test()) // -&gt; Promise {&lt;resolved&gt;: &quot;1&quot;}</code></pre><p>async 就是将函数返回值使用 Promise.resolve() 包裹了下，和 then 中处理返回值一样，并且 await 只能配套 async 使用。</p><pre><code class="js">async function test() {  let value = await sleep()}</code></pre><p>async 和 await 可以说是异步终极解决方案了，相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题。</p><p>当然也存在一些缺点，因为 <strong>await 将异步代码改造成了同步代码</strong>，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p><pre><code class="js">async function test() {  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式  // 如果有依赖性的话，其实就是解决回调地狱的例子了  await fetch(url)  await fetch(url1)  await fetch(url2)}</code></pre><p>看一个使用 await 的例子：</p><pre><code class="js">let a = 0let b = async () =&gt; {  a = a + await 10  console.log(&#39;2&#39;, a)}b()a++console.log(&#39;1&#39;, a)//先输出  ‘1’, 1//在输出  ‘2’, 10</code></pre><ul><li>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来</li><li>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码</li><li>同步代码 a++ 与打印 a 执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10</li></ul><p>上述解释中提到了 await 内部实现了 generator，其实 <strong>await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator</strong>。</p><h3 id="代码分析题"><a href="#代码分析题" class="headerlink" title="代码分析题"></a>代码分析题</h3><pre><code class="js">function wait() {  return new Promise(resolve =&gt;      setTimeout(resolve,  1000)  )}async function main() {  console.time();  const x = wait();  const y = wait();  const z = wait();  await x;  await y;  await z;  console.timeEnd();}main();</code></pre><p>答案： 输出耗时： 1秒多一点点。<br>原因： 3个wait函数在赋值的时候就已经开始执行了。</p><p>稍微改造一下就可以得到3 * 1000 ms以上的结果</p><pre><code class="js">function wait () {  return new Promise(    resolve =&gt; setTimeout(resolve,  1000)  )}async function main () {  console.time()  const x = await wait()  const y = await wait()  const z = await wait()  console.timeEnd()}main()</code></pre><h3 id="Generator-生成器"><a href="#Generator-生成器" class="headerlink" title="Generator 生成器"></a>Generator 生成器</h3><pre><code class="js">function *foo(x) {  let y = 2 * (yield (x + 1))  let z = yield (y / 3)  return (x + y + z)}let it = foo(5)console.log(it.next())   // =&gt; {value: 6, done: false}console.log(it.next(12)) // =&gt; {value: 8, done: false}console.log(it.next(13)) // =&gt; {value: 42, done: true}</code></pre><ul><li><p>首先 Generator 函数调用和普通函数不同，它会返回一个迭代器</p></li><li><p>当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6</p></li><li><p>当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8</p></li><li><p>当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42</p></li></ul><h3 id="生成器原理"><a href="#生成器原理" class="headerlink" title="生成器原理"></a>生成器原理</h3><p>当yeild产生一个值后，生成器的执行上下文就会从栈中弹出。但由于迭代器一直保持着队执行上下文的引用，上下文不会丢失，不会像普通函数一样执行完后上下文就被销毁</p><h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><p>ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别</p><ul><li>CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案</li><li>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>ES Module 会编译成 require/exports 来执行的</li></ul><pre><code class="js">// 引入模块 APIimport XXX from &#39;./a.js&#39;import { XXX } from &#39;./a.js&#39;// 导出模块 APIexport function a() {}export default function() {}</code></pre><h3 id="私有方法和私有属性（阿里一面）"><a href="#私有方法和私有属性（阿里一面）" class="headerlink" title="私有方法和私有属性（阿里一面）"></a>私有方法和私有属性（阿里一面）</h3><p><a href="https://es6.ruanyifeng.com/?search=%E7%A7%81%E6%9C%89&x=0&y=0#docs/class#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">阮老师 | ES6入门</a></p><h4 id="现有的解决方案"><a href="#现有的解决方案" class="headerlink" title="现有的解决方案"></a>现有的解决方案</h4><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别，即在函数名或属性名前加<code>_</code>，但这并不安全，只是一种团队规范。</p><p>另一种方法就是索性<strong>将私有方法移出类，放到模块里</strong>，因为模块内部的所有方法都是对外可见的。</p><pre><code class="js">class Widget {  foo (baz) {    bar.call(this, baz);  }  // ...}function bar(baz) {  return this.snaf = baz;}</code></pre><p>上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p><p>还有一种方法是利用<strong>Symbol值的唯一性</strong>，将私有方法的名字命名为一个Symbol值。</p><pre><code class="js">const bar = Symbol(&#39;bar&#39;);const snaf = Symbol(&#39;snaf&#39;);export default class myClass{  // 公有方法  foo(baz) {    this[bar](baz);  }  // 私有方法  [bar](baz) {    return this[snaf] = baz;  }  // ...};</code></pre><p>上面代码中，bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，Reflect.ownKeys()依然可以拿到它们。</p><pre><code class="js">const inst = new myClass();Reflect.ownKeys(myClass.prototype)// [ &#39;constructor&#39;, &#39;foo&#39;, Symbol(bar) ]</code></pre><h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">Proxy</a></h3><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><pre><code class="js">var obj = new Proxy({}, {  get: function (target, key, receiver) {    console.log(`getting ${key}!`);    return Reflect.get(target, key, receiver);  },  set: function (target, key, value, receiver) {    console.log(`setting ${key}!`);    return Reflect.set(target, key, value, receiver);  }});</code></pre><p>Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li>get(target, propKey, receiver)<ul><li>拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li></ul></li><li>set(target, propKey, value, receiver)<ul><li>拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li></ul></li><li>has(target, propKey)<ul><li>拦截propKey in proxy的操作，返回一个布尔值。</li></ul></li><li>deleteProperty(target, propKey)<ul><li>拦截delete proxy[propKey]的操作，返回一个布尔值。</li></ul></li><li>ownKeys(target)<ul><li>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li></ul></li><li>getOwnPropertyDescriptor(target, propKey)<ul><li>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li></ul></li><li>defineProperty(target, propKey, propDesc)<ul><li>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li></ul></li><li>preventExtensions(target)<ul><li>拦截Object.preventExtensions(proxy)，返回一个布尔值。</li></ul></li><li>getPrototypeOf(target)<ul><li>拦截Object.getPrototypeOf(proxy)，返回一个对象。</li></ul></li><li>isExtensible(target)<ul><li>拦截Object.isExtensible(proxy)，返回一个布尔值。</li></ul></li><li>setPrototypeOf(target, proto)<ul><li>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li></ul></li><li>apply(target, object, args)<ul><li>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li></ul></li><li>construct(target, args)<ul><li>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/DOM</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/DOM/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><ul><li>DOM 事件的级别</li><li>DOM 事件模型</li><li>DOM 事件流</li><li>DOM 事件捕获的具体流程</li><li>Event 对象的常见应用</li><li>自定义事件</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener">DOM概述 | MDN</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element" target="_blank" rel="noopener">DOM | MDN</a></p><p><a href="https://blog.csdn.net/Night_Emperor/article/details/78471051" target="_blank" rel="noopener">DOM操作</a></p><h3 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h3><ul><li>DOM0<ul><li>onXXX类型的定义事件</li><li>element.onclick = function(e) { … }</li></ul></li><li>DOM2<ul><li>addEventListener方式</li><li>element.addEventListener(‘click’, function (e) { … })</li><li>btn.removeEventListener(‘click’, func, false)</li><li>btn.attachEvent(“onclick”, func);</li><li>btn.detachEvent(“onclick”, func);</li></ul></li><li>DOM3<ul><li>增加了很多事件类型</li><li>element.addEventListener(‘keyup’, function (e) { … })</li><li>eventUtil 是自定义对象，textInput 是 DOM3 级事件</li></ul></li></ul><h3 id="DOM-事件模型"><a href="#DOM-事件模型" class="headerlink" title="DOM 事件模型"></a>DOM 事件模型</h3><p>捕获从上到下， 冒泡从下到上。<br>先捕获，再到目标，再冒泡<br><img src="../img/dom%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B.jpg" srcset="/img/loading.gif" alt="事件模型"></p><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从window对象开始，也在window对象结束。</p><p>DOM标准规定事件流包括三个阶段：</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h3 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h3><p>从window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素</p><h3 id="Event对象常见应用"><a href="#Event对象常见应用" class="headerlink" title="Event对象常见应用"></a>Event对象常见应用</h3><ul><li>event.target<ul><li>触发事件的元素</li></ul></li><li>event.currentTarget<ul><li>绑定事件的元素</li></ul></li><li>event.preventDefault()<ul><li>阻止默认行为</li><li>event.cancelBubble()和event.preventBubble 都已经废弃</li></ul></li><li>event.stopPropagation()<ul><li>阻止在捕获阶段或冒泡阶段继续传播，而不是阻止冒泡</li></ul></li><li>event.stopImmediatePropagation()<ul><li>阻止事件冒泡并且阻止相同事件的其他侦听器被调用。</li></ul></li></ul><h3 id="事件的代理-委托"><a href="#事件的代理-委托" class="headerlink" title="事件的代理/委托"></a>事件的代理/委托</h3><p>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件</p><p>优点：</p><ul><li>可以减少事件注册，节省大量内存占用</li><li>可以将事件应用于动态添加的子元素上</li></ul><p>但使用不当会造成事件在不应该触发时触发</p><pre><code class="js">ulEl.addEventListener(&#39;click&#39;, function(e){  var target = event.target || event.srcElement;  if(target &amp;&amp; target.nodeName.toUpperCase() === &quot;LI&quot;){    console.log(target.innerHTML);  }}, false);</code></pre><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><ul><li>Event</li><li>CustomEvent</li></ul><p>CustomEvent不仅可以用来做自定义事件，还可以在后面跟一个object做参数</p><pre><code class="js">var evt = new Event(&#39;myEvent&#39;);someDom.addEventListener(&#39;myEvent&#39;, function() {  //处理这个自定义事件});someDom.dispatchEvent(evt);</code></pre><h3 id="IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>IE 只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获。</p><p>阻止冒泡：</p><ul><li>取消默认操作<ul><li>w3c 的方法是 e.preventDefault()</li><li>IE 则是使用 e.returnValue = false;</li></ul></li><li>return false <ul><li>javascript 的 return false 只会阻止默认行为</li><li>是用 jQuery 的话则既阻止默认行为又防止对象冒泡。</li></ul></li><li>阻止冒泡 <ul><li>w3c 的方法是 e.stopPropagation()</li><li>IE 则是使用 e.cancelBubble = true</li></ul></li></ul><pre><code class="js">[js] view plaincopyfunction stopHandler(event)  window.event   ? window.event.cancelBubble = true   : event.stopPropagation();}</code></pre><h3 id="DOM-元素的-dom-getAttribute-propName-和-dom-propName-有什么区别和联系"><a href="#DOM-元素的-dom-getAttribute-propName-和-dom-propName-有什么区别和联系" class="headerlink" title="DOM 元素的 dom.getAttribute(propName)和 dom.propName 有什么区别和联系"></a>DOM 元素的 dom.getAttribute(propName)和 dom.propName 有什么区别和联系</h3><ul><li>dom.getAttribute()，是标准 DOM 操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性</li><li>dom.propName 通常是在 HTML 文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如 a 标签生成 HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用 getAttribute 进行访问</li><li>dom.getAttribute()返回值是源文件中设置的值，类型是字符串或者 null（有的实现返回””）</li><li>dom.propName 返回值可能是字符串、布尔值、对象、undefined 等</li><li>大部分 attribute 与 property 是一一对应关系，修改其中一个会影响另一个，如 id，title 等属性</li><li>一些布尔属性<code>&lt;input hidden/&gt;</code>的检测设置需要 hasAttribute 和 removeAttribute 来完成，或者设置对应 property</li><li>像<code>&lt;a href=&quot;../index.html&quot;&gt;link&lt;/a&gt;</code>中 href 属性，转换成 property 的时候需要通过转换得到完整 URL</li><li>一些 attribute 和 property 不是一一对应如：form 控件中<code>&lt;input value=&quot;hello&quot;/&gt;</code>对应的是 defaultValue，修改或设置 value property 修改的是控件当前值，setAttribute 修改 value 属性不会改变 value property</li></ul><h3 id="JS获取dom的CSS样式"><a href="#JS获取dom的CSS样式" class="headerlink" title="JS获取dom的CSS样式"></a>JS获取dom的CSS样式</h3><pre><code class="js">function getStyle(obj, attr){  if(obj.currentStyle){    return obj.currentStyle[attr];  } else {    return window.getComputedStyle(obj, false)[attr];  }}</code></pre><h3 id="JS实现鼠标拖拽"><a href="#JS实现鼠标拖拽" class="headerlink" title="JS实现鼠标拖拽"></a><a href="https://blog.csdn.net/qq_37746973/article/details/80748879" target="_blank" rel="noopener">JS实现鼠标拖拽</a></h3><h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点?"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点?</h3><p>创建新节点</p><ul><li>createDocumentFragment() //创建一个 DOM 片段</li><li>createElement() //创建一个具体的元素</li><li>createTextNode() //创建一个文本节点</li></ul><p>添加、移除、替换、插入</p><ul><li>appendChild()</li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore() //在已有的子节点前插入一个新的子节点</li></ul><p>查找</p><ul><li>getElementsByTagName() //通过标签名称</li><li>getElementsByName() // 通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组，其中包括 id 等于 name 值的)  </li><li>getElementById() //通过元素 Id，唯一性</li></ul><h3 id="documen-write-和-innerHTML-的区别"><a href="#documen-write-和-innerHTML-的区别" class="headerlink" title="documen.write 和 innerHTML 的区别"></a>documen.write 和 innerHTML 的区别</h3><ul><li>document.write 只能重绘整个页面</li><li>innerHTML 可以重绘页面的一部分</li></ul><h3 id="Window-对象-与-document对象"><a href="#Window-对象-与-document对象" class="headerlink" title="Window 对象 与 document对象"></a>Window 对象 与 document对象</h3><p>window</p><ul><li>Window 对象表示当前浏览器的窗口，是 JavaScript 的顶级对象。</li><li>我们创建的所有对象、函数、变量都是 Window 对象的成员。</li><li>Window 对象的方法和属性是在全局范围内有效的。</li></ul><p>document</p><ul><li>Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）</li><li>Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问</li><li>Document 对象是 Window 对象的一部分，即 window.document</li></ul><h3 id="区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”"><a href="#区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”" class="headerlink" title="区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”"></a>区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”</h3><ul><li>客户区坐标<ul><li>鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)</li></ul></li><li>页面坐标<ul><li>鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标</li></ul></li><li>屏幕坐标<ul><li>设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)</li></ul></li></ul><h3 id="focus-blur与focusin-focusout的区别与联系"><a href="#focus-blur与focusin-focusout的区别与联系" class="headerlink" title="focus/blur与focusin/focusout的区别与联系"></a>focus/blur与focusin/focusout的区别与联系</h3><ol><li>focus/blur不冒泡，focusin/focusout冒泡</li><li>focus/blur兼容性好，focusin/focusout在除FireFox外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在FireFox下使用事件捕获elem.addEventListener(‘focus’, handler, true)</li></ol><h3 id="mouseover-mouseout与mouseenter-mouseleave的区别与联系"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别与联系" class="headerlink" title="mouseover/mouseout与mouseenter/mouseleave的区别与联系"></a>mouseover/mouseout与mouseenter/mouseleave的区别与联系</h3><ol><li>mouseover/mouseout是标准事件，<strong>所有浏览器都支持</strong>；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持</li><li>mouseover/mouseout是<strong>冒泡</strong>事件；mouseenter/mouseleave<strong>不冒泡</strong>。需要为<strong>多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能</strong></li><li>标准事件模型中event.target表示发生移入/出的元素,<strong>vent.relatedTarget</strong>对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，<strong>event.toElement</strong>表示移出的目标元素，<strong>event.fromElement</strong>表示移入时的来源元素</li></ol><h3 id="IE-的事件处理和-W3C-的事件处理有哪些区别？"><a href="#IE-的事件处理和-W3C-的事件处理有哪些区别？" class="headerlink" title="IE 的事件处理和 W3C 的事件处理有哪些区别？"></a>IE 的事件处理和 W3C 的事件处理有哪些区别？</h3><p>绑定事件</p><ul><li>W3C: targetEl.addEventListener(‘click’, handler, false);</li><li>IE: targetEl.attachEvent(‘onclick’, handler);</li></ul><p>删除事件</p><ul><li>W3C: targetEl.removeEventListener(‘click’, handler, false);</li><li>IE: targetEl.detachEvent(event, handler);</li></ul><p>事件对象</p><ul><li>W3C: var e = arguments.callee.caller.arguments[0]</li><li>IE: window.event</li></ul><p>事件目标</p><ul><li>W3C: e.target</li><li>IE: window.event.srcElement</li></ul><p>阻止事件默认行为</p><ul><li>W3C: e.preventDefault()</li><li>IE: window.event.returnValue = false’</li></ul><p>阻止事件传播</p><ul><li>W3C: e.stopPropagation()</li><li>IE: window.event.cancelBubble = true</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础/BOM</title>
    <link href="/uncategorized/JS%E5%9F%BA%E7%A1%80/BOM/"/>
    <url>/uncategorized/JS%E5%9F%BA%E7%A1%80/BOM/</url>
    
    <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM 是 browser object model 的缩写， 简称浏览器对象模型。 主要处理浏览器窗口和框架，<br>描述了与浏览器进行交互的方法和接口， 可以对浏览器窗口进行访问和操作， 譬如可以弹出<br>新的窗口， 回退历史记录， 获取 url……</p><h3 id="BOM-与-DOM-的关系"><a href="#BOM-与-DOM-的关系" class="headerlink" title="BOM 与 DOM 的关系"></a>BOM 与 DOM 的关系</h3><ol><li>javacsript 是通过访问 BOM 对象来访问、 控制、 修改浏览器</li><li>BOM 的 window 包含了 document， 因此通过 window 对象的 document 属性就可以访问、<br>检索、 修改文档内容与结构。</li><li>document 对象又是 DOM 模型的根节点。</li></ol><p>因此， BOM 包含了 DOM， 浏览器提供出来给予访问的是 BOM 对象， 从 BOM 对象再访<br>问到 DOM 对象， 从而 js 可以操作浏览器以及浏览器读取到的文档</p><h3 id="BOM-对象包含哪些内容？"><a href="#BOM-对象包含哪些内容？" class="headerlink" title="BOM 对象包含哪些内容？"></a>BOM 对象包含哪些内容？</h3><ul><li>Window JavaScript 层级中的顶层对象， 表示浏览器窗口。</li><li>Navigator 包含客户端浏览器的信息。</li><li>History 包含了浏览器窗口访问过的 URL。</li><li>Location 包含了当前 URL 的信息。</li><li>Screen 包含客户端显示屏的信息。</li></ul><h3 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h3><p>History 对象包含用户（在浏览器窗口中） 访问过的 URL</p><table><thead><tr><th>方法/属性</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td>返回浏览器历史列表中的 URL 数量。</td></tr><tr><td>back()</td><td>加载 history 列表中的前一个 URL。</td></tr><tr><td>forward()</td><td>加载 history 列表中的下一个 URL。</td></tr><tr><td>go()</td><td>加载 history 列表中的某个具体页面</td></tr></tbody></table><h3 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h3><p>Location 对象包含有关当前 URL 的信息。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>hash</td><td>设置或返回从井号 (#) 开始的 URL（锚） 。</td></tr><tr><td>host</td><td>设置或返回主机名和当前 URL 的端口号。</td></tr><tr><td>hostname</td><td>设置或返回当前 URL 的主机名。</td></tr><tr><td>href</td><td>设置或返回完整的 URL。</td></tr><tr><td>pathname</td><td>设置或返回当前 URL 的路径部分。</td></tr><tr><td>port</td><td>设置或返回当前 URL 的端口号。</td></tr><tr><td>protocol</td><td>设置或返回当前 URL 的协议。</td></tr><tr><td>search</td><td>置或返回从问号 (?) 开始的 URL（查询部分） 。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>assign()</td><td>加载新的文档。</td></tr><tr><td>reload(‘force’)</td><td>重新加载当前文档。参数可选，不填或填 false 则取浏览器缓存的文档</td></tr><tr><td>replace()</td><td>用新的文档替换当前文档。</td></tr></tbody></table><h3 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h3><p>Window 对象表示一个浏览器窗口或一个框架。 在客户端 JavaScript 中， Window 对象<br>是全局对象，所有的表达式都在当前的环境中计算。 例如，可以只写 document， 而<br>不必写 window.document。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>closed</td><td>返回窗口是否已被关闭。</td></tr><tr><td>defaultStatus</td><td>设置或返回窗口状态栏中的默认文本。 （仅 Opera 支持）</td></tr><tr><td>document</td><td>对 Document 对象的只读引用。 请参阅 Document 对象。</td></tr><tr><td>history</td><td>对 History 对象的只读引用。 请参数 History 对象。</td></tr><tr><td>innerheight</td><td>返回窗口的文档显示区的高度。</td></tr><tr><td>innerwidth</td><td>返回窗口的文档显示区的宽度。</td></tr><tr><td>length</td><td>设置或返回窗口中的框架数量。</td></tr><tr><td>location</td><td>用于窗口或框架的 Location 对象。 请参阅 Location 对象。</td></tr><tr><td>name</td><td>设置或返回窗口的名称。</td></tr><tr><td>Navigator</td><td>对 Navigator 对象的只读引用。 请参数 Navigator 对象。</td></tr><tr><td>opener</td><td>返回对创建此窗口的窗口的引用。</td></tr><tr><td>outerheight</td><td>返回窗口的外部高度。</td></tr><tr><td>outerwidth</td><td>返回窗口的外部宽度。</td></tr><tr><td>pageXOffset</td><td>设置或返回当前页面相对于窗口显示区左上角的 X 位置。</td></tr><tr><td>pageYOffset</td><td>设置或返回当前页面相对于窗口显示区左上角的 Y 位置。</td></tr><tr><td>parent</td><td>返回父窗口。</td></tr><tr><td>Screen</td><td>对 Screen 对象的只读引用。 请参数 Screen 对象。</td></tr><tr><td>self</td><td>返回对当前窗口的引用。 等价于 Window 属性。</td></tr><tr><td>status</td><td>设置窗口状态栏的文本。 (默认只支持 Opera)</td></tr><tr><td>top</td><td>返回最顶层的先辈窗口。</td></tr><tr><td>window</td><td>window 属性等价于 self 属性， 它包含了对窗口自身的引用。</td></tr><tr><td>screenLeft <br/> screenTop <br/> screenX <br/> screenY</td><td>只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。 IE、 Safari、 Chrome 和 Opera 支持 screenLeft 和 screenTop， 而 Chrome、 Firefox 和 Safari 支持 screenX 和 screenY。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>alert()</td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td>blur()</td><td>把键盘焦点从顶层窗口移开。</td></tr><tr><td>confirm()</td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr><tr><td>createPopup()</td><td>创建一个弹出窗口。 只有 ie 支持（不包括 ie11）</td></tr><tr><td>focus()</td><td>把键盘焦点给予一个窗口。</td></tr><tr><td>moveBy()</td><td>可相对窗口的当前坐标把它移动指定的像素。</td></tr><tr><td>moveTo()</td><td>把窗口的左上角移动到一个指定的坐标。</td></tr><tr><td>open()</td><td>打开一个新的浏览器窗口或查找一个已命名的窗口。 window.open(URL,name,features,replace)</td></tr><tr><td>print()</td><td>打印当前窗口的内容。</td></tr><tr><td>prompt()</td><td>显示可提示用户输入的对话框。</td></tr><tr><td>resizeBy()</td><td>按照指定的像素调整窗口的大小。</td></tr><tr><td>resizeTo()</td><td>把窗口的大小调整到指定的宽度和高度。</td></tr><tr><td>scrollBy()</td><td>按照指定的像素值来滚动内容。</td></tr><tr><td>scrollTo()</td><td>把内容滚动到指定的坐标。</td></tr><tr><td>setInterval()</td><td>按照指定的周期（以毫秒计） 来调用函数或计算表达式。</td></tr><tr><td>setTimeout()</td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr><tr><td>clearInterval()</td><td>取消由 setInterval() 设置的 timeout。</td></tr><tr><td>clearTimeout()</td><td>取消由 setTimeout() 方法设置的 timeout。close() 关闭浏览器窗口</td></tr></tbody></table><h3 id="Navigator-对象"><a href="#Navigator-对象" class="headerlink" title="Navigator 对象"></a>Navigator 对象</h3><p>Navigator 对象包含的属性描述了正在使用的浏览器。 可以使用这些属性进行平台专用的配置。 虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器， 但其他实现了 JavaScript 的浏览器也支持这个对象。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>appCodeName</td><td>返回浏览器的代码名。 以 Netscape 代码为基础的浏览器中， 它的值是 “Mozilla”。Microsoft 也是</td></tr><tr><td>appMinorVersion</td><td>返回浏览器的次级版本。 （IE4、 Opera 支持）</td></tr><tr><td>appName</td><td>返回浏览器的名称。</td></tr><tr><td>appVersion</td><td>返回浏览器的平台和版本信息。</td></tr><tr><td>browserLanguage</td><td>返回当前浏览器的语言。 （IE 和 Opera 支持）cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值。</td></tr><tr><td>cpuClass</td><td>返回浏览器系统的 CPU 等级。 （IE 支持）</td></tr><tr><td>onLine</td><td>返回指明系统是否处于脱机模式的布尔值。</td></tr><tr><td>platform</td><td>返回运行浏览器的操作系统平台。</td></tr><tr><td>systemLanguage</td><td>返回当前操作系统的默认语言。 （IE 支持）</td></tr><tr><td>userAgent</td><td>返回由客户机发送服务器的 user-agent 头部的值。</td></tr><tr><td>userLanguage</td><td>返回操作系统设定的自然语言。 （IE 和 Opera 支持）</td></tr><tr><td>plugins</td><td>返回包含客户端安装的所有插件的数组</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>javaEnabled()</td><td>规定浏览器是否支持并启用了 Java。</td></tr><tr><td>taintEnabled()</td><td>规定浏览器是否启用数据污点 (data tainting)。</td></tr></tbody></table><h3 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h3><p>Screen 对象包含有关客户端显示屏幕的信息。 每个 Window 对象的 screen 属性都引用一个 Screen 对象。 Screen 对象中存放着有关显示浏览器屏幕的信息。 JavaScript 程序将利用这些信息来优化它们的输出， 以达到用户的显示要求。 例如，一个程序可以根据显示器的尺寸选择使用大图像还是使用小图像，它还可以根据显示器的颜色深度选择使用 16 位色还是使用 8 位色的图形。 另外，JavaScript 程序还能根有关屏幕尺寸的信息将新的浏览器窗口定位在屏幕中间。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>availHeight</td><td>返回显示屏幕的高度 (除 Windows 任务栏之外)。</td></tr><tr><td>availWidth</td><td>返回显示屏幕的宽度 (除 Windows 任务栏之外)。</td></tr><tr><td>bufferDepth</td><td>设置或返回调色板的比特深度。 （仅 IE 支持）colorDepth 返回目标设备或缓冲器上的调色板的比特深度。</td></tr><tr><td>deviceXDPI</td><td>返回显示屏幕的每英寸水平点数。 （仅 IE 支持）</td></tr><tr><td>deviceYDPI</td><td>返回显示屏幕的每英寸垂直点数。 （仅 IE 支持）</td></tr><tr><td>fontSmoothingEnabled</td><td>返回用户是否在显示控制面板中启用了字体平滑。 （仅 IE 支持）</td></tr><tr><td>height</td><td>返回显示屏幕的高度。</td></tr><tr><td>logicalXDPI</td><td>返回显示屏幕每英寸的水平方向的常规点数。 （仅 IE 支持）</td></tr><tr><td>logicalYDPI</td><td>返回显示屏幕每英寸的垂直方向的常规点数。 （仅 IE 支持）</td></tr><tr><td>pixelDepth</td><td>返回显示屏幕的颜色分辨率（比特每像素） 。</td></tr><tr><td>updateInterval</td><td>设置或返回屏幕的刷新率。 （仅 IE11 以下支持）</td></tr><tr><td>width</td><td>返回显示器屏幕的宽度。</td></tr></tbody></table><h3 id="检测浏览器版本版本有哪些方式？"><a href="#检测浏览器版本版本有哪些方式？" class="headerlink" title="检测浏览器版本版本有哪些方式？"></a>检测浏览器版本版本有哪些方式？</h3><ul><li>根据 navigator.userAgent // UA.toLowerCase().indexOf(‘chrome’)</li><li>根据 window 对象的成员 // ‘ActiveXObject’ in window</li></ul><h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别</h3><ul><li>offsetWidth/offsetHeight 返回值包含 content + padding + border，效果与 e.getBoundingClientRect()相同</li><li>clientWidth/clientHeight 返回值只包含 content + padding，如果有滚动条，也不包含滚动条</li><li>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML/其他题目</title>
    <link href="/uncategorized/HTML/%E5%85%B6%E4%BB%96%E9%A2%98%E7%9B%AE/"/>
    <url>/uncategorized/HTML/%E5%85%B6%E4%BB%96%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="HTML5-的-form-如何关闭自动补全功能？"><a href="#HTML5-的-form-如何关闭自动补全功能？" class="headerlink" title="HTML5 的 form 如何关闭自动补全功能？"></a>HTML5 的 form 如何关闭自动补全功能？</h3><p>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</p><h3 id="如何实现浏览器内多个标签页之间的通信-阿里"><a href="#如何实现浏览器内多个标签页之间的通信-阿里" class="headerlink" title="如何实现浏览器内多个标签页之间的通信? (阿里)"></a>如何实现浏览器内多个标签页之间的通信? (阿里)</h3><ul><li>WebSocket、SharedWorker；</li><li>也可以调用 localstorge、cookies 等本地存储方式；</li></ul><p>localstorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个<code>storage</code>事件，</p><p>我们通过监听事件，控制它的值来进行页面信息通信；</p><p>注意 quirks：Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常；</p><h3 id="webSocket-如何兼容低浏览器？-阿里"><a href="#webSocket-如何兼容低浏览器？-阿里" class="headerlink" title="webSocket 如何兼容低浏览器？(阿里)"></a>webSocket 如何兼容低浏览器？(阿里)</h3><ul><li>Adobe Flash Socket 、</li><li>ActiveX HTMLFile (IE) 、</li><li>基于 multipart 编码发送 XHR 、</li><li>基于长轮询的 XHR</li></ul><h3 id="title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？"><a href="#title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？" class="headerlink" title="title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？"></a>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</h3><ul><li>title 属性没有明确意义只表示是个标题，H1 则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li><li>strong 是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：strong 会重读，而 b 是展示强调内容。</li><li>i 内容展示为斜体，em 表示强调的文本；</li></ul><p>Physical Style Elements – 自然样式标签</p><p>b, i, u, s, pre</p><p>Semantic Style Elements – 语义样式标签</p><p>strong, em, ins, del, code</p><p>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</p><h3 id="html5-有哪些新特性、移除了那些元素？如何处理-HTML5-新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5-有哪些新特性、移除了那些元素？如何处理-HTML5-新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><ul><li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等。<br>功能的增加：</p><ul><li>绘画 canvas</li><li>用于媒介播放的 video 和 audio 元素</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>语意化更好的内容元素，比如 article、footer、header、nav、section</li><li>表单控件，calendar、date、time、email、url、search</li><li>新的技术 webworker, websocket, Geolocation</li></ul></li><li><p>移除的元素：</p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul></li><li><p>支持 HTML5 新标签：</p><ul><li><p>IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，</p></li><li><p>可以利用这一特性让这些浏览器支持 HTML5 新标签，</p></li><li><p>浏览器支持新标签后，还需要添加标签默认的样式。</p></li><li><p>当然也可以直接使用成熟的框架、比如 html5shim;</p><pre><code class="html">&lt;!--[if lt IE 9]&gt;  &lt;script&gt;    src = &#39;http://html5shim.googlecode.com/svn/trunk/html5.js&#39;  &lt;/script&gt;&lt;![endif]--&gt;</code></pre></li></ul></li><li><p>如何区分 HTML5： DOCTYPE 声明\新增的结构元素\功能元素</p></li></ul><h3 id="HTML5-的离线储存怎么使用，工作原理能不能解释一下？"><a href="#HTML5-的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="HTML5 的离线储存怎么使用，工作原理能不能解释一下？"></a>HTML5 的离线储存怎么使用，工作原理能不能解释一下？</h3><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p><p>原理：HTML5 的离线存储是基于一个新建的.appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>如何使用：</p><ol><li>页面头部像下面一样加入一个 manifest 的属性；</li><li>在 cache.manifest 文件的编写离线存储的资源</li></ol><pre><code>CACHE MANIFEST#v1.0CACHE:js/app.jscss/style.cssNETWORK:assets/logo.pngFALLBACK:/html5/ /404.html</code></pre><h3 id="浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？"><a href="#浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？" class="headerlink" title="浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？"></a>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</h3><ul><li>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li><li>离线的情况下，浏览器就直接使用离线存储的资源。</li></ul><p>在离线状态时，操作 window.applicationCache 进行需求实现。</p><p>参考链接：<a href="https://yanhaijing.com/html/2014/12/28/html5-manifest/" target="_blank" rel="noopener">HTML5 离线缓存-manifest 简介</a></p><h3 id="iframe-有那些缺点？"><a href="#iframe-有那些缺点？" class="headerlink" title="iframe 有那些缺点？"></a>iframe 有那些缺点？</h3><ul><li>iframe 会阻塞主页面的 Onload 事件；</li><li>搜索引擎的检索程序无法解读这种页面，不利于 SEO;</li><li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li></ul><p>使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript</p><p>动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。</p><h3 id="Label-的作用是什么？是怎么用的？"><a href="#Label-的作用是什么？是怎么用的？" class="headerlink" title="Label 的作用是什么？是怎么用的？"></a>Label 的作用是什么？是怎么用的？</h3><p>label 标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p><pre><code class="html">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt; &lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;&lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</code></pre><h3 id="页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途？"></a>页面可见性（Page Visibility API） 可以有哪些用途？</h3><ul><li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li><li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</li></ul><h3 id="如何在页面上实现一个圆形的可点击区域？"><a href="#如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="如何在页面上实现一个圆形的可点击区域？"></a>如何在页面上实现一个圆形的可点击区域？</h3><ul><li>map+area 或者 svg</li><li>border-radius</li><li>纯 js 实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li></ul><h3 id="实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3><pre><code class="html">&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML/README</title>
    <link href="/uncategorized/HTML/README/"/>
    <url>/uncategorized/HTML/README/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML与浏览器"><a href="#HTML与浏览器" class="headerlink" title="HTML与浏览器"></a>HTML与浏览器</h1><h3 id="Doctype-作用？标准模式与兼容模式各有什么区别"><a href="#Doctype-作用？标准模式与兼容模式各有什么区别" class="headerlink" title="Doctype 作用？标准模式与兼容模式各有什么区别?"></a>Doctype 作用？标准模式与兼容模式各有什么区别?</h3><p>DOCTYPE是用来声明文档类型和DTD规范的。<br><code>&lt;!DOCTYPE html&gt;</code>声明位于HTML文档中的第一行，不是一个HTML标签，处于 html 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p><p>标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p><p>在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容<br>HTML5不基于SGML，所以不用指定DTD</p><h3 id="HTML-全局属性"><a href="#HTML-全局属性" class="headerlink" title="HTML 全局属性"></a>HTML 全局属性</h3><p>全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，即使属性可能对某些元素不起作用。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes" target="_blank" rel="noopener">全局属性 | MDN</a></p><h3 id="canvas和svg的区别"><a href="#canvas和svg的区别" class="headerlink" title="canvas和svg的区别"></a>canvas和svg的区别</h3><p>canvas是html5提供的新元素&lt;canvas&gt;，而svg存在的历史要比canvas久远，已经有十几年了。svg并不是html5专有的标签，最初svg是用xml技术（超文本扩展语言，可以自定义标签或属性）描述二维图形的语言。在H5中看似canvas与svg很像，但是，他们有巨大的差别。</p><p>首先，从它们的功能上来讲，canvas可以看做是一个画布。，其绘制出来的图形为<strong>标量图</strong>，因此，可以在canvas中引入jpg或png这类格式的图片，在实际开发中，大型的网络<strong>游戏</strong>都是用canvas画布做出来的，并且canvas的技术现在已经相当的成熟。另外，我们喜欢用canvas来做一些统计用的图表，如柱状图曲线图或饼状图等。<br>而svg，所绘制的图形为<strong>矢量图</strong>，所以其用法上受到了限制。因为只能绘制矢量图，所以svg中不能引入普通的图片，因为矢量图的不会失真的效果，在项目中我们会用来<strong>做小图标</strong>。但是由于其本质为矢量图，可以被无限放大而不会失真，这很适合被用来做地图，而百度地图就是用svg技术做出来的。</p><p>另外从技术发面来讲canvas里面绘制的图形不能被引擎抓取，如我们要让canvas里面的一个图片跟随鼠标事件: canvas.onmouseover=function(){}。<br>而svg里面的图形可以被引擎抓取，支持事件的绑定。另外canvas中我们绘制图形通常是通过javascript来实现，svg更多的是通过标签来来实现，如在svg中绘制正矩形形就要用<rect>，这里我们不能用属性style=”width:XXX;height:XXX;”来定义。</p><h3 id="行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><p>定义：CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值，如 div 的 display 默认值为“block”，则为“块级”元素；span 默认 display 属性值为“inline”，是“行内”元素。</p><ul><li>行内元素有：a b span img input select strong（强调的语气）</li><li>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</li><li>空元素：<ul><li>常见: br hr img input link meta</li><li>不常见: area base col command embed keygen param source track wbr</li></ul></li></ul><p>不同浏览器（版本）、HTML4（5）、CSS2 等实际略有差异<br>参考: <a href="http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements" target="_blank" rel="noopener">http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements</a></p><h3 id="页面导入样式时，使用-link-和-import-有什么区别？"><a href="#页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="页面导入样式时，使用 link 和@import 有什么区别？"></a>页面导入样式时，使用 link 和@import 有什么区别？</h3><ul><li>link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS, 定义 rel 连接属性等作用；而@import 是 CSS 提供的，只能用于加载 CSS;</li><li>页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载;</li><li>import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题;</li><li>link 支持使用 js 控制 DOM 去改变样式，而@import 不支持;</li></ul><h3 id="介绍一下你对浏览器内核的理解？"><a href="#介绍一下你对浏览器内核的理解？" class="headerlink" title="介绍一下你对浏览器内核的理解？"></a>介绍一下你对浏览器内核的理解？</h3><p>主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。</p><p>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后渲染到用户的屏幕上。</p><p>JS 引擎则：解析和执行 javascript 来实现逻辑和控制 DOM 进行交互。</p><p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><h3 id="HTML5变化"><a href="#HTML5变化" class="headerlink" title="HTML5变化"></a>HTML5变化</h3><ul><li><a href="http://www.w3school.com.cn/html/html5_new_elements.asp" target="_blank" rel="noopener">新的语义化元素</a><ul><li>header footer nav main article  section</li><li>删除了一些纯样式的标签</li></ul></li><li><a href="http://caibaojian.com/html5/form.html" target="_blank" rel="noopener">表单增强</a></li><li>新API<ul><li>离线 （applicationCache ）</li><li>音视频 （audio, vidio）</li><li>图形 （canvans）</li><li>实时通信（websoket）</li><li>本地存储（localStorage, indexDB）</li><li>设备能力（地图定位，手机摇一摇）</li></ul></li></ul><h3 id="em-与-i-的区别"><a href="#em-与-i-的区别" class="headerlink" title="em 与 i 的区别"></a>em 与 i 的区别</h3><ul><li>效果都是斜体</li><li>em 是语义化标签，表强调</li><li>i 是样式标签， 表斜体</li></ul><h3 id="哪些元素可以自闭合？"><a href="#哪些元素可以自闭合？" class="headerlink" title="哪些元素可以自闭合？"></a>哪些元素可以自闭合？</h3><ul><li>表单元素 input</li><li>img</li><li>br,  hr</li><li>meta, link</li></ul><h3 id="HTML和DOM的关系"><a href="#HTML和DOM的关系" class="headerlink" title="HTML和DOM的关系"></a>HTML和DOM的关系</h3><ul><li>HTML只是一个字符串</li><li>DOM由HTML解析而来</li><li>JS可以维护DOM</li></ul><h3 id="property和attribute的区别"><a href="#property和attribute的区别" class="headerlink" title="property和attribute的区别"></a>property和attribute的区别</h3><p>例如一个input标签 <code>&lt;input value=&quot;3&quot; /&gt;</code><br>他的attribute是3<br>但如果使用<code>input.value = 4</code> 或 直接修改值为4，这时再去getAttribute得到的还是”3”</p><h3 id="form-作用"><a href="#form-作用" class="headerlink" title="form 作用"></a>form 作用</h3><ul><li>直接提交表单</li><li>使用submit / reset按钮</li><li>便于浏览器保存表单</li><li>第三方库可以整体取值</li><li>第三方库可以进行表单验证</li></ul><h3 id="主流浏览器机器内核"><a href="#主流浏览器机器内核" class="headerlink" title="主流浏览器机器内核"></a>主流浏览器机器内核</h3><table><thead><tr><th>浏览器</th><th>内核</th><th>备注</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td>IE、猎豹安全、360 极速浏览器、百度浏览器</td></tr><tr><td>firefox</td><td>Gecko</td><td></td></tr><tr><td>Safari</td><td>webkit</td><td>从 Safari 推出之时起，它的渲染引擎就是 Webkit，一提到 webkit，首先想到的便是 chrome，Webkit 的鼻祖其实是 Safari。</td></tr><tr><td>chrome</td><td>Chromium/Blink</td><td>在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用 Blink 内核。二次开发</td></tr><tr><td>Opera</td><td>blink</td><td>Opera内核原为：Presto，现在跟随 chrome 用 blink 内核。</td></tr></tbody></table><h3 id="简述一下你对-HTML-语义化的理解？"><a href="#简述一下你对-HTML-语义化的理解？" class="headerlink" title="简述一下你对 HTML 语义化的理解？"></a>简述一下你对 HTML 语义化的理解？</h3><ul><li>用正确的标签做正确的事情。</li><li>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li><li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</li><li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li></ul><h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><ul><li>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li><li>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li><li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</li><li>存储大小：<ul><li>cookie 数据大小不能超过 4k。</li><li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li></ul></li><li>有效期（生命周期）：<ul><li>localStorage: 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li><li>sessionStorage: 数据在当前浏览器窗口关闭后自动删除。</li><li>cookie: 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li><li>共享<ul><li>sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享</li></ul></li></ul><h3 id="html-中-title-属性和-alt-属性的区别？"><a href="#html-中-title-属性和-alt-属性的区别？" class="headerlink" title="html 中 title 属性和 alt 属性的区别？"></a>html 中 title 属性和 alt 属性的区别？</h3><pre><code class="html">&lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; /&gt;</code></pre><p>当图片不输出信息的时候，会显示 alt 信息 鼠标放上去没有信息，当图片正常读取，不会出现 alt 信息。</p><pre><code class="html">&lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; title=&quot;title信息&quot; /&gt;</code></pre><ul><li>当图片不输出信息的时候，会显示 alt 信息 鼠标放上去会出现 title 信息；</li><li>当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。</li><li>除了纯装饰图片外都必须设置有意义的值，搜索引擎会分析。</li></ul><h3 id="另外还有一些关于-title-属性的知识："><a href="#另外还有一些关于-title-属性的知识：" class="headerlink" title="另外还有一些关于 title 属性的知识："></a>另外还有一些关于 title 属性的知识：</h3><ul><li>title 属性可以用在除了 base，basefont，head，html，meta，param，script 和 title 之外的所有标签。</li><li>title 属性的功能是提示。额外的说明信息和非本质的信息请使用 title 属性。title 属性值可以比 alt 属性值设置的更长。</li><li>title 属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。</li></ul><h3 id="为什么我们要弃用table标签？"><a href="#为什么我们要弃用table标签？" class="headerlink" title="为什么我们要弃用table标签？"></a>为什么我们要弃用table标签？</h3><p>table的缺点在于服务器把代码加载到本地服务器的过程中，本来是加载一行执行一行，但是table标签是里面的东西<strong>全都下载完之后才会显示出来</strong>，那么如果图片很多的话就会导致网页一直加载不出来，除非所有的图片和内容都加载完。如果要等到所有的图片全都加载完之后才显示出来的话那也太慢了，所以table标签现在我们基本放弃使用了。</p><h3 id="head-元素"><a href="#head-元素" class="headerlink" title="head 元素"></a>head 元素</h3><p>head子元素大概分为三类，分别是：</p><ul><li>描述网页基本信息的</li><li>指向渲染网页需要其他文件链接的</li><li>各大厂商根据自己需要定制的</li></ul><h4 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h4><p>一个网页，首先得有个标题，就跟人有名字一样。除此之外，还可以根据实际需要补充一些基本信息。</p><ul><li>文档标题（浏览器标签中显示的文本）：<title>深入了解 head 元素</title></li><li>编码格式：<meta charset="utf-8"> 如果你的页面出现乱码，那一般就是编码格式不对</li><li>视窗设置：<meta name="viewport" content="width=device-width, initial-scale=1.0"></li><li>搜索引擎优化相关内容： <meta name="description" content=“帮助你深层次了解HTML文档结构”></li><li>IE浏览器版本渲染设置：<meta http-equiv="X-UA-Compatible" content="ie=edge"></li></ul><h4 id="其他文件链接"><a href="#其他文件链接" class="headerlink" title="其他文件链接"></a>其他文件链接</h4><ul><li>CSS 文件：<link rel="stylesheet" type="text/css" href="style.css"></li><li>JavaScript 文件：&lt;script src=“script.js”&gt;</script></li></ul><p>但是为了让页面的样子更早的让用户看到，一般把JS文件放到body的底部</p><h4 id="厂商定制"><a href="#厂商定制" class="headerlink" title="厂商定制"></a>厂商定制</h4><p>同样分享页面到QQ的聊天窗口，有些页面直接就是一个链接，但是有些页面有标题，图片，还有文字介绍。为什么区别这么明显呢？其实就是看有没有设置下面这三个内容</p><pre><code class="html">&lt;meta itemprop=&quot;name&quot; content=&quot;这是分享的标题&quot;/&gt;&lt;meta itemprop=&quot;image&quot; content=&quot;http://imgcache.qq.com/qqshow/ac/v4/global/logo.png&quot; /&gt;&lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;这是要分享的内容&quot; /&gt;</code></pre><h3 id="移动端项目需要注意的4个问题"><a href="#移动端项目需要注意的4个问题" class="headerlink" title="移动端项目需要注意的4个问题"></a>移动端项目需要注意的4个问题</h3><h4 id="meta中设置viewport"><a href="#meta中设置viewport" class="headerlink" title="meta中设置viewport"></a>meta中设置viewport</h4><p>阻止用户手滑放大或缩小页面，需要在 index.html中添加meta元素,设置viewport。</p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;</code></pre><h4 id="CSS样式统一问题"><a href="#CSS样式统一问题" class="headerlink" title="CSS样式统一问题"></a>CSS样式统一问题</h4><p>我们需要重置页面样式，因为在不同的手机浏览器上，默认的css样式不是统一的。 解决方法：使用reset.css重置所有元素的默认样式</p><h4 id="一像素边框问题"><a href="#一像素边框问题" class="headerlink" title="一像素边框问题"></a>一像素边框问题</h4><p>有的手机分辨率比较高，是2倍屏或3倍屏，手机上的浏览器就会把CSS中的1像素值展示为2个或3个物理宽度 解决方法： 添加一个border.css库，将利用<strong>scroll缩放的原理</strong>将边框重置。当我们需要使用一像素边框时只需要在标签上添加对应类名，如设置底部一像素边框就在标签上加入”border-bottom”的class名</p><h4 id="300毫秒点击延迟问题"><a href="#300毫秒点击延迟问题" class="headerlink" title="300毫秒点击延迟问题"></a>300毫秒点击延迟问题</h4><p>在移动端开发中，某些机型上使用click事件会延迟300ms才执行，这样影响了用户体验。 解决方法： 引入<a href="https://www.jianshu.com/p/05b142d84780" target="_blank" rel="noopener">fastclick.js</a>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML/example</title>
    <link href="/uncategorized/HTML/example/"/>
    <url>/uncategorized/HTML/example/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <meta http-equiv="X-UA-Compatible" content="ie=edge">  <!-- 告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面。  -->  <title>Document</title><meta name="generator" content="Hexo 4.2.0"></head><body>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git/分支</title>
    <link href="/uncategorized/Git/%E5%88%86%E6%94%AF/"/>
    <url>/uncategorized/Git/%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h1><p>在进行提交操作时，Git 会保存一个提交对象（commit object）。</p><p>假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 <strong>blob 对象</strong>来保存它们），最终将校验和加入到暂存区域等待提。</p><p>当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在Git 仓库中这些校验和保存为<strong>树对象</strong>。 随后，Git 便会创建一个<strong>提交对象</strong>，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>常用操作</p><ul><li>创建分支<ul><li><code>git branch testing</code> </li><li>创建分支后，有一个名为 HEAD 的特殊指针指向当前所在的分支。</li></ul></li><li>分支切换<ul><li><code>git checkout testing</code> 让<code>HEAD</code>自己指针指向testing</li><li>如果在某分支修改了没有提交然后就切换分支，会有失败并有提示</li></ul></li><li>查看当前所处分支和各分支名<ul><li><code>git branch</code></li></ul></li><li>查看分支交叉情况<ul><li><code>git log --oneline --decorate --graph --all</code></li></ul></li><li>删除分支<ul><li><code>git branch -d hotfix</code></li></ul></li><li>分支合并<ul><li>切换到想要合并到的分支，将目标分支合并进来</li><li><code>git merge iss53</code></li></ul></li><li>查看每一个分支的最后一个提交<ul><li><code>git branch -v</code></li></ul></li><li>查看哪些分支 已经/没有 合并到当前分支<ul><li><code>git branch --merged</code></li><li><code>git branch --no-merged</code></li></ul></li></ul><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>分支创建后，主分支与分出去的分支都修改了同一个地方。</p><pre><code>CONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 </p><p>使用<code>git status</code>可以看到文件处于未合并（unmerged）状态。</p><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。需要手动解决冲突。看起来像下面这个样子：</p><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADmaster branch diff =======hhhhhhhhh &gt;&gt;&gt;&gt;&gt;&gt;&gt; testing</code></pre><p>在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 <strong>一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</strong></p><p>再使用<code>merge</code>操作提交更新就好。</p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。<br>远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p><p>它们以 (remote)/(branch) 形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支；但是在服务器上的分支会指向 origin/iss53 的提交。</p><ul><li>查看远程分支<ul><li><code>git remote</code></li></ul></li><li>同步远程到本地<ul><li><code>git fetch origin</code></li></ul></li><li>推送<ul><li><code>git push （remote） (branch)</code></li></ul></li><li><code>git pull</code><ul><li>在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。</li><li>通常单独显式地使用 fetch 与 merge 命令会更好一些</li></ul></li><li>删除远程分支<ul><li><code>git push origin --delete serverfix</code></li></ul></li></ul><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">变基</a></h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code>以及 <code>rebase</code>。</p><p>整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。<br><img src="../img/git-mergep.png" srcset="/img/loading.gif" alt=""></p><p>你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><pre><code>git checkout experimentgit rebase master</code></pre><p><img src="../img/git-rebease.png" srcset="/img/loading.gif" alt=""></p><p>最后回到 master 分支，进行一次快进合并<br><img src="../img/git-mergep2.png" srcset="/img/loading.gif" alt=""></p><p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。</p><p><code>merge</code>和<code>rebase</code>这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><h4 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h4><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong><br>如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git/README</title>
    <link href="/uncategorized/Git/README/"/>
    <url>/uncategorized/Git/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="Git-快照"><a href="#Git-快照" class="headerlink" title="Git 快照"></a>Git 快照</h3><blockquote><p>Every time you commit, or save the state of your project in Git, it basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot.</p></blockquote><p>Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个快照流。</p><blockquote><p>In computer systems, a snapshot is the state of a system at a particular point in time.</p></blockquote><p>记录差异<br><img src="../img/git-jlcy.png" srcset="/img/loading.gif" alt="记录差异"></p><p>记录快照<br><img src="../img/git-glkz.png" srcset="/img/loading.gif" alt="记录快照"></p><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><ul><li>已提交 committed</li><li>已暂存 staged</li><li>已修改 modified</li></ul><h3 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h3><ul><li>Git仓库<ul><li>是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</li></ul></li><li>暂存区域<ul><li>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。</li></ul></li><li>工作目录<ul><li>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li></ul></li></ul><p><img src="../img/git-3-place.png" srcset="/img/loading.gif" alt="三个区域"></p><h3 id="基本的-Git-工作流程"><a href="#基本的-Git-工作流程" class="headerlink" title="基本的 Git 工作流程"></a>基本的 Git 工作流程</h3><ol><li>在工作目录修改文件</li><li>暂存文件，将文件的快照放入暂存区</li><li>提交更新，找到暂存去文件，将快照永久性存储到 Git 仓库目录。</li></ol><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改。</p><pre><code>git config --global user.name &quot;huyaocode&quot;git config --global user.email johndoe@example.com</code></pre><h3 id="加入暂存区"><a href="#加入暂存区" class="headerlink" title="加入暂存区"></a>加入暂存区</h3><pre><code>git add 文件名或路径</code></pre><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>创建一个<code>.gitignore</code>文件，可描述需要忽略的文件。 参考</p><pre><code class="py"># no .a files*.a# but do track lib.a, even though you&#39;re ignoring .a files above!lib.a# 只忽略当前文件夹下已 TODO 为名的文件/TODO# 忽略当前目录下 build 这个文件夹build/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf</code></pre><h3 id="状态修改"><a href="#状态修改" class="headerlink" title="状态修改"></a>状态修改</h3><p><code>git status -s</code>将每个修改状态以一行展示，也可以用<code>git status</code>多行展示。</p><ul><li><code>A</code> 新添加到暂存区中的文件</li><li><code>M</code> 修改过的文件</li><li><code>D</code> 被删除的文件</li><li><code>MM</code> 出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。</li><li><code>??</code> 未跟踪</li></ul><h3 id="查看修改"><a href="#查看修改" class="headerlink" title="查看修改"></a>查看修改</h3><ul><li>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code></li><li>要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 或 <code>git diff --staged</code></li></ul><h3 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h3><p>运行<code>git commit</code>，会出现如下情况。这种方式会启动文本编辑器，开头还有一空行，供你输入提交说明。下面的行是被注释了的，也可以取消这些注释。</p><p>一般是vim 或 emacs。当然也可以按照 起步 介绍的方式，使用 <code>git config --global core.editor</code> 命令设定你喜欢的编辑软件。</p><p><img src="../img/git-commit.png" srcset="/img/loading.gif" alt="commit"></p><p>也可以使用<code>git commit -m &quot;修改描述&quot;</code> 这种直接输入描述的方式提交修改。</p><p> <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。<br>可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>运行 <code>git rm</code>记录此次移除文件的操作。下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，<br>这样的数据不能被 Git 恢复。</p><p>想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。(不想让Git跟踪)</p><pre><code>git rm --cached 某文件</code></pre><h3 id="文件更名"><a href="#文件更名" class="headerlink" title="文件更名"></a>文件更名</h3><pre><code>git mv file_from file_to</code></pre><p>其实，运行 git mv 就相当于运行了下面三条命令：</p><pre><code>mv README.md READMEgit rm README.mdgit add README</code></pre><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p><code>git log</code>git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p>使用 <code>-p</code> 用来限制展示条数。<code>git log -p -2</code></p><p>使用 <code>--stat</code> 选项看到每次提</p><p>使用<code>format</code>，定制要显示的记录格式。</p><p>使用<code>--graph</code>可形象地展示你的分支、合并历史。</p><pre><code>$ git log --pretty=format:&quot;%h %s&quot; --graph* 2d3acf9 ignore errors from SIGCHLD on trap* 5e3ee11 Merge branch &#39;master&#39; of git://github.com/dustin/grit|\| * 420eac9 Added a method for getting the current branch.* | 30e367c timeout code and tests* | 5a09431 add timeout protection to grit* | e1193f8 support for heads with slashes in them|/* d6016bc require time for xmlschema* 11d191e Merge branch &#39;defunkt&#39; into local</code></pre><h3 id="重新提交"><a href="#重新提交" class="headerlink" title="重新提交"></a>重新提交</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交。</p><pre><code>git commit --amend</code></pre><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><pre><code>git commit -m &#39;initial commit&#39;git add forgotten_filegit commit --amend</code></pre><p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>使用 <code>git reset HEAD &lt;file&gt;</code> 来取消暂存。在调用时加上 –hard 选项可以令 git reset 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！）</p><h3 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h3><p>使用<code>git checkout -- &lt;file&gt;</code> 可以撤销修改（未保存到暂存区）</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li>添加远程仓库<ul><li><code>git remote add &lt;shortname&gt; &lt;url&gt;</code></li></ul></li><li>从远程仓库中抓取与拉取<ul><li><code>git fetch [remote-name]</code></li></ul></li><li>推送到远程仓库<ul><li><code>git push [remote-name] [branch-name]</code></li></ul></li><li>查看远程仓库<ul><li><code>git remote show [remote-name]</code></li></ul></li><li>远程仓库的重命名<ul><li><code>git remote rename</code></li></ul></li></ul><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>Git 可以给历史中的某一个提交打上标签，以示重要。</p><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。通常建议创建附注标签。</p><ul><li>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</li><li>附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。</li></ul><p>列出标签<code>git tag</code></p><p>附注标签</p><ul><li>创建<ul><li><code>git tag -a v1.4 -m &#39;描述&#39;</code></li></ul></li><li>查看某版本<ul><li><code>git show 版本号</code></li></ul></li></ul><p>轻量标签</p><ul><li>轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息，不些描述</li><li><code>git tag v1.4-lw</code></li></ul><p>共享标签</p><ul><li>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 <code>git push origin [tagname]</code>。</li><li>如果想要一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</li></ul><p>删除标签</p><ul><li>删本地，并不会从任何远程仓库中移除这个标签<ul><li><code>git tag -d &lt;tagname&gt;</code></li></ul></li><li>删远程<ul><li><code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code></li></ul></li></ul><h3 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h3><p>可为一些操作器别名，例如： <code>git config --global alias.last &#39;log -1 HEAD&#39;</code>后， 使用<code>git last</code> 就可以看到最后一次提交</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/布局/圣杯布局</title>
    <link href="/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"/>
    <url>/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html>  <head>    <meta charset="utf-8" />    <title>实现三栏水平布局之圣杯布局</title>    <style type="text/css">      /*基本样式*/      .left, .right, .main {        min-height: 300px;      }      .left {        width: 200px;        background-color:thistle;      }      .main {        background-color: #999;      }      .right {        width: 300px;        background-color: violet;      }      /* 圣杯布局关键代码 */      .left, .main, .right {        float: left;        position: relative;      }      .main {        width: 100%;      }      .container {        padding-left: 200px;        padding-right: 300px;      }      .left {        margin-left: -100%;        left: -200px;      }      .right {        margin-left: -300px;        right: -300px;      }    </style>  <meta name="generator" content="Hexo 4.2.0"></head>  <body>    <div class="container">      <div class="main">main</div>      <div class="left">left</div>      <div class="right">right</div>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/布局/双飞翼布局</title>
    <link href="/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <url>/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>双飞翼布局</title>    <style>      .left,      .right,      .main {        min-height: 200px;      }      .left {        width: 200px;        background-color: thistle;      }      .main {        background: #999;      }      .right {        width: 300px;        background-color: violet;      }      /* 双飞翼布局重点 */      .left,      .main,      .right {        float: left;      }      .main {        width: 100%;      }      .main-inner {        margin-left: 200px;        margin-right: 300px;      }      .left {        margin-left: -100%;      }      .right {        margin-left: -300px;      }    </style>  <meta name="generator" content="Hexo 4.2.0"></head>  <body>    <div class="main"><div class="main-inner">中心区</div></div>    <div class="left">left</div>    <div class="right">right</div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/布局/三栏-表格布局</title>
    <link href="/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80/"/>
    <url>/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>表格布局</title>    <style>      * {        margin: 0;        padding: 0;      }      .wrapper {        display: table;        width: 100%;      }      .left,      .right,      .center {        min-height: 100px;        display: table-cell;      }      .left {        width: 300px;        background-color: red;      }      .center {        background-color: orange;      }      .right {        background-color: blue;        width: 300px;      }    </style>  <meta name="generator" content="Hexo 4.2.0"></head>  <body>    <div class="wrapper">      <aside class="left"></aside>      <main class="center">        <h1>表格布局</h1>        <p>父元素display: table;并且宽度为100%</p>        <p>每一个子元素display: table-cell; </p>        <p>左右两侧添加宽度，中间不加宽度</p>      </main>      <aside class="right"></aside>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/布局/三栏-网格布局</title>
    <link href="/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"/>
    <url>/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>网格布局</title>    <style>    * {        margin: 0;        padding: 0;      }      /* 网格布局 */      .wrapper {        display: grid;        width: 100%;        grid-template-columns: 300px 1fr 300px;      }            .left {        background-color: red;      }      .center {        background-color: orange;      }      .right {        background-color: blue;      }    </style>  <meta name="generator" content="Hexo 4.2.0"></head>  <body>    <div class="wrapper">      <aside class="left"></aside>      <main class="center">        <h1>表格布局</h1>        <p>父元素display: table;并且宽度为100%</p>        <p>每一个子元素display: table-cell;</p>        <p>左右两侧添加宽度，中间不加宽度</p>      </main>      <aside class="right"></aside>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/布局/三栏-绝对定位</title>
    <link href="/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D/"/>
    <url>/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>绝对定位三栏布局</title>    <style>      * {        margin: 0;        padding: 0;      }      aside {        position: absolute;        width: 300px;        min-height: 100px;      }      aside.left {        left: 0;        background-color: red;      }      aside.right {        right: 0;        background-color: blue;      }      main.center {        position: absolute;        left: 300px;        right: 300px;        background-color: orange;      }    </style>  <meta name="generator" content="Hexo 4.2.0"></head>  <body>    <aside class="left"></aside>    <aside class="right"></aside>    <main class="center">      <h1>绝对定位解决方案</h1>      <p>左右区域分别postion：absolute，固定到左右两边</p>      <p>中间区域postion：absolute；left：300px; right: 300px</p>      <p>给总的宽度加一个min-width，不然缩小窗口会有毛病</p>    </main>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/布局/三栏-浮动方案</title>
    <link href="/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-%E6%B5%AE%E5%8A%A8%E6%96%B9%E6%A1%88/"/>
    <url>/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-%E6%B5%AE%E5%8A%A8%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>Document</title>    <style>      * {        padding: 0;        margin: 0;      }      .left,      .right,      .center {        min-height: 100px;      }      .left {        background-color: red;        width: 200px;        float: left;      }      .right {        background-color: blue;        width: 200px;        float: right;      }      .center {        background-color: orange;        width: 100%;      }    </style>  <meta name="generator" content="Hexo 4.2.0"></head>  <body>    <aside class="left"></aside>    <aside class="right"></aside>    <main class="center">      <h1>浮动解决方案</h1>      <p>方法：left和right写在center前面，并且分别左右浮动；</p>      <p>        中间的这个div因为是块级元素，所以在水平方向上按照他的包容块自动撑开。      </p>      <p>简单，但是中心部分过长下面会溢出，然后文字就会跑到两边去。</p>    </main>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/布局/三栏-flex</title>
    <link href="/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-flex/"/>
    <url>/uncategorized/CSS/%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F-flex/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>Document</title>    <style>      * {        margin: 0;        padding: 0;      }      .left,      .right,      .center {        min-height: 100px;      }      .wrapper {        display: flex;      }      .left{        background-color: red;        width: 300px;      }      .center {        background-color: orange;        flex: 1;      }      .right {        background-color: blue;        width: 300px;      }    </style>  <meta name="generator" content="Hexo 4.2.0"></head>  <body>    <div class="wrapper">      <aside class="left"></aside>      <main class="center">        <h1>flex布局解决方案</h1>        <p>包裹这个3个块的父元素display: flex; 中间的元素flex: 1;</p>      </main>      <aside class="right"></aside>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/布局/README</title>
    <link href="/uncategorized/CSS/%E5%B8%83%E5%B1%80/README/"/>
    <url>/uncategorized/CSS/%E5%B8%83%E5%B1%80/README/</url>
    
    <content type="html"><![CDATA[<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex - 阮一峰 （语法篇）</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex - 阮一峰 （实战篇）</a></p><h2 id="grid网格布局"><a href="#grid网格布局" class="headerlink" title="grid网格布局"></a>grid网格布局</h2><p><a href="https://www.imooc.com/article/28513" target="_blank" rel="noopener">grid网格布局</a></p><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>假设高度已知，请写出三栏布局，其中左右栏宽300px,中间自适应</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p>要求：三列布局；中间宽度自适应，两边内容定宽。</p><p>好处：重要的内容放在文档流前面可以优先渲染</p><p>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</p><p>实现方式：</p><p>main部分首先要放在container的最前部分。然后是left,right</p><p>1.将三者都 float:left , 再加上一个position:relative (因为相对定位后面会用到）</p><p>2.main部分 width:100%占满</p><p>3.此时main占满了，所以要把left拉到最左边，使用margin-left:-100%</p><p>4.这时left拉回来了，但会覆盖main内容的左端，要把main内容拉出来，所以在外围container加上 padding:0 220px 0 200px</p><p>5.main内容拉回来了，right也跟着过来了，所以要还原，就对left使用相对定位 left:-200px  同理，right也要相对定位还原 right:-220px</p><p>6.到这里大概就自适应好了。如果想container高度保持一致可以给left main right都加上min-height:130px</p><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位。</p><p>左翅left有200px,右翅right..220px.. 身体main自适应未知</p><p>1.html代码中，main要放最前边，left  right</p><p>2.将main  left  right 都float:left</p><p>3.将main占满 width:100%</p><p>4.此时main占满了，所以要把left拉到最左边，使用margin-left:-100%  同理 right使用margin-left:-220px</p><p>（这时可以直接继续上边圣杯布局的步骤，也可以有所改动）</p><p>5.main内容被覆盖了吧，除了使用外围的padding，还可以考虑使用margin。</p><p>给main增加一个内层div– main-inner, 然后margin:0 220px 0 200px</p><h3 id="响应式设计和布局"><a href="#响应式设计和布局" class="headerlink" title="响应式设计和布局"></a>响应式设计和布局</h3><p>在不同设备上正常使用，一般主要处理屏幕大小问题</p><ul><li>隐藏 + 折行 + 自适应空间</li><li>rem做单位</li><li>viewport<ul><li>width=divice-width,</li></ul></li><li>媒体查询</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/布局/BFC两栏布局</title>
    <link href="/uncategorized/CSS/%E5%B8%83%E5%B1%80/BFC%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <url>/uncategorized/CSS/%E5%B8%83%E5%B1%80/BFC%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <meta http-equiv="X-UA-Compatible" content="ie=edge">  <title>BFC自适应两栏布局</title>  <style>    .left {      width: 200px;      height: 500px;      float: left;      background: #999;    }    .main {      height: 800px;      background: #aaa;      overflow: auto;      color: #fff;    }  </style><meta name="generator" content="Hexo 4.2.0"></head><body>  <div class="left"></div>  <div class="main">    <h1>BFC 两栏布局</h1>    <p>      左侧块浮动到左边，但是因为是浮动块，右侧块高度一旦超过左侧块后文字就会出现在左侧的下方，因为没有块把它挡住。    </p>    <p>解决办法： 让右侧块变为BFC文字就不会横过去。因为BFC元素不与Float元素相重叠。</p>  </div></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/水平居中/center4</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/center4/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/center4/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>水平元素居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .wrapper {      width: 80%;      height: 500px;      background: #888;    }    .center {      width: 500px;      position: relative;      left: 50%;      margin-left: -250px;      background-color: orange;    }  </style>  <body>    <div class="wrapper">      <div class="center">如果元素positon: relative。 那么 1）为元素设置宽度，2）偏移量设置为 50%，3）偏移方向外边距设置为元素宽度一半乘以-1</div>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/水平居中/center3</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/center3/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/center3/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>水平元素居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .wrapper {      width: 80%;      height: 500px;      background: #888;            position: relative;    }    .center {      width: 500px;      position: absolute;      left: 50%;      margin-left: -250px;      background-color: orange;    }  </style>  <body>    <div class="wrapper">      <div class="center">如果元素positon: absolute; 那么 0）设置父元素postion: relative 1）为元素设置宽度，2）偏移量设置为 50%，3）偏移方向外边距设置为元素宽度一半乘以-1</div>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/水平居中/center2</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/center2/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/center2/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>水平元素居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .wrapper {      width: 100%;      height: 500px;      text-align: center; /* 3 */    }    .center {      width: 500px;      text-align: left;       margin: 0 auto;       background-color: orange;    }  </style>  <body>    <div class="wrapper">      <div class="center">          父元素上设置 text-align: center;<br />          居中元素上margin 为 auto。      </div>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/水平居中/center1</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/center1/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/center1/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>水平元素居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .wrapper {      text-align: center;      height: 1000px;    }    .center {      display: inline-block;      width: 500px;      height: 200px;            background: orange;    }  </style>  <body>    <div class="wrapper">      <div class="center">如果需要居中的元素为常规流中 inline / inline-block 元素，为父元素设置 text-align: center;</div>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/垂直居中/center5</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center5/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center5/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>垂直居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .wrapper {      width: 1000px;      height: 600px;      background: #999;      display: flex;      justify-content: center;      align-items: center;    }    .center {      width: 18em;      height: 10em;      text-align: center;      background-color: orange;      color: #fff;    }  </style>  <body>    <div class="wrapper">      <div class="center">        使用flex居中<br/>        父元素 display: flex; <br/>        justify-content: center;<br/>        align-items: center;<br/>      </div>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/垂直居中/center4</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center4/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center4/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>垂直居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .wrapper {      width: 1000px;      height: 600px;      background: #999;      display: flex;    }    .center {      width: 18em;      height: 10em;      text-align: center;      background-color: orange;      color: #fff;      margin: auto;    }  </style>  <body>    <div class="wrapper">      <div class="center">        使用flex居中<br/>        父元素 display: flex; <br/>        居中块： margin: auto;      </div>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/垂直居中/center3</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center3/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center3/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>垂直居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .center {      width: 18em;      height: 10em;      text-align: center;      background-color: orange;      color: #fff;      position: absolute;      top: 50%;      left: 50%;      transform: translate(-50%, -50%);    }  </style>  <body>    <div class="center">        不要求原生有固定的宽高。<br/>        position: absolute;<br/>        top和left 为 50%;<br/>        transform: translate(-50%, -50%);    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/垂直居中/center2</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center2/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center2/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>垂直居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .center {      width: 18em;      height: 10em;      text-align: center;      background-color: orange;      color: #fff;      position: absolute;      top: calc(50% - 5em);      left: calc(50% - 9em);    }  </style>  <body>    <div class="center">        要求原生有固定的宽高。<br/>        position: absolute;<br/>        top 为 calc(50% 剪 一半高)        left 为 calc(50% 剪 一半宽)    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/垂直居中/center1</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center1/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center1/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>垂直居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .center {      width: 18em;      height: 10em;      text-align: center;      background-color: orange;      color: #fff;      position: absolute;      top: 50%;      left: 50%;      margin-left: -9rem;      margin-top: -5rem;    }  </style>  <body>    <div class="center">        要求原生有固定的宽高。<br/>        position: absolute;<br/>        top和left 为 50%;<br/>        margin上为高的一半<br/>        margin左为宽的一半<br/>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/垂直居中/center-in-body</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center-in-body/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/center-in-body/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>垂直居中</title>  <meta name="generator" content="Hexo 4.2.0"></head>  <style>    .wrapper {      overflow: hidden;      width: 1000px;      height: 500px;      background: #999;    }    .center {      width: 18em;      height: 10em;      text-align: center;      background-color: orange;      color: #fff;      margin: 50vh auto;      transform: translateY(-50%);    }      </style>  <body>    <div class="wrapper">      <div class="center">        基于视口的垂直居中<br />        不要求原生有固定的宽高。<br />        但是这种居中是在整个页面窗口内居中，不是基于父元素<br />      </div>    </div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/居中元素/README</title>
    <link href="/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/README/"/>
    <url>/uncategorized/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/README/</url>
    
    <content type="html"><![CDATA[<h1 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h1><h3 id="如何竖直居中一个元素"><a href="#如何竖直居中一个元素" class="headerlink" title="如何竖直居中一个元素"></a>如何竖直居中一个元素</h3><p>参考代码: <a href="https://github.com/huyaocode/webKnowledge/tree/master/CSS/%E5%B1%85%E4%B8%AD%E5%85%83%E7%B4%A0/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD" target="_blank" rel="noopener">CSS/居中元素/垂直居中</a></p><h4 id="被居中元素宽高固定"><a href="#被居中元素宽高固定" class="headerlink" title="被居中元素宽高固定"></a>被居中元素宽高固定</h4><ol><li><p>绝对定位，top和left 为 50%， margin的left和top为自身宽高一半</p><pre><code class="css">.center {position: absolute;top: 50%;left: 50%;margin-left: -9rem;margin-top: -5rem;}</code></pre></li><li><p>绝对定位，top和lefe为父元素一半剪自身一半</p><pre><code class="css">.center {position: absolute;top: calc(50% - 5em);left: calc(50% - 9em);}</code></pre></li></ol><h4 id="被居中元素宽高不定"><a href="#被居中元素宽高不定" class="headerlink" title="被居中元素宽高不定"></a>被居中元素宽高不定</h4><ol start="3"><li><p>使用CSS3 的 <code>transform</code>将位置在中心点平移自身宽高一半</p><pre><code class="css">.center {position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);}</code></pre></li><li><p>使用flex布局居中</p><pre><code class="css">.wrapper {display: flex;}.center {margin: auto;}</code></pre></li><li><p>flex布局，父元素指定子元素居中。</p><pre><code class="css">.wrapper {display: flex;align-items: center;justify-content: center;}</code></pre></li></ol><h4 id="在浏览器窗口中居中"><a href="#在浏览器窗口中居中" class="headerlink" title="在浏览器窗口中居中"></a>在浏览器窗口中居中</h4><p>基于视口的垂直居中。不要求原生有固定的宽高，但是这种居中是在整个页面窗口内居中，不是基于父元素</p><pre><code class="css">.center{  margin: 50vh auto;  transform: translateY(-50%);}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/动画/transition</title>
    <link href="/uncategorized/CSS/%E5%8A%A8%E7%94%BB/transition/"/>
    <url>/uncategorized/CSS/%E5%8A%A8%E7%94%BB/transition/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <meta http-equiv="X-UA-Compatible" content="ie=edge">  <title>01-transition</title>  <style>  #one{    width: 50px;    height: 50px;    background-color: orange;    transition: width 1s, background 2s;    transition-delay: 1s;    /* transition-duration:  */  }  #one:hover{    width: 500px;    background: blue;  }  </style><meta name="generator" content="Hexo 4.2.0"></head><body>  <div id="one"></div></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/动画/README</title>
    <link href="/uncategorized/CSS/%E5%8A%A8%E7%94%BB/README/"/>
    <url>/uncategorized/CSS/%E5%8A%A8%E7%94%BB/README/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h1><ul><li>位置 - 平移</li><li>方向 - 旋转</li><li>大小 - 缩放</li><li>透明度</li><li>其他 - 线形变换</li></ul><h3 id="前端动画怎么做"><a href="#前端动画怎么做" class="headerlink" title="前端动画怎么做"></a>前端动画怎么做</h3><ul><li>animation过渡动画</li><li>transition过渡动画</li><li>JS原生控制DOM位置</li><li>canvas绘制动画</li></ul><h3 id="transition-过渡动画"><a href="#transition-过渡动画" class="headerlink" title="transition 过渡动画"></a>transition 过渡动画</h3><p>用来控制过渡的时间，使用过渡的属性，过渡效果曲线，过渡的延时</p><p>要求元素的状态必须有变化，即某CSS值变化时发生的动画</p><ul><li>transition-property   <ul><li>规定设置过渡效果的 CSS 属性的名称。</li></ul></li><li>transition-duration   <ul><li>规定完成过渡效果需要多少秒或毫秒。</li></ul></li><li>transition-timing-function      <ul><li>规定速度效果的速度曲线。</li></ul></li><li>transition-delay      <ul><li>定义过渡效果何时开始</li></ul></li></ul><p>在chrome的调试窗口按下esc在下面出现一个框框，选择 animation就可以看到动画面板了</p><pre><code class="css">div{  width:100px;  height:100px;  background:blue;  transition:width 2s, background 1s;}div:hover{  background:orange;  width:300px;}</code></pre><h3 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h3><ul><li>ease  慢速开始，然后变快，然后慢速结束</li><li>ease-in 慢速开始</li><li>ease-out 慢结束</li><li>ease-in-out </li><li>linear</li><li>cubic-bezier(a,b,c,d)</li></ul><p>bezier曲线在线效果网址 <a href="http://cubic-bezier.com" target="_blank" rel="noopener">cubic-bezier.com</a></p><h3 id="animation-关键帧动画"><a href="#animation-关键帧动画" class="headerlink" title="animation 关键帧动画"></a>animation 关键帧动画</h3><p>相当于多个补间动画组合到一起</p><p>与transition不同的是，他可以让元素自己动，而不要求某值的改变来触发动画</p><p><code>animation: name duration timing-function delay iteration-count direction;</code></p><ul><li>animation-name<ul><li>规定需要绑定到选择器的 keyframe 名称。</li></ul></li><li>animation-duration<ul><li>规定完成动画所花费的时间，以秒或毫秒计</li></ul></li><li>animation-timing-function<ul><li>动画的速度曲线</li></ul></li><li>animation-delay<ul><li>动画开始之前的延迟</li></ul></li><li>animation-iteration-count<ul><li>n | infinit</li><li>动画应该播放的次数</li></ul></li><li>animation-direction<ul><li>normal | alternate</li><li>是否应该轮流反向播放动画</li></ul></li><li>animation-play-state<ul><li>可用于暂停动画</li></ul></li><li>animation-fill-mode <ul><li>forwards 动画停了就保持最后的那个状态</li><li>backwards 动画停了还得反着做一遍回去</li><li>在动画执行之前和之后如何给动画的目标应用样式。</li></ul></li></ul><pre><code class="css">#one{  width: 50px;  height: 50px;  background-color: orange;  animation: run;  animation-delay: 0.5s;  animation-duration: 2s;  animation-fill-mode: forwards;}@keyframes run {  0%{    width: 100px;  }  50%{    width: 400px;    background-color: blue;  }  100% {    width: 800px;  }}</code></pre><h3 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h3><p>关键帧之间是有补间的，会选一个效果过渡过去，而逐帧动画则是每个keyframe之间没有过渡，直接切换过去<br>参考<a href="./animal.html">猎豹奔跑</a><br>关键是使用下面这行CSS<br><code>animation-timing-function: steps(1);</code><br>这个step是指定关键帧之间需要有几个画面</p><h3 id="过渡动画和关键帧动画的区别"><a href="#过渡动画和关键帧动画的区别" class="headerlink" title="过渡动画和关键帧动画的区别"></a>过渡动画和关键帧动画的区别</h3><ul><li>过渡动画需要有状态变化</li><li>关键帧动画不需要状态变化</li><li>关键帧动画能控制更精细</li></ul><h3 id="CSS动画的性能"><a href="#CSS动画的性能" class="headerlink" title="CSS动画的性能"></a>CSS动画的性能</h3><ul><li>CSS动画不差</li><li>部分情况下优于JS</li><li>JS可以做到更精细</li><li>含高危属性，会让性能变差 (如box-shadow)</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/动画/animation</title>
    <link href="/uncategorized/CSS/%E5%8A%A8%E7%94%BB/animation/"/>
    <url>/uncategorized/CSS/%E5%8A%A8%E7%94%BB/animation/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <meta http-equiv="X-UA-Compatible" content="ie=edge">  <title>animation</title>  <style>  #one{    width: 50px;    height: 50px;    background-color: orange;    animation: run;    animation-delay: 0.5s;    animation-duration: 2s;    animation-fill-mode: forwards;  }  @keyframes run {    0%{      width: 100px;    }    50%{      width: 400px;      background-color: blue;    }    100% {      width: 800px;    }  }  </style><meta name="generator" content="Hexo 4.2.0"></head><body>  <div id="one"></div></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/动画/animal</title>
    <link href="/uncategorized/CSS/%E5%8A%A8%E7%94%BB/animal/"/>
    <url>/uncategorized/CSS/%E5%8A%A8%E7%94%BB/animal/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        .container{            width: 100px;            height: 100px;            border: 1px solid red;            background: url(./animal.png) no-repeat;            animation: run 1s infinite;            animation-timing-function: steps(1);        }        @keyframes run{            0%{                background-position: 0 0;            }            12.5%{                background-position: -100px 0;            }            25%{                background-position: -200px 0;            }            37.5%{                background-position: -300px 0;            }            50%{                background-position: 0 -100px;            }            62.5%{                background-position: -100px -100px;            }            75%{                background-position: -200px -100px;            }            87.5%{                background-position: -300px -100px;            }            100%{                background-position: 0 0;            }        }    </style><meta name="generator" content="Hexo 4.2.0"></head><body>    <div class="container">    </div></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/其他题目</title>
    <link href="/uncategorized/CSS/%E5%85%B6%E4%BB%96%E9%A2%98%E7%9B%AE/"/>
    <url>/uncategorized/CSS/%E5%85%B6%E4%BB%96%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度"><a href="#一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度" class="headerlink" title="一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度"></a>一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度</h3><ul><li>方案 1： .sub { height: calc(100%-100px); }</li><li>方案 2： .container { position:relative; } .sub { position: absolute; top: 100px; bottom: 0; }</li><li>方案 3： .container { display:flex; flex-direction:column; } .sub { flex:1; }</li></ul><h3 id="为什么要初始化-CSS-样式？"><a href="#为什么要初始化-CSS-样式？" class="headerlink" title="为什么要初始化 CSS 样式？"></a>为什么要初始化 CSS 样式？</h3><ul><li>不同浏览器对有些标签样式的默认值解析不同</li><li>不初始化 CSS 会造成各现浏览器之间的页面显示差异</li><li>可以使用 reset.css 或 Normalize.css 做 CSS 初始化</li></ul><h3 id="Normalize-css-理解"><a href="#Normalize-css-理解" class="headerlink" title="Normalize.css 理解"></a>Normalize.css 理解</h3><p>Normalize.css 是一种现代的，为 HTML5 准备的优质替代方案。<br>创造 normalize.css 有下几个目的：</p><ul><li>保护有用的浏览器默认样式而不是完全去掉它们</li><li>一般化的样式：为大部分 HTML 元素提供</li><li>修复浏览器自身的 bug 并保证各浏览器的一致性</li><li>优化 CSS 可用性：用一些小技巧</li><li>解释代码：用注释和详细的文档来</li></ul><p>参考：<a href="https://www.jianshu.com/p/9d7ff89757fd" target="_blank" rel="noopener">谈一谈 Normalize.css</a></p><h3 id="什么是-FOUC-Flash-of-Unstyled-Content-？-如何来避免-FOUC？"><a href="#什么是-FOUC-Flash-of-Unstyled-Content-？-如何来避免-FOUC？" class="headerlink" title="什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？"></a>什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？</h3><ul><li>当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象： 没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为 FOUC</li><li>产生原因：当样式表晚于结构性 html 加载时，加载到此样式表时，页面将停止之前的渲染。</li><li>等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</li><li>解决方法：使用 link 标签将样式表放在文档 head</li></ul><h3 id="介绍使用过的-CSS-预处理器"><a href="#介绍使用过的-CSS-预处理器" class="headerlink" title="介绍使用过的 CSS 预处理器"></a>介绍使用过的 CSS 预处理器</h3><p>CSS 预处理器基本思想：<br>    为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等）</p><p>行 Web 页面样式设计，再编译成正常的 CSS 文件使用.</p><p><a href="https://www.sass.hk/guide/" target="_blank" rel="noopener">sass</a>, <a href="http://lesscss.cn" target="_blank" rel="noopener">less</a>, <a href="http://stylus-lang.com/" target="_blank" rel="noopener">stylus</a></p><ul><li>变量 (定义主题色)</li><li>函数  (计算值)</li><li>混合器 （代码段的复用）</li><li>父级选择器 </li></ul><h3 id="抽离样式模块怎么写，说出思路？"><a href="#抽离样式模块怎么写，说出思路？" class="headerlink" title="抽离样式模块怎么写，说出思路？"></a>抽离样式模块怎么写，说出思路？</h3><p>CSS 可以拆分成 2 部分：公共 CSS 和 业务 CSS：</p><ul><li>网站的配色，字体，交互提取出为公共 CSS。这部分 CSS 命名不应涉及具体的业务</li><li>对于业务 CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的 CSS</li></ul><h3 id="什么是视差滚动效果，如何给每页做不同的动画？"><a href="#什么是视差滚动效果，如何给每页做不同的动画？" class="headerlink" title="什么是视差滚动效果，如何给每页做不同的动画？"></a>什么是视差滚动效果，如何给每页做不同的动画？</h3><ul><li>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验</li><li>一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的</li></ul><p>实现原理</p><ul><li>以 “页面滚动条” 作为 “视差动画进度条”</li><li>以 “滚轮刻度” 当作 “动画帧度” 去播放动画的</li><li>监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果</li></ul><h3 id="如果设计中使用了非标准的字体，你该如何去实现？"><a href="#如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="如果设计中使用了非标准的字体，你该如何去实现？"></a>如果设计中使用了非标准的字体，你该如何去实现？</h3><ul><li>用图片代替</li><li>web fonts 在线字库</li><li>@font-face</li></ul><p>参考链接：<a href="https://blog.csdn.net/xujie_0311/article/details/42368371" target="_blank" rel="noopener">如果设计中使用了非标准的字体，你该如何去实现？</a></p><h3 id="请问为何要使用-transform-而非-absolute-positioning，或反之的理由？为什么？"><a href="#请问为何要使用-transform-而非-absolute-positioning，或反之的理由？为什么？" class="headerlink" title="请问为何要使用 transform 而非 absolute positioning，或反之的理由？为什么？"></a>请问为何要使用 transform 而非 absolute positioning，或反之的理由？为什么？</h3><ul><li>使用 transform 或 position 实现动画效果时是有很大差别。</li><li>使用 transform 时，可以让 GPU 参与运算，动画的 FPS 更高。</li><li>使用 position 时，最小的动画变化的单位是 1px，而使用 transform 参与时，可以做到更小（动画效果更加平滑）</li><li>功能都一样。但是 translate 不会引起浏览器的重绘和重排，这就相当 nice 了。</li></ul><p>反之</p><ul><li>transform 改变 fixed 子元素的定位对象</li><li>transform 改变元素层叠顺序<br><a href="http://imweb.io/topic/5a23e1f1a192c3b460fce26e" target="_blank" rel="noopener">transform 的副作用</a></li></ul><h3 id="怎么让-Chrome-支持小于-12px-的文字？"><a href="#怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="怎么让 Chrome 支持小于 12px 的文字？"></a>怎么让 Chrome 支持小于 12px 的文字？</h3><pre><code class="css">  .shrink{    -webkit-transform:scale(0.8);    -o-transform:scale(1);    display:inline-block;  }</code></pre><h3 id="font-style-属性-oblique-是什么意思？"><a href="#font-style-属性-oblique-是什么意思？" class="headerlink" title="font-style 属性 oblique 是什么意思？"></a>font-style 属性 oblique 是什么意思？</h3><p>font-style: oblique; 使没有 italic 属性的文字实现倾斜</p><h3 id="如果需要手动写动画，你认为最小时间间隔是多久？"><a href="#如果需要手动写动画，你认为最小时间间隔是多久？" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久？"></a>如果需要手动写动画，你认为最小时间间隔是多久？</h3><p>16.7ms</p><h3 id="如何修改-Chrome-记住密码后自动填充表单的黄色背景？"><a href="#如何修改-Chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="如何修改 Chrome 记住密码后自动填充表单的黄色背景？"></a>如何修改 Chrome 记住密码后自动填充表单的黄色背景？</h3><ul><li>产生原因：由于 Chrome 默认会给自动填充的 input 表单加上 input:-webkit-autofill 私有属性造成的</li><li>解决方案 1：在 form 标签上直接关闭了表单的自动填充：autocomplete=”off”</li><li>解决方案 2：input:-webkit-autofill { background-color: transparent; }</li></ul><p>input [type=search] 搜索框右侧小图标如何美化？</p><pre><code class="css">input[type=&quot;search&quot;]::-webkit-search-cancel-button{  -webkit-appearance: none;  height: 15px;  width: 15px;  border-radius: 8px;  background:url(&quot;images/searchicon.png&quot;) no-repeat 0 0;  background-size: 15px 15px;}</code></pre><h3 id="网站图片文件，如何点击下载？而非点击预览？"><a href="#网站图片文件，如何点击下载？而非点击预览？" class="headerlink" title="网站图片文件，如何点击下载？而非点击预览？"></a>网站图片文件，如何点击下载？而非点击预览？</h3><pre><code class="html">&lt;a href=&quot;logo.jpg&quot; download&gt;下载&lt;/a&gt; &lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载&lt;/a&gt;</code></pre><h3 id="如何优化网页的打印样式"><a href="#如何优化网页的打印样式" class="headerlink" title="如何优化网页的打印样式"></a>如何优化网页的打印样式</h3><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;xxx.css&quot; /&gt;其中 media 指定的属性就是设备，显示器上就是 screen，打印机则是 print，电视是 tv，投影仪是 projection。```html &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;print&quot; href=&quot;yy</code></pre><p>但打印样式表也应有些注意事项：</p><ul><li>打印样式表中最好不要用背景图片，因为打印机不能打印 CSS 中的背景。如要显示图片，请使用 html 插入到页面中。</li><li>最好不要使用像素作为单位，因为打印样式表要打印出来的会是实物，所以建议使用 pt 和 cm。</li><li>隐藏掉不必要的内容。（@print div{display:none;}）</li><li>打印样式表中最好少用浮动属性，因为它们会消失。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/README</title>
    <link href="/uncategorized/CSS/README/"/>
    <url>/uncategorized/CSS/README/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>Cascading Style Sheet 层叠样式表</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a><a href="./CSS选择器.md">CSS选择器</a></h3><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>盒模型有两种， IE 怪异盒子模型、W3C标准盒子模型；</p><p>盒模型是由： 内容(content)、内边距(padding)、边框(border)、外边距(margin) 组成的。</p><p>标准模型的宽高是指的content区宽高；<br>IE盒模型的宽高是指的content+padding+border的宽高。</p><p><img src="../img/stadardBox.png" srcset="/img/loading.gif" alt="W3C盒模型"></p><p><img src="../img/strangeBox.png" srcset="/img/loading.gif" alt="IE盒模型"></p><h3 id="CSS如何设置这两种盒模型？"><a href="#CSS如何设置这两种盒模型？" class="headerlink" title="CSS如何设置这两种盒模型？"></a>CSS如何设置这两种盒模型？</h3><p>标准盒模型：</p><pre><code>box-sizing: content-box;</code></pre><p>怪异盒模型：</p><pre><code>box-sizing: border-box;</code></pre><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><a href="https://www.cnblogs.com/libin-1/p/7098468.html" target="_blank" rel="noopener">什么是BFC</a></p><p>W3C对BFC定义：</p><blockquote><p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p></blockquote><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p><p>BFC作用：</p><ol><li>利用BFC避免外边距折叠</li><li>清除内部浮动 （撑开高度）<ol><li>原理: 触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内</li></ol></li><li>避免文字环绕</li><li>分属于不同的BFC时，可以阻止margin重叠</li><li>多列布局中使用BFC</li></ol><p>如何生成BFC：（脱离文档流，满足下列的任意一个或多个条件即可）</p><ol><li>根元素，即HTML元素（最大的一个BFC）</li><li>float的值不为none</li><li>position的值为absolute或fixed</li><li>overflow的值不为visible（默认值。内容不会被修剪，会呈现在元素框之外）</li><li>display的值为inline-block、table-cell、table-caption</li></ol><p>BFC布局规则：</p><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>属于同一个BFC的两个相邻的Box的margin会发生重叠</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此, 文字环绕效果，设置float</li><li>BFC的区域不会与float box重叠。</li><li>计算BFC的高度，浮动元素也参与计算</li></ol><h3 id="BFC、IFC、GFC-和-FFC"><a href="#BFC、IFC、GFC-和-FFC" class="headerlink" title="BFC、IFC、GFC 和 FFC"></a>BFC、IFC、GFC 和 FFC</h3><ul><li><p>BFC（Block formatting contexts）：块级格式上下文</p></li><li><p>IFC（Inline formatting contexts）：内联格式上下文</p></li><li><p>GFC（GrideLayout formatting contexts）：网格布局格式化上下文</p></li><li><p>FFC（Flex formatting contexts）:自适应格式上下文</p></li></ul><h3 id="非布局样式"><a href="#非布局样式" class="headerlink" title="非布局样式"></a>非布局样式</h3><ul><li>字体、字重、颜色、大小、行高</li><li>背景、边框</li><li>滚动、换行</li><li>粗体、斜体、下划线</li><li>其他</li></ul><h3 id="行高的构成"><a href="#行高的构成" class="headerlink" title="行高的构成"></a>行高的构成</h3><ul><li>行高是由 line-box 组成的</li><li>line-box 是由一行里的 inline-box 组成的</li><li>inline-box中最高的那个，或字体最大的拿个决定行高</li></ul><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul><li>元素”浮动”</li><li>脱离文档流</li><li>不脱离文本流</li><li>位置尽量靠上，并靠左或右</li></ul><p>对自己的影响</p><ul><li>形成”块”(BFC)</li><li>这个块会负责自己的布局，宽高由自己决定</li></ul><p>比如 span 中用 float 这个span就形成了一个BFC，就可以设置宽高了</p><p>对兄弟元素的影响</p><ul><li>上面一般贴非float元素</li><li>靠边贴float元素或边</li><li>不影响其他块级元素位置</li><li>影响其他块级元素文本</li></ul><p>对父级元素的影响</p><ul><li>从布局上”消失”</li><li>高度塌陷</li></ul><h3 id="清楚浮动"><a href="#清楚浮动" class="headerlink" title="清楚浮动"></a>清楚浮动</h3><p>浮动的元素布局时不会占据父元素的布局空间，即父元素布局时不会管浮动元素，浮动元素有可能超出父元素，从而对其他元素造成影响。</p><p>方法一：让父元素变为一个BFC。<br>父元素 overflow: auto/hidden。 让父元素去关注里面的高度。<br>必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度</p><p>方法二： 使用伪元素清楚浮动</p><pre><code class="css">.container::after {  content: &quot; &quot;;  clear: both;  display: block;  visibility: hidden;  height: 0;}</code></pre><h3 id="inline-block的间隙"><a href="#inline-block的间隙" class="headerlink" title="inline-block的间隙"></a>inline-block的间隙</h3><p>两个并列的inline-block中间会有一条裂缝，这个的原因是两个标签之间有空格，浏览器把这些空格当成文字中空格，所以这两个块中间多少有间隙。</p><p>解决办法：</p><ol><li>删除两个标签间的空格，但是这样html排版不好</li><li>容器元素font-size: 0 然后再在里面再重新设置字体大小</li></ol><h3 id="你对-line-height-是如何理解的？"><a href="#你对-line-height-是如何理解的？" class="headerlink" title="你对 line-height 是如何理解的？"></a>你对 line-height 是如何理解的？</h3><ul><li>line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中</li><li>line-height 和 height 都能撑开一个高度，height 会触发 haslayout（一个低版本IE的东西），而 line-height 不会</li></ul><h3 id="line-height-三种赋值方式有何区别？（带单位、纯数字、百分比）"><a href="#line-height-三种赋值方式有何区别？（带单位、纯数字、百分比）" class="headerlink" title="line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）"></a>line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）</h3><ul><li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li><li>百分比：将计算后的值传递给后代</li></ul><h3 id="图片下面有一个缝隙是因为什么"><a href="#图片下面有一个缝隙是因为什么" class="headerlink" title="图片下面有一个缝隙是因为什么"></a>图片下面有一个缝隙是因为什么</h3><p><img src="../img/imgbottom.png" srcset="/img/loading.gif" alt="fenxi"></p><p>因为 img 也相当于一个 inline 的元素， inline 就要遵守行高的构成，它会按照base基线对齐，基线对齐的话那么它就会和底线间有一个缝隙。</p><p>如何解决： 因为它会遵守文字对齐方案，那么就把图片的对齐方式修改为 <code>vertical-align: bottom</code>。或者让他<code>display: block</code>，这样图片虽然会换行，但是没有间隙了。</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul><li>边框的属性： 线型、大小、颜色</li><li>边框背景图</li><li>边框衔接</li></ul><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><ul><li>visible 滚动条隐藏, 文字超出显示</li><li>hidden  滚动条隐藏, 文字超出不显示</li><li>scroll  滚动条一直显示，无论文字是否够多</li><li>auto    滚动条自动隐藏</li></ul><h3 id="文字折行"><a href="#文字折行" class="headerlink" title="文字折行"></a>文字折行</h3><ul><li>overflow-wrap(word-wrap)通用换行控制<ul><li>是否保留单词</li></ul></li><li>word-break 针对多字节文本文字<ul><li>中文句子也是单词</li></ul></li><li>white-space 空白处是否换行</li></ul><h3 id="装饰属性及其他"><a href="#装饰属性及其他" class="headerlink" title="装饰属性及其他"></a>装饰属性及其他</h3><ul><li>字重（粗体） font-weight</li><li>斜体  font-style: itatic</li><li>下划线   text-decoration</li><li>指针  cursor</li></ul><h3 id="CSS-Hack"><a href="#CSS-Hack" class="headerlink" title="CSS Hack"></a>CSS Hack</h3><p>在一部分不合法，但是在某些浏览器上生效的写法就叫CSS Hack，一般用来兼容老的浏览器， 缺点是难理解、难维护、易失效</p><p>替代方案： </p><ul><li>特征检测</li><li>针对性的加class<ul><li>比如第一步检测是IE6，那么只需要添加一个专门的 class 名来兼容IE6就好</li></ul></li></ul><p>写Hack时需要注意</p><ul><li>标准属性写在前面， hack代码写在后面</li></ul><h3 id="单行文本溢出显示省略号"><a href="#单行文本溢出显示省略号" class="headerlink" title="单行文本溢出显示省略号"></a>单行文本溢出显示省略号</h3><pre><code class="css">overflow: hidden;text-overflow: ellipsis;white-space: no-wrap;</code></pre><h3 id="多行文本溢出显示省略号"><a href="#多行文本溢出显示省略号" class="headerlink" title="多行文本溢出显示省略号"></a>多行文本溢出显示省略号</h3><pre><code class="css">overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical;</code></pre><h3 id="display-none-与-visibility-hidden-的区别"><a href="#display-none-与-visibility-hidden-的区别" class="headerlink" title="display: none; 与 visibility: hidden; 的区别"></a>display: none; 与 visibility: hidden; 的区别</h3><p>结构：</p><ul><li>display:none<ul><li>会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，</li></ul></li><li>visibility: hidden<ul><li>不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击 </li></ul></li><li>opacity: 0<ul><li>不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</li></ul></li></ul><p>继承</p><ul><li>display: none和opacity: 0<ul><li>非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。</li></ul></li><li>visibility: hidden<ul><li>继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。</li></ul></li></ul><p>性能</p><ul><li>display:none<ul><li>修改元素会造成文档回流。读屏器不会读取display: none元素内容，性能消耗较大</li></ul></li><li>visibility:hidden<ul><li>修改元素只会造成本元素的重绘,性能消耗较少。读屏器读取visibility: hidden元素内容</li></ul></li><li>opacity: 0<ul><li>修改元素会造成重绘，性能消耗较少</li></ul></li></ul><p>相同点： 它们都能让元素不可见、他们都依然可以被 JS 所获取到</p><h3 id="外边距折叠-collapsing-margins"><a href="#外边距折叠-collapsing-margins" class="headerlink" title="外边距折叠(collapsing margins)"></a>外边距折叠(collapsing margins)</h3><p>外边距重叠就是 margin-collapse</p><p>相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距</p><p>折叠结果遵循下列计算规则：</p><ul><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li><li>两个外边距一正一负时，折叠结果是两者的相加的和</li></ul><p>新手在做导航栏的时候发现页面整体掉下来一截就是这个原因。</p><h3 id="CSS单位"><a href="#CSS单位" class="headerlink" title="CSS单位"></a>CSS单位</h3><ol><li><p>px  绝对单位。传统上一个像素对应于计算机屏幕上的一个点，而对于高清屏则对应更多。</p></li><li><p>%   父元素<strong>宽度</strong>的比例。</p><ol><li>如果对 html 元素设置 font-size 为百分比值，则是以浏览器默认的字体大小16px为参照计算的（所有浏览器的默认字体大小都为 16px），如62.5%即等于10px（62.5% * 16px = 10px）。</li></ol></li><li><p>em  相对单位。 不同的属性有不同的参照值。</p><ol><li>对于字体大小属性（font-size）来说，em 的计算方式是相对于父元素的字体大小</li><li>border, width, height, padding, margin, line-height）在这些属性中，使用em单位的计算方式是参照该元素的 font-size，1em 等于该元素设置的字体大小。同理如果该元素没有设置，则一直向父级元素查找，直到找到，如果都没有设置大小，则使用浏览器默认的字体大小。</li></ol></li><li><p>rem 是相对于根元素 html 的 font-size 来计算的，所以其参照物是固定的。</p><ol><li>好处：rem 只需要修改 html 的 font-size 值即可达到全部的修改，即所谓的牵一发而动全身。</li></ol></li><li><p>vw, vh, vmin, vmax   相对单位，是基于视窗大小（浏览器用来显示内容的区域大小）来计算的。</p><ol><li>vw：基于视窗的宽度计算，1vw 等于视窗宽度的百分之一</li><li>vh：基于视窗的高度计算，1vh 等于视窗高度的百分之一</li><li>vmin：基于vw和vh中的最小值来计算，1vmin 等于最小值的百分之一</li><li>vmax：基于vw和vh中的最大值来计算，1vmax 等于最大值的百分之一</li></ol></li></ol><h3 id="transform变形"><a href="#transform变形" class="headerlink" title="transform变形"></a><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform" target="_blank" rel="noopener">transform变形</a></h3><p>与transition、translate名字有点像，transition是做过渡动画的，而translate是用来做平移的。</p><ul><li>none    <ul><li>定义不进行转换。</li></ul></li><li>matrix(n,n,n,n,n,n)    <ul><li>定义 2D 转换，使用六个值的矩阵。</li></ul></li><li>translate(x,y)<ul><li>从其当前位置移动，根据给定的 left（x 坐标）和 top（y 坐标）</li></ul></li><li>translate3d(x,y,z)<ul><li>定义 3D 转换。</li></ul></li><li>translateX(x)</li><li>translateY(y)</li><li>translateZ(z)</li><li>scale(x[,y]?)<ul><li>定义 2D 缩放转换。</li></ul></li><li>scale3d(x,y,z)    <ul><li>定义 3D 缩放转换。</li></ul></li><li>scaleX(x)    </li><li>scaleY(y)    </li><li>scaleZ(z)    </li><li>rotate(angle)    <ul><li>定义 2D 旋转，在参数中规定角度。</li></ul></li><li>rotate3d(x,y,z,angle)    <ul><li>定义 3D 旋转。</li></ul></li><li>rotateX(angle)    </li><li>rotateY(angle)    </li><li>rotateZ(angle)    </li><li>skew(x-angle,y-angle)<ul><li>定义沿着 X 和 Y 轴的 2D 倾斜转换。</li></ul></li><li>skewX(angle)</li><li>skewY(angle)</li><li>perspective(n)    <ul><li>为 3D 转换元素定义透视视图。</li></ul></li></ul><h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><ul><li>嵌套           <ul><li>反映层级和约束</li></ul></li><li>变量和计算      <ul><li>减少冗余代码</li></ul></li><li>entend和mixin  <ul><li>代码片段重用</li><li>mixin是直接把CSS代码每个地方重复写一份</li><li>extend是使用逗号分割的选择器来为多个不同的地方使用同一段CSS</li></ul></li><li>循环          <ul><li>适用于复杂有规律的样式</li></ul></li><li>import        <ul><li>CSS模块化</li></ul></li></ul><h3 id="CSS-优化、提高性能的方法有哪些？"><a href="#CSS-优化、提高性能的方法有哪些？" class="headerlink" title="CSS 优化、提高性能的方法有哪些？"></a>CSS 优化、提高性能的方法有哪些？</h3><ul><li>多个 css 合并，尽量减少 HTTP 请求</li><li>css 雪碧图</li><li>抽象提取公共样式，减少代码量</li><li>选择器优化嵌套，尽量避免层级过深 （用‘&gt;’替换‘ ’）</li><li>属性值为 0 时，不加单位</li><li>压缩CSS代码</li><li>避免使用 <a href="http://www.divcss5.com/css3-style/c50224.shtml" target="_blank" rel="noopener">CSS 表达式</a><ul><li>它们要计算成千上万次并且可能会对你页面的性能产生影响。</li></ul></li></ul><h2 id="DOM层级顺序与z-index"><a href="#DOM层级顺序与z-index" class="headerlink" title="DOM层级顺序与z-index"></a><a href="https://segmentfault.com/a/1190000014382426" target="_blank" rel="noopener">DOM层级顺序与z-index</a></h2><h3 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h3><ul><li>link 是 HTML 方式， @import 是 CSS 方式</li><li>link 最大限度支持并行下载，@import 过多嵌套导致串行下载，出现 FOUC</li><li>link 可以通过 rel=”alternate stylesheet” 指定候选样式</li><li>浏览器对 link 支持早于@import ，可以使用 @import 对老浏览器隐藏样式</li><li>@import 必须在样式规则之前，可以在 css 文件中引用其他文件</li><li>总体来说：link 优于@import</li></ul><h3 id="CSS-有哪些继承属性"><a href="#CSS-有哪些继承属性" class="headerlink" title="CSS 有哪些继承属性"></a>CSS 有哪些继承属性</h3><ul><li>关于文字排版的属性如：<ul><li>font</li><li>word-break</li><li>letter-spacing</li><li>text-align</li><li>text-rendering</li><li>word-spacing</li><li>white-space</li><li>text-indent</li><li>text-transform</li><li>text-shadow</li></ul></li><li>line-height</li><li>color</li><li>visibility</li><li>cursor</li></ul><h3 id="display-有哪些值？说明他们的作用"><a href="#display-有哪些值？说明他们的作用" class="headerlink" title="display 有哪些值？说明他们的作用"></a>display 有哪些值？说明他们的作用</h3><ul><li>block 像块类型元素一样显示。</li><li>none  此元素将显示为块级元素，此元素前后会带有换行符。</li><li>inline  内联元素，元素前后没有换行符。</li><li>inline-block 象行内元素一样定位，但其内容象块类型元素一样显示。</li><li>list-item 象块类型元素一样显示，并添加样式列表标记。</li><li>table 此元素会作为块级表格来显示</li><li>inherit 规定应该从父元素继承 display 属性的值</li></ul><h3 id="position-有哪些值？-relative-和-absolute-定位原点是？"><a href="#position-有哪些值？-relative-和-absolute-定位原点是？" class="headerlink" title="position 有哪些值？ relative 和 absolute 定位原点是？"></a>position 有哪些值？ relative 和 absolute 定位原点是？</h3><ul><li>absolute 生成绝对定位的元素，相对于值不为 static 的第一个父元素进行定位。</li><li>fixed （老 IE 不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。</li><li>relative 生成相对定位的元素，相对于其正常位置进行定位。</li><li>static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。</li><li>inherit 规定从父元素继承 position 属性的值</li></ul><h3 id="CSS3新特性？"><a href="#CSS3新特性？" class="headerlink" title="CSS3新特性？"></a>CSS3新特性？</h3><ul><li>新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)}</li><li>弹性盒模型 display: flex;</li><li>多列布局 column-count: 5;</li><li>媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}}</li><li>个性化字体 @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}</li><li>颜色透明度 color: rgba(255, 0, 0, 0.75);</li><li>圆角 border-radius: 5px;</li><li>渐变 background:linear-gradient(red, green, blue);</li><li>阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</li><li>倒影 box-reflect: below 2px;</li><li>文字装饰 text-stroke-color: red;</li><li>文字溢出 text-overflow:ellipsis;</li><li>背景效果 background-size: 100px 100px;</li><li>边框效果 border-image:url(bt_blue.png) 0 10;</li><li>平滑过渡 transition: all .3s ease-in .1s;</li><li>动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</li><li>变形 transform<ul><li>旋转 transform: rotate(20deg);</li><li>倾斜 transform: skew(150deg, -10deg);</li><li>位移 transform: translate(20px, 20px);</li><li>缩放 transform: scale(.5);</li></ul></li></ul><h3 id="如何水平居中一个元素？"><a href="#如何水平居中一个元素？" class="headerlink" title="如何水平居中一个元素？"></a>如何水平居中一个元素？</h3><p>如果需要居中的元素为inline或inline-block，为父元素设置 <code>text-align: center;</code>即可实现</p><p>如果要居中的元素为一个块级元素的话，一般使用 <code>margin: 0 auto;</code> 进行居中。</p><h3 id="用纯-CSS-创建一个三角形的原理是什么？"><a href="#用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="用纯 CSS 创建一个三角形的原理是什么？"></a>用纯 CSS 创建一个三角形的原理是什么？</h3><p>把border的其他三条边设为透明<br>注意，这里要把 <code>border-width</code> 、<code>border-style</code>、 <code>border-color</code> 分开写。</p><pre><code class="css">.tri {  width: 0px;  height: 0;  border-style: solid;  border-width: 100px;  border-color: transparent transparent red transparent;}</code></pre><h3 id="li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？-也称幽灵字符"><a href="#li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？-也称幽灵字符" class="headerlink" title="li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？(也称幽灵字符)"></a>li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？(也称幽灵字符)</h3><p>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符, 这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为 0，就没有空格了</p><h3 id="display-inline-block-什么时候会显示间隙？-携程"><a href="#display-inline-block-什么时候会显示间隙？-携程" class="headerlink" title="display:inline-block 什么时候会显示间隙？(携程)"></a>display:inline-block 什么时候会显示间隙？(携程)</h3><ul><li>相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距</li><li>非 inline-block 水平元素设置为 inline-block 也会有水平间距</li><li>可以借助 vertical-align:top; 消除垂直间隙</li><li>可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙</li><li>把 li 标签写到同一行可以消除垂直间隙，但代码可读性差</li></ul><h3 id="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？</h3><ul><li>响应式设计就是网站能够兼容多个不同大小的终端，而不是为每个终端做一个特定的版本</li><li>基本原理是利用 CSS3 媒体查询，为不同尺寸的设备适配不同样式</li><li>对于低版本的 IE，可采用 JS 获取屏幕宽度，然后通过监听window.onresize 方法来实现兼容</li></ul><h3 id="谈谈浮动和清除浮动"><a href="#谈谈浮动和清除浮动" class="headerlink" title="谈谈浮动和清除浮动"></a>谈谈浮动和清除浮动</h3><p>浮动的框可以向左或向右移动，<strong>直到他的外边缘碰到包含框或另一个浮动框的边框为止</strong>。 <strong>浮动框脱离文档流</strong>，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。</p><p>清除方法：</p><ol><li>父级 div 定义伪类：after 和 zoom (推荐使用，建议定义公共类，以减少 CSS 代码)</li></ol><pre><code class="css">   .clearfloat:after{       display:block;       clear:both;       content:&quot;&quot;;       visibility:hidden;       height:0}   .clearfloat{zoom:1}</code></pre><ol start="2"><li>在结尾处添加空 div 标签 clear:both<pre><code class="html">&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; &lt;div class=&quot;clearfloat&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre></li></ol><style>    .left {float:left}    .clearfloat{clear:both}</style><pre><code>父级 div 定义 overflow:auto。 同时需要父级指定宽度参考链接[几种常用的清除浮动方法](https://www.cnblogs.com/nxl0908/p/7245460.html)### box-sizing 常用的属性有哪些？分别有什么作用？- box-sizing: content-box; // 默认的标准(W3C)盒模型元素效果- box-sizing: border-box; // 触发怪异(IE)盒模型元素的效果- box-sizing: inherit; // 继承父元素 box-sizing 属性的值### 请列举几种隐藏元素的方法- visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在- opacity: 0; CSS3 属性，设置 0 可以使一个元素完全透明- position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外- display: none; 元素会变得不可见，并且不会再占用文档的空间。- transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留- \&lt;div hidden=&quot;hidden&quot;\&gt; HTML5 属性,效果和 display:none;相同，但这个属性用于记录一个元素的状态- height: 0; 将元素高度设为 0 ，并消除边框- filter: blur(0); CSS3 属性，将一个元素的模糊度设置为 0### rgba() 和 opacity 的透明效果有什么不同？- opacity 作用于元素以及元素内的所有内容（包括文字）的透明度- rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果### css 属性 content 有什么作用？content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式### 元素竖向的百分比设定是相对于容器的高度吗？元素竖向的百分比设定是相对于容器的宽度，而不是高度### a 标签上四个伪类的使用顺序是怎么样的？link &gt; visited &gt; hover &gt; active简称 lvha(love-ha)伪类的特殊性（应用优先级）是同样的，所以后出现的伪类会覆盖先出现的伪类（同时激活） 在这里，比如把hover放在active后面，那么实际你在激活（active）链接的时候就触发了hover伪类，hover在后面覆盖了active的颜色，所以始终无法看到active的颜色 ### 伪元素和伪类的区别和作用？伪元素:在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：```cssp::before {content:&quot;第一章：&quot;;}p::after {content:&quot;Hot!&quot;;}p::first-line {background:red;}p::first-letter {font-size:30px;}</code></pre><p>伪类: 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</p><pre><code class="css">a:hover {color: #FF00FF}p:first-child {color: red}</code></pre><h3 id="before-和-after-中双冒号和单冒号有什么区别？"><a href="#before-和-after-中双冒号和单冒号有什么区别？" class="headerlink" title="::before 和 :after 中双冒号和单冒号有什么区别？"></a>::before 和 :after 中双冒号和单冒号有什么区别？</h3><ul><li>在 CSS 中伪类一直用 : 表示，如 :hover, :active 等</li><li>伪元素在 CSS1 中已存在，当时语法是用 : 表示，如 :before 和 :after</li><li>后来在 CSS3 中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类</li><li>由于低版本 IE 对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</li><li>综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容 IE 的老语法</li></ul><h3 id="设置元素浮动后，该元素的-display-值会如何变化？"><a href="#设置元素浮动后，该元素的-display-值会如何变化？" class="headerlink" title="设置元素浮动后，该元素的 display 值会如何变化？"></a>设置元素浮动后，该元素的 display 值会如何变化？</h3><p>设置元素浮动后，该元素的 display 值自动变成 block</p><h3 id="请解释-CSS-sprites，以及你要如何在页面或网站中实现它"><a href="#请解释-CSS-sprites，以及你要如何在页面或网站中实现它" class="headerlink" title="请解释 CSS sprites，以及你要如何在页面或网站中实现它"></a>请解释 CSS sprites，以及你要如何在页面或网站中实现它</h3><ul><li>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。</li><li>CSS Sprites 为一些大型的网站节约了带宽，让提高了用户的加载速度和用户体验，不需要加载更多的图片。</li></ul><h3 id="base64的使用"><a href="#base64的使用" class="headerlink" title="base64的使用"></a>base64的使用</h3><ul><li>写入CSS， 减少HTTP请求</li><li>适用于小图片</li><li>base64的体积约为原图4/3</li></ul><h3 id="margin叠加几种情况"><a href="#margin叠加几种情况" class="headerlink" title="margin叠加几种情况"></a>margin叠加几种情况</h3><p>margin叠加的意思是：当两个或者更多的垂直外边距 相遇时，它们将形成一个外边距，这个外边距的高度等于两个发生叠加的外边距中高度较大者。</p><ol><li><p>当一个元素出现在另一个元素上面时，第一个元素的底边外边距与第二个元素的顶边外边距发生叠加。如图：<br><img src="../img/marginSuperposition1.png" srcset="/img/loading.gif" alt="叠加"></p></li><li><p>当一个元素在另一个元素中时，它们的顶边距和低边距也会发生叠加<br><img src="../img/marginSuperposition2.png" srcset="/img/loading.gif" alt="叠加2"></p></li><li><p>如果一个元素是空元素（即一个元素没有内容，内边距和边框），这种情况外边距的顶边距和低边距碰在一起也会发生叠加<br><img src="../img/marginSuperposition3.png" srcset="/img/loading.gif" alt="叠加3"></p></li><li><p>在上面那种空元素的情况，如果该空元素与另一个元素的外边距碰在一起，也会发生叠加。<br><img src="../img/marginSuperposition4.png" srcset="/img/loading.gif" alt="叠加4"></p></li></ol><p>以上4种外边距叠加情况<strong>只会发生在普通文档流的垂直方向</strong>。行内框、浮动框、绝对定位框之间的外边距不会发生叠加，同样水平方向也不会发生叠加。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS/CSS选择器</title>
    <link href="/uncategorized/CSS/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/uncategorized/CSS/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS-选择器分类"><a href="#CSS-选择器分类" class="headerlink" title="CSS 选择器分类"></a>CSS 选择器分类</h3><ul><li>标签选择 </li><li>id选择器</li><li>class选择器</li><li>后代选择 （div a）</li><li>子代选择 （div &gt; p）</li><li>相邻选择 （div + p）</li><li>通配符选择 （*）</li><li>否定选择器 :not(.link){}</li><li>属性选择器</li><li>伪类选择器</li><li>伪元素选择器 ::before{}</li></ul><h3 id="CSS3属性选择器"><a href="#CSS3属性选择器" class="headerlink" title="CSS3属性选择器"></a>CSS3属性选择器</h3><table><thead><tr><th>选择器</th><th>描述</th></tr></thead><tbody><tr><td>[attribute]</td><td>用于选取带有指定属性的元素。</td></tr><tr><td>[attribute=value]</td><td>用于选取带有指定属性和值的元素。</td></tr><tr><td>[attribute~=value]</td><td>用于选取属性值中包含指定词汇的元素。</td></tr><tr><td>[attribute|=value]</td><td>用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。</td></tr><tr><td>[attribute^=value]</td><td>匹配属性值以指定值开头的每个元素。</td></tr><tr><td>[attribute$=value]</td><td>匹配属性值以指定值结尾的每个元素。</td></tr><tr><td>[attribute*=value]</td><td>匹配属性值中包含指定值的每个元素。</td></tr></tbody></table><h3 id="CSS3伪类选择器"><a href="#CSS3伪类选择器" class="headerlink" title="CSS3伪类选择器"></a>CSS3伪类选择器</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes#%E6%A0%87%E5%87%86%E4%BC%AA%E7%B1%BB%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">伪类 | MDN</a><br>常用：</p><ul><li>:hover</li><li>:focus</li><li>:after 在元素之前添加内容,也可以用来做清除浮动。</li><li>:before 在元素之后添加内容</li><li>:enabled 选择器匹配每个已启用的元素（大多用在表单元素上）。</li><li>:disabled 控制表单控件的禁用状态。</li><li>:checked 单选框或复选框被选中</li><li>::selection  用户选中的区域</li><li>:empty   一般用来隐藏内部什么都没有的元素</li><li>:not(selecter)</li><li></li><li>p:first-of-type </li><li>p:last-of-type </li><li>p:only-of-type </li><li>p:nth-of-type(n)</li><li>p:nth-last-of-type(n)</li><li></li><li>:nth-child(n)</li><li>:nth-last-child(n)</li><li>p:only-child </li></ul><h3 id="伪类和伪元素区别"><a href="#伪类和伪元素区别" class="headerlink" title="伪类和伪元素区别"></a>伪类和伪元素区别</h3><ul><li>伪类值一种状态 比如:hover</li><li>伪元素是一个真实存在的元素，他可以有样式有内容</li></ul><h3 id="iconfont原理"><a href="#iconfont原理" class="headerlink" title="iconfont原理"></a>iconfont原理</h3><ul><li>利用编码让图标编为一个字符</li><li>引入字体</li><li>利用before伪元素向页面中插入一个文字</li></ul><h3 id="css-定义的权重"><a href="#css-定义的权重" class="headerlink" title="css 定义的权重"></a>css 定义的权重</h3><ul><li>!important 优先级最高，但也会被权重高的important所覆盖</li><li>行内样式总会覆盖外部样式表的任何样式(除了!important)</li><li>单独使用一个选择器的时候，不能跨等级使css规则生效</li><li>如果两个权重不同的选择器作用在同一元素上，权重值高的css规则生效</li><li>如果两个相同权重的选择器作用在同一元素上：以后面出现的选择器为最后规则</li><li>权重相同时，与元素距离近的选择器生</li></ul><p>一句话总结：<br>!important &gt; 行内样式 &gt; ID选择器 &gt; (类选择器 | 属性选择器 | 伪类选择器 ) &gt; 元素选择器 &gt; *<br><img src="http://image.zhangxinxu.com/image/blog/201208/specifishity1-1.png" srcset="/img/loading.gif" alt="大鱼吃小鱼"></p><h3 id="浏览器解析CSS"><a href="#浏览器解析CSS" class="headerlink" title="浏览器解析CSS"></a>浏览器解析CSS</h3><p><code>.wrapper div &gt; p</code>  CSS中，浏览器查找元素是通过选择权从后往前找的， 这样做的目的是加快CSS解析速度，从后往前，排除法</p><p><a href="https://blog.csdn.net/qq_21397815/article/details/72874932" target="_blank" rel="noopener">浏览器解析css选择器的规则</a></p><h3 id="怎样美化一个checkbox"><a href="#怎样美化一个checkbox" class="headerlink" title="怎样美化一个checkbox ?"></a>怎样美化一个checkbox ?</h3><ul><li>让原本的勾选框隐藏</li><li><code>input + label</code> 背景图没选中</li><li><code>input:checked + label</code> 背景图选中</li></ul><pre><code class="css">.checkbox input{  display: none;}.checkbox input + label{  background:url(./没选中.png) left center no-repeat;  background-size:20px 20px;  padding-left:20px;}.checkbox input:checked + label{  background-image:url(./选中.png);}</code></pre><pre><code class="html">&lt;div class=&quot;checkbox&quot;&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;handsome&quot;/&gt;  &lt;label for=&quot;handsome&quot;&gt;我很帅&lt;/label&gt;&lt;/div&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/testDemo/slowServer/slow</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/slowServer/slow/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/slowServer/slow/</url>
    
    <content type="html"><![CDATA[alert('我现在才被加载出来')]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/testDemo/slowServer/js-header</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/slowServer/js-header/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/slowServer/js-header/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <meta http-equiv="X-UA-Compatible" content="ie=edge">  <title>Document</title>    <style>    body {      background: red;    }  </style>  <script src="./slow.js"></script>  <meta name="generator" content="Hexo 4.2.0"></head><body>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/testDemo/slowServer/js-bottom</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/slowServer/js-bottom/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/slowServer/js-bottom/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <meta http-equiv="X-UA-Compatible" content="ie=edge">  <title>Document</title>  <style>    body {      background: red;    }  </style><meta name="generator" content="Hexo 4.2.0"></head><body>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>    <script src="./slow.js"></script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/testDemo/slowServer/index</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/slowServer/index/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/slowServer/index/</url>
    
    <content type="html"><![CDATA[const http = require('http')const fs = require('fs')const hostname = '127.0.0.1'const port = 3000const server = http.createServer((req, res) => {  //加载很慢的JS放在头部  if (req.url === '/header') {    fs.readFile('./js-header.html', 'utf8', (err, data) => {      res.statusCode = 200      res.setHeader('Content-Type', 'text/html')      res.end(data)    })  }  //加载很慢的JS放在尾部  if (req.url === '/bottom') {    fs.readFile('./js-bottom.html', 'utf8', (err, data) => {      res.statusCode = 200      res.setHeader('Content-Type', 'text/html')      res.end(data)    })  }  if (req.url === '/slow.js') {    fs.readFile('./slow.js', 'utf8', (err, data) => {      setTimeout(() => {        res.statusCode = 200        res.setHeader('Content-Type', 'application/javascript')        res.end(data)      }, 2000)    })  }})server.listen(port, hostname, () => {  console.log(`加载很慢的JS放在头部 http://${hostname}:${port}/header`)  console.log(`加载很慢的JS放在尾部 http://${hostname}:${port}/bottom`)})]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/testDemo/opentime-2</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/opentime-2/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/opentime-2/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <meta http-equiv="X-UA-Compatible" content="ie=edge">  <title>Document</title>  <style>    body {      background: red;    }  </style><meta name="generator" content="Hexo 4.2.0"></head><body>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>    <script src="./slow.js"></script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/testDemo/opentime-1</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/opentime-1/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/testDemo/opentime-1/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <meta http-equiv="X-UA-Compatible" content="ie=edge">  <title>Document</title>  <style>    body {      background: red;    }  </style><meta name="generator" content="Hexo 4.2.0"></head><body>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>  <div>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</div>    <script>    var obj = {      a: {        b:{          c: 'value'        }      }    }    let repeatTime = 100000    for(let i =0; i < repeatTime; i++){      for(let i =0; i < repeatTime; i++){        for(let i =0; i < repeatTime; i++){          obj.a.b.c = obj.a.b.c +'';        }      }    }    console.log('被阻塞了')  </script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/雅虎军规</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%9B%85%E8%99%8E%E5%86%9B%E8%A7%84/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%9B%85%E8%99%8E%E5%86%9B%E8%A7%84/</url>
    
    <content type="html"><![CDATA[<h1 id="雅虎军规"><a href="#雅虎军规" class="headerlink" title="雅虎军规"></a>雅虎军规</h1><p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1" target="_blank" rel="noopener">雅虎军规</a></p><ul><li>网络部分<ul><li>尽量减少HTTP请求数<ul><li>合并文件</li><li>雪碧图</li><li>小图Base64</li></ul></li><li>减少DNS查找<ul><li>开启DNS预解析</li></ul></li><li>使用CND静态资源服务器</li><li>避免重定向</li><li>杜绝404</li></ul></li><li>缓存<ul><li>配置ETags<ul><li>实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制</li></ul></li><li>添上Expires或者Cache-Control HTTP头</li><li>使用外链的方式引入JS和CSS（缓存）</li></ul></li><li>内容部分<ul><li>按需加载组件</li><li>预加载组件</li><li>减少DOM元素的数量</li><li>尽量少用iframe</li><li>压缩JavaScript和CSS（代码层面）</li></ul></li><li>CSS 部分<ul><li>避免使用CSS表达式</li><li>选择<code>&lt;link&gt;</code>而不是<code>@import</code></li><li>避免使用滤镜</li><li>把样式表放在顶部</li></ul></li><li>JS 部分<ul><li>把脚本放在底部</li><li>去除重复脚本</li><li>减少DOM访问</li></ul></li><li>图片部分<ul><li>选用合适的图片格式</li><li>雪碧图中间少留空白</li><li>不要用HTML缩放图片，要小图就去加载小图</li><li>用小的可缓存的favicon.ico</li></ul></li><li>cookie<ul><li>给cookie减肥<ul><li>清除不必要的cookie</li><li>cookie尽可能小</li><li>设置好合适的域</li><li>合适的有效期</li></ul></li><li>把静态资源放在不含cookie的域下<ul><li>当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。</li></ul></li></ul></li><li>移动端<ul><li>保证所有组件都小于25K</li><li>把组件打包到一个复合文档里</li></ul></li><li>服务器<ul><li>开启Gzip等压缩</li><li>避免图片src属性为空（为空浏览器也会向服务器发送另一个请求）</li><li>对Ajax用GET请求</li><li>尽早清空缓冲区</li><li>使用CDN（内容分发网络）<ul><li>内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。</li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/网络优化</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="合并资源文件，减少HTTP请求"><a href="#合并资源文件，减少HTTP请求" class="headerlink" title="合并资源文件，减少HTTP请求"></a>合并资源文件，减少HTTP请求</h3><p>浏览器并发的HTTP请求是由数量限制的（比如桌面浏览器并发请求可能是8个，手机浏览器是6个），如果一下子并发的几十个请求那么会有很多请求会停下来等，等前面的请求好了下一个再进去，这样就延长了整个页面的加载时间</p><h3 id="压缩资源文件减小请求大小"><a href="#压缩资源文件减小请求大小" class="headerlink" title="压缩资源文件减小请求大小"></a>压缩资源文件减小请求大小</h3><p>文件大小越小当然加载速度就越快。<br>可对代码进行压缩，去掉空格、注释、变量替换，在传输时，使用gzip等压缩方式也可以降低资源文件的大小。</p><h3 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h3><ul><li>强缓存<ul><li>直接从浏览器缓存中读取，不去后台查询是否过期</li><li><code>Exprise</code> 过期时间</li><li><code>Cache-Control:max-age=3600</code> 过期秒数</li></ul></li><li>协商缓存<ul><li>每次使用缓存之前先去后台确认一下</li><li><code>Last-Modified</code> <code>If-Modified-Since</code> 上次修改时间</li><li><code>Etag</code> <code>If-None-Match</code></li></ul></li><li>如何区别<ul><li>是否设置了<code>no-cache</code></li></ul></li></ul><h3 id="利用缓存机制，尽可能使用缓存减少请求"><a href="#利用缓存机制，尽可能使用缓存减少请求" class="headerlink" title="利用缓存机制，尽可能使用缓存减少请求"></a>利用缓存机制，尽可能使用缓存减少请求</h3><p>浏览器是有缓存机制的，在返回资源的时候设置一个cache-control设置过期时间，在过期时间内浏览器会默认使用本地缓存。</p><p>但缓存机制也存在一定的问题，因为网站开发是阶段性的，隔一段时间会发布一个新的版本。因为HTTP请求是根据url来定位的，如果资源文件名的url没有发生更改那么浏览器还是会使用缓存，这个时候怎么办那？<br>这时就需要一个缓存更新机制来让修改过的文件具有一个新的名字。<br>最简单的方法就是在url后加一个时间戳，但是这会导致只要有新的版本发布就会重新获取所有的新资源。<br>一个现代流行的方法就是根据文件计算一个hash值，这个hash值是根据文件的更新变化而变化的。 当浏览器获取文件时如果这个文件名有更新那么就会请求新的文件。</p><h3 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h3><p>现代浏览器在 DNS Prefetch 上做了两项工作：</p><ol><li><p>html 源码下载完成后，会解析页面的包含链接的标签，提前查询对应的域名</p></li><li><p>对于访问过的页面，浏览器会记录一份域名列表，当再次打开时，会在 html 下载的同时去解析 DNS</p></li></ol><p><strong>自动解析</strong></p><p>浏览器使用超链接的href属性来查找要预解析的主机名。当遇到a标签，浏览器会自动将href中的域名解析为IP地址，这个解析过程是与用户浏览网页并行处理的。但是为了确保安全性，在HTTPS页面中不会自动解析</p><p><strong>手动解析</strong></p><pre><code class="html">预解析某域名&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img.alicdn.com&quot;&gt;强制开启HTTPS下的DNS预解析&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code></pre><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN 的原理是尽可能的在各个地方分布机房缓存数据。</p><p>因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。</p><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p><p>预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载。</p><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p><pre><code class="html">&lt;link rel=&quot;preload&quot; href=&quot;http://example.com&quot;&gt;</code></pre><h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染。</p><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><ul><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端按理说，图片不需要加载原图，可请求裁剪好的图片</li><li>小图使用base64格式</li><li>将多个图标文件整合到一张图中（雪碧图）</li><li>采用正确的图片格式<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>色彩很多的使用 JPEG</li><li>色彩种类少的使用 PNG，有的可用SVG代替</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/编写高性能的Javascript</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84Javascript/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84Javascript/</url>
    
    <content type="html"><![CDATA[<h3 id="常见编码规范"><a href="#常见编码规范" class="headerlink" title="常见编码规范"></a>常见编码规范</h3><ul><li>将 js 脚本放在页面底部，加快渲染页面</li><li>将 js 脚本将脚本成组打包，减少请求</li><li>使用非阻塞方式下载 js 脚本</li><li>尽量使用局部变量来保存全局变量</li><li>遵循严格模式：”use strict”;</li><li>尽量减少使用闭包</li><li>减少对象成员嵌套</li><li>缓存DOM节点访问</li><li>避免使用eval()和Function()构造器</li><li>尽量使用直接量取创建对象和数组</li><li>最小化重绘(repaint)和回流(reflow)</li></ul><h3 id="为什么JS要放到body尾部？"><a href="#为什么JS要放到body尾部？" class="headerlink" title="为什么JS要放到body尾部？"></a>为什么JS要放到body尾部？</h3><p>如果JS需要绑定操作DOM，那么放在header中如果处理不当就不会绑定到DOM</p><p><strong>JS 引擎是独立于渲染引擎存在的。</strong>我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。</p><p>浏览器之所以让 JS 阻塞其它的活动，是因为它不知道 JS 会做什么改变，担心如果不阻止后续的操作，会造成混乱。</p><p>结论：</p><ul><li><strong>如果JS在header中，浏览器会阻塞并等待JS加载完毕并执行</strong></li><li><strong>如果JS在body尾部，览器会进行一次提前渲染，从而提前首屏出现时间</strong></li></ul><p>参考demo: 执行<code>/性能优化/testDemo/slowServer/index.js</code>，注意查看终端</p><h3 id="非核心代码的异步加载"><a href="#非核心代码的异步加载" class="headerlink" title="非核心代码的异步加载"></a>非核心代码的异步加载</h3><ul><li>动态脚本加载<ul><li>使用JS创建一个script标签再插入到页面中</li></ul></li><li>defer（IE）<ul><li>整个HTML<strong>解析完</strong>后才会执行，如果是多个，按照加载顺序依次执行</li></ul></li><li>async<ul><li><strong>加载完</strong>之后立即执行，如果是多个，执行和加载顺序无关</li></ul></li></ul><h3 id="header中meta"><a href="#header中meta" class="headerlink" title="header中meta"></a>header中meta</h3><p>兼容性配置，让IE使用最高级的Edge渲染，如果有chrome就使用chrome渲染。</p><pre><code class="html">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;</code></pre><p>如果是双核浏览器，优先使用webkit引擎</p><pre><code class="html">&lt;meta name=&quot;render&quot; content=&quot;webkit&quot;&gt;</code></pre><h3 id="使用节流和防抖"><a href="#使用节流和防抖" class="headerlink" title="使用节流和防抖"></a>使用节流和防抖</h3><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。<br>对于图片来说，先设置图片标签的 src 属性为一张占位图或为空，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/浏览器渲染</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h3 id="浏览器的渲染过程，DOM-树和渲染树的区别？"><a href="#浏览器的渲染过程，DOM-树和渲染树的区别？" class="headerlink" title="浏览器的渲染过程，DOM 树和渲染树的区别？"></a>浏览器的渲染过程，DOM 树和渲染树的区别？</h3><p><img src="../img/xuanran.png" srcset="/img/loading.gif" alt="xuanran.png"></p><p>HTML 经过解析生成 DOM树； CSS经过解析生成　Style Rules。 二者一结合生成了Render Tree。<br>通过layout计算出DOM要显示的宽高、位置、颜色。<br>最后渲染在界面上，用户就看到了</p><p>浏览器的渲染过程：</p><ul><li>解析 HTML 构建 DOM(DOM 树)，并行请求 css/image/js</li><li>CSS 文件下载完成，开始构建 CSSOM(CSS 树)</li><li>CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)</li><li>布局(Layout)：计算出每个节点在屏幕中的位置</li><li>显示(Painting)：通过显卡把页面画到屏幕上</li></ul><p>DOM 树 和 渲染树 的区别：</p><ul><li>DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素</li><li>渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的 css 属性</li></ul><h3 id="CSS会阻塞DOM解析吗？"><a href="#CSS会阻塞DOM解析吗？" class="headerlink" title="CSS会阻塞DOM解析吗？"></a>CSS会阻塞DOM解析吗？</h3><p>对于一个HTML文档来说，不管是内联还是外链的css，都会阻碍后续的dom渲染，但是不会阻碍后续dom的解析。</p><p>当css文件放在<head>中时，虽然css解析也会阻塞后续dom的渲染，但是在解析css的同时也在解析dom，所以等到css解析完毕就会逐步的渲染页面了。</p><h3 id="重绘和回流（重排）的区别和关系？"><a href="#重绘和回流（重排）的区别和关系？" class="headerlink" title="重绘和回流（重排）的区别和关系？"></a>重绘和回流（重排）的区别和关系？</h3><ul><li>重绘：当渲染树中的元素<strong>外观</strong>（如：颜色）发生改变，不影响布局时，产生重绘</li><li>回流：当渲染树中的元素的<strong>布局</strong>（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流</li><li>注意：JS 获取 Layout 属性值（如：offsetLeft、scrollTop、getComputedStyle 等）也会引起回流。因为浏览器需要通过回流计算最新值</li><li>回流必将引起重绘，而重绘不一定会引起回流</li></ul><p>DOM结构中的各元素都有自己的盒子，这些都需要浏览器根据各种样式来计算并更具结果将元素放到它该出现的位置，这个过程叫 reflow</p><p>触发reflow </p><ul><li>添加或删除可见的DOM元素。 </li><li>元素位置改变。 </li><li>元素的尺寸改变（包括：内外边距、边框厚度、宽度、高度等属性的改变）。 </li><li>内容改变。 </li><li>页面渲染器初始化。 </li><li>浏览器窗口尺寸改变。</li></ul><h3 id="如何最小化重绘-repaint-和回流-reflow-？"><a href="#如何最小化重绘-repaint-和回流-reflow-？" class="headerlink" title="如何最小化重绘(repaint)和回流(reflow)？"></a>如何最小化重绘(repaint)和回流(reflow)？</h3><p>以下几个操作会导致性能问题：</p><ul><li>改变 window 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p>解决方法：</p><ul><li>需要要对DOM元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示</li><li>需要创建多个 DOM 节点时，使用 DocumentFragment 创建完后一次性的加入 document，或使用字符串拼接方式构建好对应HTML后再使用innerHTML来修改页面</li><li>缓存 Layout 属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流</li><li>避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流）</li><li>避免使用 css 表达式(expression)，因为每次调用都会重新计算值（包括加载页面）</li><li>尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color</li><li>批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/性能测试</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><h2 id="测试性能工具"><a href="#测试性能工具" class="headerlink" title="测试性能工具"></a>测试性能工具</h2><p>Chrome 已经提供了一个大而全的性能测试工具 Audits。<br><img src="../img/aduits.png" srcset="/img/loading.gif" alt="audits"></p><p>选择想测试的功能然后点击 Run audits ，工具就会自动运行帮助我们测试问题并且给出一个完整的报告。<br><img src="../img/aduitsReport.png" srcset="/img/loading.gif" alt="报告"></p><p>可以看到报告中分别为<strong>性能、体验、SEO</strong> 都给出了打分，并且每一个指标都有详细的评估。</p><p>评估结束后，工具还提供了一些建议便于我们提高这个指标的分数。<br><img src="../img/auditsSuggest.png" srcset="/img/loading.gif" alt="建议"></p><p>还有一个 Performance 工具也可以供我们使用。<br><img src="../img/performance.png" srcset="/img/loading.gif" alt="performance"><br>在这张图中，我们可以详细的看到每个时间段中浏览器在处理什么事情，哪个过程最消耗时间，便于我们更加详细的了解性能瓶颈。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/webpack中优化</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/webpack%E4%B8%AD%E4%BC%98%E5%8C%96/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/webpack%E4%B8%AD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h1><ul><li>有哪些方式可以减少 Webpack 的打包时间</li><li>有哪些方式可以让 Webpack 打出来的包更小</li></ul><h2 id="减小打包后文件体积"><a href="#减小打包后文件体积" class="headerlink" title="减小打包后文件体积"></a>减小打包后文件体积</h2><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>如果我们将页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。</p><h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><p>Tree Shaking 可以实现删除项目中未被引用的代码，比如</p><pre><code class="js">// test.jsexport const a = 1export const b = 2// index.jsimport { a } from &#39;./test.js&#39;</code></pre><p>对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p><h3 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h3><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。<br>比如我们希望打包两个文件</p><pre><code class="js">// test.jsexport const a = 1// index.jsimport { a } from &#39;./test.js&#39;</code></pre><p>对于这种情况，我们打包出来的代码会类似这样</p><pre><code class="js">[  /* 0 */  function (module, exports, require) {    //...  },  /* 1 */  function (module, exports, require) {    //...  }]</code></pre><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><pre><code class="js">[  /* 0 */  function (module, exports, require) {    //...  }]</code></pre><p>样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。</p><pre><code class="js">module.exports = {  optimization: {    concatenateModules: true  }}</code></pre><h2 id="加快打包速度"><a href="#加快打包速度" class="headerlink" title="加快打包速度"></a>加快打包速度</h2><h3 id="优化-Loader"><a href="#优化-Loader" class="headerlink" title="优化 Loader"></a>优化 Loader</h3><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST（抽象语法树），然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。</p><p>首先我们可以<strong>减小 Loader 的文件搜索范围</strong></p><pre><code class="js">module.exports = {  module: {    rules: [      {        // js 文件才使用 babel        test: /\.js$/,        loader: &#39;babel-loader&#39;,        // 只在 src 文件夹下查找        include: [resolve(&#39;src&#39;)],        // 不会去查找的路径        exclude: /node_modules/      }    ]  }}</code></pre><p>还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间。</p><pre><code>loader: &#39;babel-loader?cacheDirectory=true&#39;</code></pre><h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><p><strong>HappyPack 可以将 Loader 的同步执行转换为并行的</strong>，这样就能充分利用系统资源来加快打包效率了</p><pre><code class="js">module: {  loaders: [    {      test: /\.js$/,      include: [resolve(&#39;src&#39;)],      exclude: /node_modules/,      // id 后面的内容对应下面      loader: &#39;happypack/loader?id=happybabel&#39;    }  ]},plugins: [  new HappyPack({    id: &#39;happybabel&#39;,    loaders: [&#39;babel-loader?cacheDirectory&#39;],    // 开启 4 个线程    threads: 4  })]</code></pre><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><p>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</p><pre><code class="js">// 单独配置在一个文件中// webpack.dll.conf.jsconst path = require(&#39;path&#39;)const webpack = require(&#39;webpack&#39;)module.exports = {  entry: {    // 想统一打包的类库    vendor: [&#39;react&#39;]  },  output: {    path: path.join(__dirname, &#39;dist&#39;),    filename: &#39;[name].dll.js&#39;,    library: &#39;[name]-[hash]&#39;  },  plugins: [    new webpack.DllPlugin({      // name 必须和 output.library 一致      name: &#39;[name]-[hash]&#39;,      // 该属性需要与 DllReferencePlugin 中一致      context: __dirname,      path: path.join(__dirname, &#39;dist&#39;, &#39;[name]-manifest.json&#39;)    })  ]}</code></pre><p>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中</p><pre><code class="js">// webpack.conf.jsmodule.exports = {  // ...省略其他配置  plugins: [    new webpack.DllReferencePlugin({      context: __dirname,      // manifest 就是之前打包出来的 json 文件      manifest: require(&#39;./dist/vendor-manifest.json&#39;),    })  ]}</code></pre><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p>在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。</p><p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。</p><h3 id="一些小的优化点"><a href="#一些小的优化点" class="headerlink" title="一些小的优化点"></a>一些小的优化点</h3><ul><li><code>resolve.extensions</code> 用来表明文件后缀列表，默认查找顺序是 [‘.js’, ‘.json’]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li><li><code>resolve.alias</code>  可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</li><li><code>module.noParse</code>  如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/SEO</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/SEO/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/SEO/</url>
    
    <content type="html"><![CDATA[<h3 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a>前端需要注意哪些SEO</h3><ol><li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li><li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用js输出：爬虫不会执行js获取内容</li><li>少用iframe：搜索引擎不会抓取iframe中的内容</li><li>非装饰性图片必须加alt</li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/README</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/README/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/README/</url>
    
    <content type="html"><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul><li>资源压缩合并，减少HTTP请求，开启gzip压缩</li><li>非核心代码的异步加载<ul><li>异步加载方式</li><li>异步加载的区别</li></ul></li><li>利用浏览器缓存<ul><li>缓存分类</li><li>缓存原理</li></ul></li><li>使用CDN</li><li>DNS预解析</li></ul><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a><a href="网络优化.md">网络优化</a></h2><p>压缩传输内容，用好缓存</p><h2 id="webpack中优化"><a href="#webpack中优化" class="headerlink" title="webpack中优化"></a><a href="webpack中优化.md">webpack中优化</a></h2><p>主要就是为了减少Webpack打包后的文件体积</p><h2 id="编写高性能的Javascript"><a href="#编写高性能的Javascript" class="headerlink" title="编写高性能的Javascript"></a><a href="编写高性能的Javascript.md">编写高性能的Javascript</a></h2><h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a><a href="浏览器渲染.md">浏览器渲染</a></h2><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a><a href="CDN.md">CDN</a></h2><h3 id="插入几万个-DOM，如何实现页面不卡顿？"><a href="#插入几万个-DOM，如何实现页面不卡顿？" class="headerlink" title="插入几万个 DOM，如何实现页面不卡顿？"></a>插入几万个 DOM，如何实现页面不卡顿？</h3><p>肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。部分人应该可以想到通过 <code>requestAnimationFrame</code> 的方式去循环的插入 DOM，其实还有种方式去解决这个问题：<strong>虚拟滚动</strong>（virtualized scroller）。</p><p>这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。</p><p><img src="../img/vScroll.png" srcset="/img/loading.gif" alt="滚动"></p><p>从上图中我们可以发现，即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这发问题。如果你想了解更多的内容可以了解下这个 <a href="https://github.com/bvaughn/react-virtualized" target="_blank" rel="noopener">react-virtualized</a>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化/CDN</title>
    <link href="/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CDN/"/>
    <url>/uncategorized/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CDN/</url>
    
    <content type="html"><![CDATA[<h1 id="CDN-的缓存与回源机制解析"><a href="#CDN-的缓存与回源机制解析" class="headerlink" title="CDN 的缓存与回源机制解析"></a>CDN 的缓存与回源机制解析</h1><p>CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p><h3 id="CDN的核心功能"><a href="#CDN的核心功能" class="headerlink" title="CDN的核心功能"></a>CDN的核心功能</h3><p>CDN 的核心点有两个，一个是<strong>缓存</strong>，一个是<strong>回源</strong>。</p><ul><li>“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程</li><li>“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</li></ul><h3 id="CDN-与前端性能优化"><a href="#CDN-与前端性能优化" class="headerlink" title="CDN 与前端性能优化"></a>CDN 与前端性能优化</h3><p>CDN 往往被用来<strong>存放静态资源</strong>。 </p><p>“根服务器”本质上是业务服务器，它的核心任务在于生成”动态页面”或返回”非纯静态页面”(需要计算的)。业务服务器仿佛一个车间，车间里运转的机器轰鸣着为我们产出所需的资源；相比之下，CDN 服务器则像一个仓库，它只充当资源的“栖息地”和“搬运工”。</p><p>所谓<strong>静态资源</strong>，就是<strong>像 JS、CSS、图片等不需要业务服务器进行计算即得的资源</strong>。而<strong>动态资源</strong>，顾名思义是需要<strong>后端实时动态生成的资源</strong>，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。</p><p>什么是<strong>非纯静态资源</strong>呢？它是<strong>指需要服务器在页面之外作额外计算的 HTML 页面</strong>。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它<strong>和业务服务器的操作耦合</strong>，我们把它丢到CDN 上显然是不合适的。</p><h3 id="CDN-的实际应用"><a href="#CDN-的实际应用" class="headerlink" title="CDN 的实际应用"></a>CDN 的实际应用</h3><p>静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。</p><p>首先，CDN服务器域名与业务服务器域名不一致。</p><p>例如淘宝，业务服务器域名为“<a href="http://www.taobao.com”，而CDN" target="_blank" rel="noopener">www.taobao.com”，而CDN</a> 服务器的域名是“g.alicdn.com”</p><blockquote><p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息我现在并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是很大的。</p></blockquote><p>同一个域名下的请求会不分青红皂白地携带 Cookie，而静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！</p><h3 id="CDN-典型构成"><a href="#CDN-典型构成" class="headerlink" title="CDN 典型构成"></a>CDN 典型构成</h3><p>从功能上看，典型的CDN系统由分发服务系统，负载均衡系统和运营管理系统组成。</p><h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><p>最基本的工作单元就是Cache设备，cache（边缘cache）<strong>负责直接响应最终用户的访问请求</strong>，把缓存在本地的内容快速地提供给用户。同时cache还<strong>负责与源站点进行内容同步</strong>，把更新的内容以及本地没有的内容从源站点获取并保存在本地，（<a href="https://blog.csdn.net/starter_____/article/details/79255536" target="_blank" rel="noopener">webhook</a>）。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标。</p><h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><p>主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本 地负载均衡（SLB）。GSLB主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。SLB主要负责节点内部的设备负载均衡。</p><h4 id="运营管理系统"><a href="#运营管理系统" class="headerlink" title="运营管理系统"></a>运营管理系统</h4><p>分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p><p>负责为用户提供内容服务的cache设备应部署在物理上的网络边缘位置，即CDN边缘层。CDN系统中负责全局性管理和控制的设备组成中心层（二级缓存），中心层同时保存着最多的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站 回源（如果是流媒体，代价很大）。</p><p>CDN骨干点和CDN POP点在功能上不同，中心和区域节点一般称为骨干点，主要作为内容分发和边缘未命中时的服务点；边缘节点又被称为POP（point of presence）节点，CDN POP点主要作为直接向用户提供服务的节点。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
