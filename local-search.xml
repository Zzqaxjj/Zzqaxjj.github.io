<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SEO</title>
    <link href="/uncategorized/SEO/"/>
    <url>/uncategorized/SEO/</url>
    
    <content type="html"><![CDATA[<h3 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a>前端需要注意哪些SEO</h3><ol><li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li><li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用js输出：爬虫不会执行js获取内容</li><li>少用iframe：搜索引擎不会抓取iframe中的内容</li><li>非装饰性图片必须加alt</li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP</title>
    <link href="/uncategorized/TCP/"/>
    <url>/uncategorized/TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP（Transmission Control Protocol），又叫传输控制协议。<br>TCP协议是面向连接的，可靠的，基于字节流的传输协议。在基于 TCP 进行通信时，通信双方需要先建立一个 TCP 连接，建立连接需要经过三次握手，断开连接的时候需要经过四次挥手。</p><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p><img src="../img/TCP.png" srcset="/img/loading.gif" alt="TCP header"></p><p>对于 TCP 头部来说，以下几个字段是很重要的:</p><ul><li><p><code>序列号</code> （Sequence number），这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</p></li><li><p><code>确认号</code> （Acknowledgement Number），这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</p></li><li><p><code>窗口大小</code> （Window Size），表示还能接收多少字节的数据，用于流量控制</p></li><li><p><code>标识符</code></p><ul><li>ACK=1 ：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</li><li>SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li><li>FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。</li><li>URG=1 :  该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li><li>PSH=1 ：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li><li>RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li></ul></li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="../img/thr-handshake.png" srcset="/img/loading.gif" alt="三次握手"></p><p>简单的说：</p><ul><li><p>第一次握手</p><ul><li>SYN = 1， seq(client) = x</li><li>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li></ul></li><li><p>第二次握手</p><ul><li>SYN = 1，ACK = 1，确认序号 = x+1, seq(server) = y</li><li>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态</li></ul></li><li><p>第三次握手</p><ul><li>ACK = 1，确认序号 = y+1, seq(client) = x + 1</li><li>客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li></ul></li></ul><h3 id="为什么不用两次握手？"><a href="#为什么不用两次握手？" class="headerlink" title="为什么不用两次握手？"></a>为什么不用两次握手？</h3><p>主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>假设有这样一种场景, 客户端发送的第一个请求连接并且没有丢失，但是被滞留的时间太长。由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送报文。<br>而现在第一个请求到达服务端，这个请求已经报废了，但是又会建立连接。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="../img/quarticBye.png" srcset="/img/loading.gif" alt="四次挥手"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p><ul><li><p>第一次挥手</p><ul><li>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</li></ul></li><li><p>第二次挥手</p><ul><li>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 <strong>CLOSE_WAIT</strong> 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 <strong>TCP 连接时双向的</strong>，所以 B 仍旧可以发送数据给 A。</li></ul></li><li><p>第三次挥手</p><ul><li>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入<strong>LAST-ACK</strong>状态。</li><li>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。</li></ul></li><li><p>第四次挥手</p><ul><li>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 <strong>TIME-WAIT</strong> 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 <strong>CLOSED</strong> 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</li></ul></li></ul><h3 id="为什么-A-要进入-TIME-WAIT-状态，等待-2MSL-时间后才进入-CLOSED-状态？"><a href="#为什么-A-要进入-TIME-WAIT-状态，等待-2MSL-时间后才进入-CLOSED-状态？" class="headerlink" title="为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？"></a>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</h3><p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p><h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 </p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了</p><h2 id="ARQ-（超时重传）协议"><a href="#ARQ-（超时重传）协议" class="headerlink" title="ARQ （超时重传）协议"></a>ARQ （超时重传）协议</h2><p>通过确认和超时机制保证了数据的正确送达，ARQ 协议包含<code>停止等待 ARQ</code> 和<code>连续 ARQ</code></p><h3 id="停止等待-ARQ"><a href="#停止等待-ARQ" class="headerlink" title="停止等待 ARQ"></a>停止等待 ARQ</h3><p><strong>正常传输过程</strong></p><p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p><p><strong>当报文丢失或出错：</strong></p><p>报文传输的过程中丢包： 这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p><p>传输过程中报文出错： 对端会抛弃该报文并等待 A 端重传。</p><p>PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。</p><p><strong>ACK 超时或丢失：</strong></p><p>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p><p>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK 。</p><h3 id="连续-ARQ"><a href="#连续-ARQ" class="headerlink" title="连续 ARQ"></a>连续 ARQ</h3><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1的数据。</p><p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>上面讲到了发送窗口。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。</p><p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。</p><p><img src="../img/slideWindow.png" srcset="/img/loading.gif" alt="滑动窗口"></p><p>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p><p>当发送端接收到应答报文后，会随之将窗口进行滑动</p><p><strong>滑动窗口实现了流量控制</strong>。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p><p><strong>Zero 窗口</strong></p><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p><h2 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h2><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p><h3 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h3><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口从1开始指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p><p>慢开始算法步骤具体如下</p><ol><li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li><li>每过一个 RTT (往返时延) 就将窗口大小乘二</li><li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法</li></ol><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p><img src="../img/ysbm.png" srcset="/img/loading.gif" alt="拥塞避免"></p><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p><p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 1 MSS</li><li>启动拥塞避免算法</li></ul><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p><h3 id="RTT与RTO"><a href="#RTT与RTO" class="headerlink" title="RTT与RTO"></a>RTT与RTO</h3><ul><li><strong>RTT</strong>(Round Trip Time)<ul><li>一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值。 </li></ul></li><li><strong>RTO</strong>(Retransmission Time Out)<ul><li>重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。 </li></ul></li><li>RTT和RTO 的关系是<ul><li>由于网络波动的不确定性，每个RTT都是动态变化的，所以RTO也应随着RTT动态变化。</li></ul></li></ul><p><a href="https://blog.csdn.net/whgtheone/article/details/80970292" target="_blank" rel="noopener">博客链接</a></p><h3 id="TCP-小结"><a href="#TCP-小结" class="headerlink" title="TCP 小结"></a>TCP 小结</h3><p>为什么TCP这么复杂?</p><p>因为既要保证可靠性, 同时又要尽可能提高性能</p><p>保证可靠性的机制</p><ul><li>校验和</li><li>序列号(按序到达)</li><li>确认应答</li><li>超时重传</li><li>连接管理</li><li>流量控制</li><li>拥塞控制</li></ul><p>提高性能的机制</p><ul><li>滑动窗口</li><li>快速重传</li><li>延迟应答</li><li>捎带应答</li></ul><p>定时器</p><ul><li>超时重传定时器</li><li>保活定时器</li><li>TIME_WAIT定时器</li></ul><h3 id="基于-TCP-的应用层协议"><a href="#基于-TCP-的应用层协议" class="headerlink" title="基于 TCP 的应用层协议"></a>基于 TCP 的应用层协议</h3><ul><li>HTTP</li><li>HTTPS</li><li>SSH</li><li>Telnet</li><li>FTP</li><li>SMTP</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RESTful</title>
    <link href="/uncategorized/RESTful/"/>
    <url>/uncategorized/RESTful/</url>
    
    <content type="html"><![CDATA[<h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h1><p>REST (Representational State Transfer)，中文意思是：表述性状态转移。 一组架构约束条件和原则，如果一个架构符合 REST 的约束条件和原则，我们就称它为 RESTful 架构。</p><p>RESTful基本概念</p><ul><li>在 REST 中，一切的内容都被认为是一种资源</li><li>每个资源都由 URI 唯一标识</li><li>使用统一的接口处理资源请求（POST/GET/PUT/DELETE/HEAD）</li><li>无状态（每次请求之前是无关联，没有 session ）</li></ul><h2 id="理解RESTful"><a href="#理解RESTful" class="headerlink" title="理解RESTful"></a>理解RESTful</h2><p>下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。</p><ul><li>资源与URI</li><li>统一资源接口</li><li>资源的表述</li><li>资源的链接</li><li>状态的转移</li></ul><h3 id="资源和URI"><a href="#资源和URI" class="headerlink" title="资源和URI"></a>资源和URI</h3><ul><li>使用 <code>/</code> 来表示资源的层级关系</li><li>使用 <code>?</code> 用来过滤资源</li><li>使用 <code>_</code> 或者 <code>-</code> 让URI的可读性更好</li><li><code>,</code> 或 <code>;</code> 可以用来表示同级资源的关系</li></ul><h3 id="统一资源接口"><a href="#统一资源接口" class="headerlink" title="统一资源接口"></a>统一资源接口</h3><table><thead><tr><th>请求方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>获取某个资源。 幂等（取多少次结果都没有变化）</td></tr><tr><td>POST</td><td>创建一个新的资源</td></tr><tr><td>PUT</td><td>替换某个已有的资源（更新操作） ， 幂等（更新多次只保存一个结果）</td></tr><tr><td>DELETE</td><td>删除某个资源</td></tr><tr><td>HEAD</td><td>主要用于确认 URL 的有效性以及资源更新的日期时间等</td></tr><tr><td>PATCH</td><td>新引入的，对PUT方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><h3 id="资源表述"><a href="#资源表述" class="headerlink" title="资源表述"></a>资源表述</h3><p>客户端获取的只是资源的表述而已。资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。文本资源可以采用 html、xml、json 等格式，图片可以使用 PNG 或 JPG 展现出来。</p><p>资源的表述包括数据和描述数据的元数据，例如，HTTP 头 “Content-Type” 就是这样一个元数据属性。</p><p>那么客户端如何知道服务端提供哪种表述形式呢？</p><p>答案是可以通过 HTTP 内容协商，客户端可以通过 Accept 头请求一种特定格式的表述，服务端则通过 Content-Type 告诉客户端资源的表述形式。</p><p>MIME 类型</p><p>accept: text/xml html文件</p><p>Content-Type告诉客户端资源的表述形式</p><h3 id="资源的链接"><a href="#资源的链接" class="headerlink" title="资源的链接"></a>资源的链接</h3><p>超媒体即应用状态引擎（可以做多层链接）</p><p><a href="https://api.github.com/repos/github" target="_blank" rel="noopener">https://api.github.com/repos/github</a></p><pre><code>{  &quot;message&quot;: &quot;Not Found&quot;,  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;}</code></pre><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>服务器端不应该保存客户端状态。</p><p>应用状态 -&gt; 服务器端不保存应用状态</p><p>访问订单 根据接口去查询</p><p>访问商品 查询</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nginx</title>
    <link href="/uncategorized/nginx/"/>
    <url>/uncategorized/nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx代理"><a href="#nginx代理" class="headerlink" title="nginx代理"></a>nginx代理</h1><h3 id="nginx基本代理"><a href="#nginx基本代理" class="headerlink" title="nginx基本代理"></a>nginx基本代理</h3><pre><code>server {  listen        80;  # 访问的域名  server_name   test.com;  # 代理请求  location / {    proxy_pass http://127.0.0.1:8888;    # 设置HTTP头中修改host为test.com    proxy_set_header Host $host;  }}</code></pre><h3 id="nginx配置缓存"><a href="#nginx配置缓存" class="headerlink" title="nginx配置缓存"></a>nginx配置缓存</h3><pre><code># 写在server外proxy_cache_path  cache levels=1:2 keys_zoom=my_cache:10m</code></pre><ul><li>cache<ul><li>文件夹名</li></ul></li><li>levels=1:2<ul><li>设置二级文件夹来存缓存，因为随着文件的越来越多查找速度会越来越慢</li></ul></li><li>keys_zoom=my_cache:10m<ul><li>申请10兆内存来缓存内容</li></ul></li></ul><pre><code>server {  listen        80;  server_name   test.com;  location / {    proxy_cache   my_cache; #在这里写缓存    proxy_pass http://127.0.0.1:8888;    proxy_set_header Host $host;  }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS</title>
    <link href="/uncategorized/HTTPS/"/>
    <url>/uncategorized/HTTPS/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>http默认采用80作为通讯端口，对于传输采用不加密的方式，https默认采用443，对于传输的数据进行加密传输。</p><h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><p>明文： 明文指的是未被加密过的原始数据。</p><p>密文：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。</p><p>密钥：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。</p><pre><code>其加密过程如下：明文 + 加密算法 + 私钥 =&gt; 密文解密过程如下：密文 + 解密算法 + 私钥 =&gt; 明文</code></pre><p>对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。</p><p>其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。</p><ul><li><p><strong>被公钥加密过的密文只能被私钥解密</strong>，过程如下：</p><pre><code>明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文</code></pre></li><li><p><strong>被私钥加密过的密文只能被公钥解密</strong>，过程如下：</p><pre><code>明文 + 加密算法 + 私钥 =&gt; 密文， 密文 + 解密算法 + 公钥 =&gt; 明文</code></pre></li></ul><p>由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。<br>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br>在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p><h2 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h2><p><strong>HTTPS协议 = HTTP协议 + SSL/TLS协议</strong>，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。</p><p><strong>SSL</strong>的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0。</p><p><strong>TLS</strong>的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。</p><p>HTTPS为了兼顾安全与效率，<strong>同时使用了对称加密和非对称加密</strong>。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，<strong>对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输</strong>。</p><p><img src="../img/httpscrypt.png" srcset="/img/loading.gif" alt="加密"></p><p>HTTPS在传输的过程中会涉及到三个密钥：</p><ul><li>服务器端的公钥和私钥，用来进行非对称加密</li><li>客户端生成的随机密钥，用来进行对称加密</li></ul><p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。</p><ol><li>客户端向服务器发起HTTPS请求，连接到服务器的443端口</li><li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</li><li>服务器将自己的公钥发送给客户端。</li><li>客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>然后服务器将加密后的密文发送给客户端。</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</li></ol><p>原文链接：<a href="https://www.jianshu.com/p/14cd2c9d2cd2" target="_blank" rel="noopener">https://www.jianshu.com/p/14cd2c9d2cd2</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/uncategorized/HTTP/"/>
    <url>/uncategorized/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><h3 id="HTTP-协议的特点"><a href="#HTTP-协议的特点" class="headerlink" title="HTTP 协议的特点"></a>HTTP 协议的特点</h3><ul><li>无连接<ul><li>限制每次连接只处理一个请求</li></ul></li><li>无状态<ul><li>协议对于事务处理没有记忆能力。</li></ul></li><li>简单快速<ul><li>客户向服务器请求服务时，只需传送请求方法和路径。</li></ul></li><li>灵活<ul><li>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li></ul></li></ul><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><ul><li>请求行<ul><li>请求类型</li><li>要访问的资源</li><li>HTTP协议版本号</li></ul></li><li>请求头<ul><li>用来说明服务器要使用的附加信息（一些键值对）</li><li>例如：User-Agent、 Accept、Content-Type、Connection</li></ul></li><li>空行<ul><li>分割请求头与请求体</li></ul></li><li>请求体<ul><li>可以添加任意的其他数据</li></ul></li></ul><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><ul><li>状态行<ul><li>状态码</li><li>状态消息 </li><li>HTTP协议版本号</li></ul></li><li>消息报头<ul><li>说明客户端要使用的一些附加信息</li><li>如：Content-Type、charset、响应的时间</li></ul></li><li>响应正文<ul><li>返回给客户端的文本信息 </li></ul></li></ul><h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><ul><li>GET<ul><li>获取资源</li></ul></li><li>POST<ul><li>传输资源</li></ul></li><li>PUT<ul><li>更新资源</li></ul></li><li>DELETE<ul><li>删除资源</li></ul></li><li>HEAD<ul><li>获取报文首部</li></ul></li></ul><h3 id="Post-和-Get-的区别"><a href="#Post-和-Get-的区别" class="headerlink" title="Post 和 Get 的区别"></a>Post 和 Get 的区别</h3><ul><li>GET在浏览器回退时是无害的，而POST会再次提交</li><li>Get请求能缓存，Post不能</li><li>Post相对Get相对安全一些，因为Get请求都包含在URL中，而且会被浏览器保存记录，Post不会。但是再抓包的情况下都是一样的。</li><li>Post 可以通过 request body来传输比 Get 更多的数据 </li><li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的</li><li>Post 支持更多的编码类型且不对数据类型限制</li><li>POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)</li></ul><p>先引入副作用和幂等的概念。<br>副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。<br>幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。<br>在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。</p><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><h4 id="1XX-指示信息"><a href="#1XX-指示信息" class="headerlink" title="1XX 指示信息"></a>1XX 指示信息</h4><p>表示请求已接收，继续处理</p><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul><li><strong>200</strong> OK</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li><strong>206</strong> Partial Content，进行范围请求</li></ul><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul><li><strong>301</strong> 永久性重定向，表示资源已被分配了新的 URL</li><li><strong>302</strong> 临时性重定向，表示资源临时被分配了新的 URL</li><li>303 表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li><strong>304</strong> 未修改，重定位到浏览器。自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</li><li>307 临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><ul><li><strong>404</strong> 在服务器上没有找到请求的资源</li><li><strong>403</strong> forbidden，表示对请求资源的访问被服务器拒绝</li><li>400 请求报文存在语法错误</li><li>401  表示发送的请求需要有通过 HTTP 认证的认证信息</li></ul><h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><ul><li><strong>500</strong> 表示服务器端在执行请求时发生了错误</li><li>501 表示服务器不支持当前请求所需要的某个功能</li><li><strong>503</strong> 表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h3 id="HTTP持久连接（HTTP1-1支持）"><a href="#HTTP持久连接（HTTP1-1支持）" class="headerlink" title="HTTP持久连接（HTTP1.1支持）"></a>HTTP持久连接（HTTP1.1支持）</h3><p>HTTP协议采用“请求-应答”模式，并且HTTP是基于TCP进行连接的。普通模式（非keep-alive）时，每个请求或应答都需要建立一个连接，完成之后立即断开。</p><p>当使用<code>Conection: keep-alive</code>模式（又称持久连接、连接重用）时，keep-alive使客户端道服务器端连接持续有效，即不关闭底层的TCP连接，当出现对服务器的后继请求时，keep-alive功能避免重新建立连接。</p><h3 id="HTTP管线化-（HTTP1-1支持）"><a href="#HTTP管线化-（HTTP1-1支持）" class="headerlink" title="HTTP管线化 （HTTP1.1支持）"></a>HTTP管线化 （HTTP1.1支持）</h3><p><img src="../img/pipe.png" srcset="/img/loading.gif" alt="pipe"></p><p>管线化后，请求和响应不再是依次交替的了。他可以支持一次性发送多个请求，并一次性接收多个响应。</p><ul><li>只有get与head请求可以进行管线化，POST有限制</li><li>初次创建连接时不应该启动管线机制，因为服务器不一定支持该协议</li></ul><h3 id="HTTP数据协商"><a href="#HTTP数据协商" class="headerlink" title="HTTP数据协商"></a>HTTP数据协商</h3><p>在客户端向服务端发送请求的时候，客户端会申明可以接受的数据格式和数据相关的一些限制是什么样的；服务端在接受到这个请求时他会根据这个信息进行判断到底返回怎样的数据。</p><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><ul><li>Accept <ul><li>在请求中使用Accept可申明想要的数据格式</li></ul></li><li>Accept-Encoding<ul><li>告诉服务端使用什么的方式来进行压缩</li><li>例如：gzip、deflate、br</li></ul></li><li>Accept-Language<ul><li>描述语言信息</li></ul></li><li>User-Agent<ul><li>用来描述客户端浏览器相关信息</li><li>可以用来区分PC端页面和移动端页面</li></ul></li></ul><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><ul><li>Content-Type<ul><li>对应Accept，从请求中的Accept支持的数据格式中选一种来返回</li></ul></li><li>Content-Encoding<ul><li>对应 Accept-Encoding，指服务端到底使用的是那种压缩方式</li></ul></li><li>Content-Language<ul><li>对应Accept-Language</li></ul></li></ul><h4 id="form-表单中enctype数据类型"><a href="#form-表单中enctype数据类型" class="headerlink" title="form 表单中enctype数据类型"></a>form 表单中enctype数据类型</h4><ul><li><code>application/x-www-form-urlencoded</code><ul><li>key=value&amp;key=value 格式</li></ul></li><li><code>multipart/form-data</code><ul><li>用于提交文件</li><li>multipart表示请求是由多个部分组成（因为上传文件的时候文件不能以字符串形式提交，需要单独分出来）</li><li>boundary 用来分隔不同部分</li></ul></li><li><code>text/plain</code></li></ul><h3 id="HTTP-Redirect-重定向"><a href="#HTTP-Redirect-重定向" class="headerlink" title="HTTP Redirect 重定向"></a>HTTP Redirect 重定向</h3><ul><li>302 暂时重定向<ul><li>浏览器每次访问都要先去目标网址访问，再重定向到新的网址</li></ul></li><li>301 永久重定向<ul><li>当浏览器收到的HTTP状态码为301时，下次访问对应网址就直接调整到新的网址，不会再访问原网址</li></ul></li></ul><h3 id="HTTP-CSP-内容安全策略"><a href="#HTTP-CSP-内容安全策略" class="headerlink" title="HTTP CSP 内容安全策略"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP" target="_blank" rel="noopener">HTTP CSP 内容安全策略</a></h3><p>CSP Content-Security-Policy</p><ul><li>限制资源获取</li><li>报告资源获取越权</li></ul><p>例子：</p><ul><li><code>Content-Security-Policy: default-src http: https:</code> 表示只允许通过http、https的方式加载资源</li><li><code>&#39;Content-Security-Policy&#39;: &#39;default-src&#39; \&#39;self\&#39;; form-action\&#39;self\&#39; &#39;</code> 表示只能加载本域下的资源，只能向本域发送表单请求</li></ul><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。</p><p>HTTP2采用<code>二进制格式传输</code>，取代了HTTP1.x的文本格式，二进制格式解析更高效。<br><code>多路复用</code>代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。</p><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p>HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。<br>HTTP2中</p><ul><li>同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。</li><li>单个连接上可以并行交错的请求和响应，之间互不干扰</li></ul><p>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</p><p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p><p><strong>多路复用，就是在一个 TCP 连接中可以存在多条流。</strong> 换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p><p><img src="../img/http2Connet.png" srcset="/img/loading.gif" alt="http2"></p><h3 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h3><p>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p><h3 id="服务端-Push"><a href="#服务端-Push" class="headerlink" title="服务端 Push"></a>服务端 Push</h3><p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p><p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。</p><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><table><thead><tr><th align="center">通用字段</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">浏览器想要优先使用的连接类型，比如  <code>keep-alive</code></td></tr><tr><td align="center">Date</td><td align="center">创建报文时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Via</td><td align="center">代理服务器相关信息</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">要求客户端升级协议</td></tr><tr><td align="center">Warning</td><td align="center">在内容中可能存在错误</td></tr></tbody></table><table><thead><tr><th align="center">请求字段</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">能正确接收的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">能正确接收的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">能正确接收的编码格式列表</td></tr><tr><td align="center">Accept-Language</td><td align="center">能正确接收的语言列表</td></tr><tr><td align="center">Expect</td><td align="center">期待服务端的指定行为</td></tr><tr><td align="center">From</td><td align="center">请求方邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">服务器的域名</td></tr><tr><td align="center">If-Match</td><td align="center">两端资源标记比较</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">本地资源未修改返回 304（比较时间）</td></tr><tr><td align="center">If-None-Match</td><td align="center">本地资源未修改返回 304（比较标记）</td></tr><tr><td align="center">User-Agent</td><td align="center">客户端信息</td></tr><tr><td align="center">Max-Forwards</td><td align="center">限制可被代理及网关转发的次数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">向代理服务器发送验证信息</td></tr><tr><td align="center">Range</td><td align="center">请求某个内容的一部分</td></tr><tr><td align="center">Referer</td><td align="center">表示浏览器所访问的前一个页面</td></tr><tr><td align="center">TE</td><td align="center">传输编码方式</td></tr></tbody></table><table><thead><tr><th align="center">响应字段</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否支持某些种类的范围</td></tr><tr><td align="center">Age</td><td align="center">资源在代理缓存中存在的时间</td></tr><tr><td align="center">ETag</td><td align="center">资源标识</td></tr><tr><td align="center">Location</td><td align="center">客户端重定向到某个 URL</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">向代理服务器发送验证信息</td></tr><tr><td align="center">Server</td><td align="center">服务器名字</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">获取资源需要的验证信息</td></tr></tbody></table><table><thead><tr><th align="center">实体字段</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源的正确请求方式</td></tr><tr><td align="center">Content-Encoding</td><td align="center">内容的编码格式</td></tr><tr><td align="center">Content-Language</td><td align="center">内容使用的语言</td></tr><tr><td align="center">Content-Length</td><td align="center">request body 长度</td></tr><tr><td align="center">Content-Location</td><td align="center">返回数据的备用地址</td></tr><tr><td align="center">Content-MD5</td><td align="center">Base64加密格式的内容 MD5检验值</td></tr><tr><td align="center">Content-Range</td><td align="center">内容的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">内容的媒体类型</td></tr><tr><td align="center">Expires</td><td align="center">内容的过期时间</td></tr><tr><td align="center">Last_modified</td><td align="center">内容的最后修改时间</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CDN</title>
    <link href="/uncategorized/CDN/"/>
    <url>/uncategorized/CDN/</url>
    
    <content type="html"><![CDATA[<h1 id="CDN-的缓存与回源机制解析"><a href="#CDN-的缓存与回源机制解析" class="headerlink" title="CDN 的缓存与回源机制解析"></a>CDN 的缓存与回源机制解析</h1><p>CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p><h3 id="CDN的核心功能"><a href="#CDN的核心功能" class="headerlink" title="CDN的核心功能"></a>CDN的核心功能</h3><p>CDN 的核心点有两个，一个是<strong>缓存</strong>，一个是<strong>回源</strong>。</p><ul><li>“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程</li><li>“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</li></ul><h3 id="CDN-与前端性能优化"><a href="#CDN-与前端性能优化" class="headerlink" title="CDN 与前端性能优化"></a>CDN 与前端性能优化</h3><p>CDN 往往被用来<strong>存放静态资源</strong>。 </p><p>“根服务器”本质上是业务服务器，它的核心任务在于生成”动态页面”或返回”非纯静态页面”(需要计算的)。业务服务器仿佛一个车间，车间里运转的机器轰鸣着为我们产出所需的资源；相比之下，CDN 服务器则像一个仓库，它只充当资源的“栖息地”和“搬运工”。</p><p>所谓<strong>静态资源</strong>，就是<strong>像 JS、CSS、图片等不需要业务服务器进行计算即得的资源</strong>。而<strong>动态资源</strong>，顾名思义是需要<strong>后端实时动态生成的资源</strong>，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。</p><p>什么是<strong>非纯静态资源</strong>呢？它是<strong>指需要服务器在页面之外作额外计算的 HTML 页面</strong>。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它<strong>和业务服务器的操作耦合</strong>，我们把它丢到CDN 上显然是不合适的。</p><h3 id="CDN-的实际应用"><a href="#CDN-的实际应用" class="headerlink" title="CDN 的实际应用"></a>CDN 的实际应用</h3><p>静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。</p><p>首先，CDN服务器域名与业务服务器域名不一致。</p><p>例如淘宝，业务服务器域名为“<a href="http://www.taobao.com”，而CDN" target="_blank" rel="noopener">www.taobao.com”，而CDN</a> 服务器的域名是“g.alicdn.com”</p><blockquote><p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息我现在并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是很大的。</p></blockquote><p>同一个域名下的请求会不分青红皂白地携带 Cookie，而静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！</p><h3 id="CDN-典型构成"><a href="#CDN-典型构成" class="headerlink" title="CDN 典型构成"></a>CDN 典型构成</h3><p>从功能上看，典型的CDN系统由分发服务系统，负载均衡系统和运营管理系统组成。</p><h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><p>最基本的工作单元就是Cache设备，cache（边缘cache）<strong>负责直接响应最终用户的访问请求</strong>，把缓存在本地的内容快速地提供给用户。同时cache还<strong>负责与源站点进行内容同步</strong>，把更新的内容以及本地没有的内容从源站点获取并保存在本地，（<a href="https://blog.csdn.net/starter_____/article/details/79255536" target="_blank" rel="noopener">webhook</a>）。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标。</p><h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><p>主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本 地负载均衡（SLB）。GSLB主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。SLB主要负责节点内部的设备负载均衡。</p><h4 id="运营管理系统"><a href="#运营管理系统" class="headerlink" title="运营管理系统"></a>运营管理系统</h4><p>分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p><p>负责为用户提供内容服务的cache设备应部署在物理上的网络边缘位置，即CDN边缘层。CDN系统中负责全局性管理和控制的设备组成中心层（二级缓存），中心层同时保存着最多的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站 回源（如果是流媒体，代价很大）。</p><p>CDN骨干点和CDN POP点在功能上不同，中心和区域节点一般称为骨干点，主要作为内容分发和边缘未命中时的服务点；边缘节点又被称为POP（point of presence）节点，CDN POP点主要作为直接向用户提供服务的节点。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/uncategorized/Ajax/"/>
    <url>/uncategorized/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX" target="_blank" rel="noopener">Ajax | MDN</a></p><p>AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XML）。简单点说，就是使用 XMLHttpRequest 对象与服务器通信。 它可以使用JSON，XML，HTML和text文本等格式发送和接收数据。AJAX最吸引人的就是它的“异步”特性，也就是说他可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p><h3 id="创建一个简单的Ajax"><a href="#创建一个简单的Ajax" class="headerlink" title="创建一个简单的Ajax"></a>创建一个简单的Ajax</h3><ul><li><p>创建 XMLHttpRequest 对象</p><pre><code class="js">if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ... httpRequest = new XMLHttpRequest();} else if (window.ActiveXObject) { // IE 6 and older httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);}</code></pre></li><li><p>绑定onreadystatechange 事件</p><pre><code class="js">httpRequest.onreadystatechange = function(){ // Process the server response here.};</code></pre></li><li><p>向服务器发送请求</p><pre><code class="js">httpRequest.open(&#39;GET&#39;, &#39;http://www.example.org/some.file&#39;, true);httpRequest.send();</code></pre></li></ul><p>完整的例子</p><pre><code class="js">function ajax(url, cb) {  let xhr;  if(window.XMLHttpRequest) {    xhr = new XMLHttpRequest();  } else {    xhr = ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);  }  xhr.onreadystatechange = function() {    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) {      cb(xhr.responseText);    }   }  xhr.open(&#39;GET&#39;, url, true);  xhr.send();}</code></pre><h3 id="httpRequest-readyState的值"><a href="#httpRequest-readyState的值" class="headerlink" title="httpRequest.readyState的值"></a>httpRequest.readyState的值</h3><ul><li>0 (未初始化) or (请求还未初始化)</li><li>1 (正在加载) or (已建立服务器链接)</li><li>2 (加载成功) or (请求已接受)</li><li>3 (交互) or (正在处理请求)</li><li>4 (完成) or (请求已完成并且响应已准备好)</li></ul><h3 id="访问服务端返回的数据"><a href="#访问服务端返回的数据" class="headerlink" title="访问服务端返回的数据"></a>访问服务端返回的数据</h3><ul><li>httpRequest.responseText<ul><li>服务器以文本字符的形式返回</li></ul></li><li>httpRequest.responseXML <ul><li>以 XMLDocument 对象方式返回，之后就可以使用JavaScript来处理</li></ul></li></ul><h3 id="GET-注意事项"><a href="#GET-注意事项" class="headerlink" title="GET 注意事项"></a>GET 注意事项</h3><ul><li>如果不设置响应头 <code>Cache-Control: no-cache</code> 浏览器将会把响应缓存下来而且再也不无法重新提交请求。你也可以添加一个总是不同的 GET 参数，比如时间戳或者随机数 (详情见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache" target="_blank" rel="noopener">bypassing the cache</a>)</li></ul><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p>POST请求则需要设置<code>RequestHeader</code>告诉后台传递内容的编码方式以及在send方法里传入对应的值</p><pre><code class="js">xhr.open(&quot;POST&quot;, url, true);xhr.setRequestHeader(&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;);xhr.send(&quot;key1=value1&amp;key2=value2&quot;);</code></pre><h3 id="Ajax与cookie"><a href="#Ajax与cookie" class="headerlink" title="Ajax与cookie"></a>Ajax与cookie</h3><ul><li>ajax会自动带上同源的cookie，不会带上不同源的cookie</li><li>可以通过前端设置withCredentials为true， 后端设置Header的方式让ajax自动带上不同源的cookie，但是这个属性对同源请求没有任何影响。会被自动忽略。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials" target="_blank" rel="noopener">withCredentials | MDN</a></p><pre><code class="js">var xhr = new XMLHttpRequest();xhr.open(&#39;GET&#39;, &#39;http://example.com/&#39;, true);xhr.withCredentials = true;xhr.send(null);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UDP</title>
    <link href="/uncategorized/UDP/"/>
    <url>/uncategorized/UDP/</url>
    
    <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP（User Datagram Protocol），又叫用户数据报协议。<br>UDP是一个无连接的、不可靠、基于数据报的传输协议。UDP只是报文（报文可以理解为一段段的数据）的搬运工，不会对报文进行任何拆分和拼装操作。</p><p>具体来说</p><ul><li>在发送端，应用层将数据传递给传输层，UDP只会给数据怎加一个UDP头标识一下这是UDP，然后就传递给网络层了，不进行任何拆分。</li><li>在接收端，网络层将数据传递给传输层，UDP只取出IP报文头就传递给应用层，不进行任何拼装。</li></ul><p>特点：</p><ul><li>面向报文</li><li>不可靠传输</li><li>高效</li></ul><p>应用场景：<br>当强调输出性能而非完整性时，如音频和多媒体的实时传输。有个视频流传输协议RTP的实时传输就是基于UDP封装而来的。</p><h3 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h3><ol><li>UDP是<strong>无连接</strong>的，也就是说同学不需要建立和断开链接。</li><li>UDP是不可靠的。它不会去备份数据，也不关心对方是否能收到数据。</li><li>UDP<strong>没有拥塞控制</strong>，一直以恒定的速度发送数据，即使网络条件不好，也不进行速率调整。 造成的弊端就是在网络条件不好时可能导致丢包。</li></ol><h3 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h3><p>因为 UDP 没有 TCP 那么复杂，不需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。</p><p>UDP包头部包含了以下几个数据</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p><img src="../img/UDP.png" srcset="/img/loading.gif" alt="UDP Header"></p><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>支持一对一，一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hybird</title>
    <link href="/uncategorized/hybird/"/>
    <url>/uncategorized/hybird/</url>
    
    <content type="html"><![CDATA[<h1 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h1><h3 id="hybrid是什么，为何会使用hybrid"><a href="#hybrid是什么，为何会使用hybrid" class="headerlink" title="hybrid是什么，为何会使用hybrid"></a>hybrid是什么，为何会使用hybrid</h3><p>hybrid即”混合”，即前端和客户端的混合开发，某些环节也可能涉及server端</p><p>hybird存在的核心意义在于快速迭代，无需审核</p><p>具体实现：</p><ul><li>前端做好静态网页，将文件交给客户端</li><li>客户端拿到前端静态网页，以文件形式存储在app中</li><li>客户端在一个webview中</li><li>使用file协议加载静态页面</li></ul><h3 id="各技术适用场景"><a href="#各技术适用场景" class="headerlink" title="各技术适用场景"></a>各技术适用场景</h3><ul><li>使用NativeApp<ul><li>体验要求极致，变化不频繁</li></ul></li><li>使用hybrid<ul><li>体验要求高，变化频繁</li></ul></li><li>使用h5<br>-体验要求低，不常用</li></ul><h3 id="hybrid存在价值"><a href="#hybrid存在价值" class="headerlink" title="hybrid存在价值"></a>hybrid存在价值</h3><ul><li>可快速迭代更新</li><li>体验流畅</li><li>双端公用一套代码</li></ul><h3 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h3><ul><li>是app中的一个组件。</li><li>用于加载h5页面，即小型浏览器内核</li><li>只是单纯的展示一个网页界面 </li></ul><p><img src="../img/webview.png" srcset="/img/loading.gif" alt="webview"></p><h3 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h3><p>加载本地的资源<br><img src="../img/file.png" srcset="/img/loading.gif" alt="file"></p><h3 id="app发布后，静态文件如何实时更新？"><a href="#app发布后，静态文件如何实时更新？" class="headerlink" title="app发布后，静态文件如何实时更新？"></a>app发布后，静态文件如何实时更新？</h3><ul><li>将静态文件(html,css,js等)压缩成包，上传到服务端</li><li>客户端每次启动，都去服务端检查静态文件发布日期</li><li>如果服务端发布日期晚与客户端使用资源的发布日期，就去下载最新的压缩包</li><li>下载完成后解压，将现有文件覆盖</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>compose</title>
    <link href="/uncategorized/compose/"/>
    <url>/uncategorized/compose/</url>
    
    <content type="html"><![CDATA[<h2 id="函数式编程-compose"><a href="#函数式编程-compose" class="headerlink" title="函数式编程 compose"></a>函数式编程 compose</h2><p>实现以下功能：</p><pre><code class="js">compose([a, b, c])(&#39;参数&#39;)=&gt;a( b( c(&#39;参数&#39;) ) )</code></pre><pre><code class="js">function compose(funcs) {  var len = funcs.length;  var index = len - 1;  for(let i = 0; i &lt; len; i ++) {    if(typeof funcs[i] !== &#39;function&#39;) {      throw new TypeError(&#39;Expected function&#39;);    }  }  return function (...args) {    let result =  funcs[index](...args) // 第一次    while(--index &gt;= 0) {      result = funcs[index](result)    }    return result;  }}</code></pre><p>测试：</p><pre><code class="js">function a (str) {  return `a ${str}`}function b (str) {  return `b ${str}`}function c (str) {  return `c ${str}`}const abc = compose([a, b, c])abc(&#39;huyao&#39;)</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>bind、apply实现</title>
    <link href="/uncategorized/bind%E3%80%81apply%E5%AE%9E%E7%8E%B0/"/>
    <url>/uncategorized/bind%E3%80%81apply%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="自封装bind方法"><a href="#自封装bind方法" class="headerlink" title="自封装bind方法"></a>自封装bind方法</h3><ul><li>因为bind的使用方法是 某函数.bind(某对象，…剩余参数)<ul><li>所以需要在Function.prototype 上进行编程</li></ul></li><li>将传递的参数中的某对象和剩余参数使用apply的方式在一个回调函数中执行即可</li><li>要在第一层获取到被绑定函数的this，因为要拿到那个函数用apply</li></ul><pre><code class="js">/** * 简单版本  */Function.prototype.myBind = (that, ...args) =&gt; {  const funcThis = this;  return function(..._args) {    return funcThis.apply(that, args.concat(_args));  }}Function.prototype.mybind = function(ctx) {    var _this = this;    var args = Array.prototype.slice.call(arguments, 1);    return function() {        return _this.apply(ctx, args.concat(args, Array.prototype.slice.call(arguments)))    }}</code></pre><pre><code class="js">/** * 自封装bind方法 * @param  {对象} target [被绑定的this对象， 之后的arguments就是被绑定传入参数] * @return {[function]}  [返回一个新函数，这个函数就是被绑定了this的新函数] */Function.prototype.myBind = function (target){    target = target || window;    var self = this;    var args = [].slice.call(arguments, 1);    var temp = function(){};    var F = function() {        var _args = [].slice.call(arguments, 0);        return self.apply(this instanceof temp ? this: target, args.concat(_args));    }    temp.prototype = this.prototype;    //维护原型关系    F.prototype = new temp();    return F;}</code></pre><h3 id="自封装一个apply"><a href="#自封装一个apply" class="headerlink" title="自封装一个apply"></a>自封装一个apply</h3><ul><li>首先要先原型上即 Function.prototype上编程</li><li>需要拿到函数的引用， 在这里是 this</li><li>让 传入对象.fn = this</li><li>执行 传入对象.fn(传入参数)</li><li>返回执行结果</li></ul><pre><code class="js">Function.prototype.myApply = function(context) {  if (typeof this !== &#39;function&#39;) {    throw new TypeError(&#39;Error&#39;)  }  context = context || window  context.fn = this  let result  // 处理参数和 call 有区别  if (arguments[1]) {    result = context.fn(...arguments[1])  } else {    result = context.fn()  }  delete context.fn  return result}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PromiseAll</title>
    <link href="/uncategorized/PromiseAll/"/>
    <url>/uncategorized/PromiseAll/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p>Promise.all 接收一个 promise 对象的数组作为参数，当这个数组里的所有 promise 对象全部变为resolve或 有 reject 状态出现的时候，它才会去调用 .then 方法,它们是并发执行的。</p><h3 id="Promise-all-简介"><a href="#Promise-all-简介" class="headerlink" title="Promise.all 简介"></a>Promise.all 简介</h3><p>Promise.all(promiseArray) 方法是 Promise 对象上的静态方法，该方法的作用是将多个 Promise 对象实例包装，生成并返回一个新的 Promise 实例。</p><p>参数：promiseArray，是一个 Promise 实例数组</p><pre><code class="js">var p1 = Promise.resolve(1),    p2 = Promise.reject(2),    p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) {    //then方法不会被执行    console.log(results);}).catch(function (e){    //catch方法将会被执行，输出结果为：2    console.log(2);});</code></pre><p>promise 数组中所有的 promise 实例都变为resolve 的时候，该方法才会返回，并将所有结果传递 results 数组中。promise 数组中任何一个 promise 为 reject 的话，则整个 Promise.all 调用会立即终止，并返回一个 reject 的新的 promise 对象。</p><h3 id="总结-promise-all-的特点"><a href="#总结-promise-all-的特点" class="headerlink" title="总结 promise.all 的特点"></a>总结 promise.all 的特点</h3><ol><li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象，</li><li>如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</li><li>如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</li><li>只要有一个失败，状态就变为 rejected，返回值将直接传递给回调<br>all() 的返回值也是新的 Promise 对象</li></ol><h3 id="实现-Promise-all-方法"><a href="#实现-Promise-all-方法" class="headerlink" title="实现 Promise.all 方法"></a>实现 Promise.all 方法</h3><pre><code class="js">function promiseAll(promises) {  return new Promise(function(resolve, reject) {    if(isArray(promises)) {        return reject(new Error(&#39;Promises must be an array&#39;))    }    var resolvedCount = 0;    var promiseNum = promises.length;    var resloveValue = [];    for(let i = 0; i &lt; promiseNum; i++) {        Promise.resolve(promises[i]).then((value) =&gt; {            resloveValue[i] = value;            resolvedCount++;            if(resolvedCount === promiseNum) {                return resloveValue;            }        }, (reason) =&gt; {            return reject(reason);        })    }  })}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入</title>
    <link href="/uncategorized/SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/uncategorized/SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，后台执行SQL语句时直接把前端传入的字段拿来做SQL查询。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li>永远不要信任用户的输入。</li><li>永远不要使用动态拼装sql</li><li>不要把机密信息直接存放</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF</title>
    <link href="/uncategorized/CSRF/"/>
    <url>/uncategorized/CSRF/</url>
    
    <content type="html"><![CDATA[<h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h1><p>（Cross Site Request Forgy）<br>打开同一浏览器时其他的网站对本网站造成的影响。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。<br><img src="../img/csrf.png" srcset="/img/loading.gif" alt="原理"></p><p>举个例子，用户同时打开了A网站和钓鱼网站。 假设A网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口。</p><pre><code class="html">&lt;img src=&quot;http://www.domain.com/xxx?comment=&#39;attack&#39;&quot;/&gt;</code></pre><h2 id="CSRF攻击原理"><a href="#CSRF攻击原理" class="headerlink" title="CSRF攻击原理"></a>CSRF攻击原理</h2><ol><li>用户登录A网站</li><li>A网站确认身份（给客户端cookie）</li><li>B网站页面向A网站发起请求（带上A网站身份）</li></ol><h2 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h2><ol><li><p>Get 请求不对数据进行修改</p></li><li><p>不让第三方网站访问到用户 Cookie</p></li><li><p>阻止第三方网站请求接口</p></li><li><p>请求时附带验证信息，比如验证码或者 Token</p><ul><li>SameSite</li><li>可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</li><li>Token验证</li><li>cookie是发送时自动带上的，而不会主动带上Token，所以在每次发送时主动发送Token</li><li>Referer验证</li><li>对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。</li><li>隐藏令牌</li><li>主动在HTTP头部中添加令牌信息</li></ul></li></ol><p>禁止第三方网站带cookies</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#SameSite_Cookies" target="_blank" rel="noopener">same-site</a>属性。 设置只有同一站点的请求才能携带cookie</p><h2 id="CSRF蠕虫"><a href="#CSRF蠕虫" class="headerlink" title="CSRF蠕虫"></a>CSRF蠕虫</h2><p>如果某个用户打开了被攻击网页，并且用户同时访问了攻击者的网页。<br>那么攻击者的网页就会使用用户的身份发送一些请求，并且常用用户的身份发布一些评论或文章，里面包含攻击者的网页链接。如果其他用户看到了这个用户的这条评论，都甚至可以不点击，其他用户也会被盗用身份发送一些恶意请求。这样病毒的传播就会越来越快，影响越来越大。</p><h2 id="CSRF攻击危害"><a href="#CSRF攻击危害" class="headerlink" title="CSRF攻击危害"></a>CSRF攻击危害</h2><ul><li>利用用户登录态</li><li>用户不知情</li><li>完成业务请求</li><li></li><li>盗取用户资金</li><li>冒充用户发帖背锅</li><li>损坏网站名誉</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>package-lock.json</title>
    <link href="/uncategorized/package-lock.json/"/>
    <url>/uncategorized/package-lock.json/</url>
    
    <content type="html"><![CDATA[<h1 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h1><p>概括很简单，就是锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致。</p><p>根据官方文档，这个package-lock.json 是在 <code>npm install</code>时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。</p><p>它有什么用呢？因为npm是一个用于管理package之间依赖关系的管理器，它允许开发者在pacakge.json中间标出自己项目对npm各库包的依赖。你可以选择以如下方式来标明自己所需要库包的版本</p><p>这里举个例子：</p><pre><code class="json">&quot;dependencies&quot;: {    &quot;@types/node&quot;: &quot;^8.0.33&quot;,},</code></pre><p>这里面的 向上标号^是定义了向后（新）兼容依赖，指如果 types/node的版本是超过8.0.33，并在大版本号（8）上相同，就允许下载最新版本的 types/node库包，例如实际上可能运行npm install时候下载的具体版本是8.0.35。</p><p>大多数情况这种向新兼容依赖下载最新库包的时候都没有问题，可是因为npm是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。这时候用户就很头疼了：在完全相同的一个nodejs的代码库，在不同时间或者不同npm下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容。</p><p>因此npm最新的版本就开始提供自动生成package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。</p><p><a href="https://docs.npmjs.com/files/package-lock.json" target="_blank" rel="noopener">package-lock.json | 官方文档</a></p><h3 id="semver-语义化版本号变更"><a href="#semver-语义化版本号变更" class="headerlink" title="semver 语义化版本号变更"></a>semver 语义化版本号变更</h3><p><code>^</code> 是npm默认的版本符号, 当你使用npm install –save时, npm会自动在package中添加^加上版本号. 例如: npm install –save angular会在package.json中添加”angular”: “^1.3.15”.这个符号会告诉npm可以安装1.3.15或者一个大于它的版本, 但是要是主版本1下的版本.</p><p><code>~</code> 同样被用来做npm得版本控制, 例如<del>1.3.15, 代表了npm可以安装1.3.15或者更高的版本, 与^的区别在于, ~的版本只能开始于次版本号1.3. 它们的作用域不同. 你可以通过npm config set save-prefix=’</del>‘将~设置为默认符号.</p><p><code>&gt;</code>符号主要是用来指定可以安装beta版本.</p><p><a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">semver版本号 | 官方文档</a></p><p><code>devDependencies</code> 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>loader</title>
    <link href="/uncategorized/loader/"/>
    <url>/uncategorized/loader/</url>
    
    <content type="html"><![CDATA[<h1 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h1><p>当打包到非JS文件的时候，webpack会在<code>module</code>中配置里查找，然后根据<code>rules</code>中的<code>test</code>选择一个loader来处理。</p><h2 id="打包静态资源"><a href="#打包静态资源" class="headerlink" title="打包静态资源"></a>打包静态资源</h2><h3 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h3><h4 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h4><p>当发现是图片，使用 file-loader来打包<br>file-loader做的事：</p><ul><li>将图片移到dist目录下</li><li>给图片改个名字</li><li>将名字返回给引入模块的变量中</li></ul><pre><code class="js">module: {    rules: [{        test: /\.jpg$/,        use: {            loader: &#39;file-loader&#39;        }    }]},</code></pre><h4 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h4><p>让图片打包出来的名字与拓展名与原来一样<br><code>&#39;[name].[ext]&#39;</code> 这种语法叫 <code>placehoder</code> 即占位符</p><pre><code class="js">rules: [{    test: /\.jpg$/,    use: {        loader: &#39;file-loader&#39;,        // option 为配置参数        options: {            // 图片打包出来的名字和后缀原来的一样            name: &#39;[name]_[hash].[ext]&#39;        }    }}]</code></pre><h4 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h4><p>将文件打包为Base64编码，当图片特别小（1~2k）的时候适用。</p><p>但是大图片不使用，可以给它加上一个<code>limit</code>来限制</p><pre><code class="js">rules: [{    test: /\.(jpg|png|gif)$/,    use: {        loader: &#39;url-loader&#39;,        // option 为配置参数        options: {            limit: 2048        }    }}]</code></pre><h3 id="打包样式"><a href="#打包样式" class="headerlink" title="打包样式"></a>打包样式</h3><pre><code class="js">{    test: /\.css$/,    // 一种文件多个Loader就使用数组    use: [        &#39;style-loader&#39;, &#39;css-loader&#39;    ]}</code></pre><ul><li><code>css-loader</code> 能帮我们分析出几个CSS文件之间的关系</li><li><code>style-loader</code> 在得到 css-loader 生成的文件后，style-loader会将这段样式挂在到 header 标签中</li></ul><h4 id="使用sass"><a href="#使用sass" class="headerlink" title="使用sass"></a><a href="https://webpack.js.org/loaders/sass-loader/" target="_blank" rel="noopener">使用sass</a></h4><p>loader是<strong>有顺序</strong>的，顺序是：从数组的最后一个依次向前处理。</p><pre><code class="js">use: [    &quot;style-loader&quot;, // creates style nodes from JS strings    &quot;css-loader&quot;, // translates CSS into CommonJS    &quot;sass-loader&quot; // compiles Sass to CSS, using Node Sass by default]</code></pre><h4 id="厂商前缀-postcss-loader"><a href="#厂商前缀-postcss-loader" class="headerlink" title="厂商前缀 postcss-loader"></a><a href="https://webpack.js.org/loaders/postcss-loader/" target="_blank" rel="noopener">厂商前缀 postcss-loader</a></h4><pre><code class="js">use: [    &quot;style-loader&quot;, // creates style nodes from JS strings    &quot;css-loader&quot;, // translates CSS into CommonJS    &quot;postcss-loader&quot; // compiles Sass to CSS, using Node Sass by default]</code></pre><p>它可以进行配置，要创建一个<code>postcss.config.js</code>文件 </p><pre><code class="js">module.exports = {    plugins: [        require(&#39;autoprefixer&#39;)    ]}</code></pre><p><code>autoprefixer</code>这个插件可以帮我们添加厂商前缀</p><h4 id="importLoaders"><a href="#importLoaders" class="headerlink" title="importLoaders"></a>importLoaders</h4><p>在sass文件中又 使用<code>@import</code>的方式去引入了其他文件，可能就会导致在打包时直接走 css-loader，而不会去走下面的两个loader</p><p><code>importLoaders</code>就是让<code>@import</code>方式引入方式的文件也走下面的两个loader</p><pre><code class="js">use: [    &quot;style-loader&quot;,    {        loader: &quot;css-loader&quot;,        options:{             importLoaders: 2        }     },     &quot;sass-loader&quot;,    &quot;postcss-loader&quot;]</code></pre><h4 id="CSS-modules"><a href="#CSS-modules" class="headerlink" title="CSS modules"></a>CSS modules</h4><p>css-loader直接将其打包注入到header中，可能造成CSS的干扰。即一个文件中引入了一个CSS，其他地方都会受到影响</p><p>解决方法是配置<code>modules</code>：</p><pre><code class="js">{    loader: &quot;css-loader&quot;,    options:{         importLoaders: 2,        modules: true    } },</code></pre><p>引入样式时使用 <code>style.className</code> 方式：</p><pre><code class="js">import style form &#39;./style.sass&#39;// 添加样式const img = new Image();img.src = girl;img.classList.add(style.girl)</code></pre><h4 id="打包字体"><a href="#打包字体" class="headerlink" title="打包字体"></a>打包字体</h4><p>打包时如果有字体文件的话打包又会报错，因为不认识字体文件。而对字体文件的打包只需要<code>file-loader</code>就可以了</p><pre><code class="js">{    test: /\.(eot|ttf|svg)$/,    use: {        loader: &#39;file-loader&#39;    }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>plugins</title>
    <link href="/uncategorized/plugins/"/>
    <url>/uncategorized/plugins/</url>
    
    <content type="html"><![CDATA[<h1 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h1><p>使用<code>plugins</code>让打包变的便捷，可以在webpack打包的某时刻帮做一些事情，他很像一个生命周期函数</p><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>html-webpack-plugin 会在打包结束后，自动生成一个html文件,并把打包生成的js自动引入到HTML中。<br>可以给这个html制定一个模板</p><pre><code class="js">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)// 插件plugins: [    new HtmlWebpackPlugin({        template: &#39;src/index.html&#39;    })],</code></pre><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a><a href="https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="noopener">clean-webpack-plugin</a></h3><p>帮助打包时先清空dist目录</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>process</title>
    <link href="/uncategorized/process/"/>
    <url>/uncategorized/process/</url>
    
    <content type="html"><![CDATA[<h1 id="process"><a href="#process" class="headerlink" title="process"></a><a href="http://nodejs.cn/api/process.htm" target="_blank" rel="noopener">process</a></h1><h3 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h3><p>cwd()方法可以获得当前执行的路径。和linux下的cwd一样</p><h3 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h3><p><code>process.argv</code> 属性返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数。</p><ul><li>数组第一个元素为：node所安装的路径</li><li>数组第二个元素为：当前执行文件的路径</li><li>剩余元素为执行node命令时传入的参数</li></ul><h3 id="process-argv0"><a href="#process-argv0" class="headerlink" title="process.argv0"></a>process.argv0</h3><p>保存了process.argv数组的第一个值的<em>引用</em>，不常用</p><h3 id="process-execArgv"><a href="#process-execArgv" class="headerlink" title="process.execArgv"></a>process.execArgv</h3><p>process.execArgv 属性返回当Node.js进程被启动时，Node.js特定的命令行选项（位于node后，文件名之前）。 这些选项在process.argv属性返回的数组中不会出现。</p><h3 id="process-execPath"><a href="#process-execPath" class="headerlink" title="process.execPath"></a>process.execPath</h3><p>返回启动 Node.js 进程的可执行文件的绝对路径名。基本就是 process.argv 的第一个参数</p><h3 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h3><p>process.env 属性返回包含用户环境的对象。</p><h4 id="process-env-PATH"><a href="#process-env-PATH" class="headerlink" title="process.env.PATH"></a>process.env.PATH</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>path</title>
    <link href="/uncategorized/path/"/>
    <url>/uncategorized/path/</url>
    
    <content type="html"><![CDATA[<h1 id="path"><a href="#path" class="headerlink" title="path"></a>path</h1><p>path 模块提供用于处理文件路径和目录路径的实用工具。</p><h3 id="normalize、join、resolve"><a href="#normalize、join、resolve" class="headerlink" title="normalize、join、resolve"></a>normalize、join、resolve</h3><ul><li><p>path.normalize() 方法规范化给定的 path，解析 ‘..’ 和 ‘.’ 片段。</p><pre><code class="js">path.normalize(&#39;/foo/bar//baz/asdf/quux/..&#39;);// 返回: &#39;/foo/bar/baz/asdf&#39;</code></pre></li><li><p>path.join方法使用平台特定分隔符作为定界符将所有给定的path片段连接在一起，然后生成规范的路径</p></li></ul><pre><code class="js">path.join(&#39;/foo&#39;, &#39;bar&#39;, &#39;baz/asdf&#39;, &#39;..&#39;) // 返回: &#39;/foo/bar/baz/asdf&#39;</code></pre><ul><li>path.resolve([…paths])把一个相对路径解析成一个绝对路径。<pre><code class="js">[path.join([...paths])](path.resolve(&#39;wwwroot&#39;, &#39;static_files/png/&#39;, &#39;../gif/image.gif&#39;);// 如果当前工作目录是 /home/myself/node，// 则返回 &#39;/home/myself/node/wwwroot/static_files/gif/image.gif&#39;)</code></pre></li></ul><h3 id="basename、dirname、extname"><a href="#basename、dirname、extname" class="headerlink" title="basename、dirname、extname"></a>basename、dirname、extname</h3><ul><li>basename<ul><li>文件名.拓展名</li></ul></li><li>dirname<ul><li>所在的文件夹</li></ul></li><li>extname<ul><li>拓展名是什么<pre><code>┌─────────────────────┬────────────┐│          dir        │    base    │├──────┬              ├──────┬─────┤│ root │              │ name │ ext │&quot;  /    home/user/dir / file  .txt &quot;└──────┴──────────────┴──────┴─────┘</code></pre></li></ul></li></ul><h3 id="parse-与-format"><a href="#parse-与-format" class="headerlink" title="parse 与 format"></a>parse 与 format</h3><ul><li>parse是将字符串形式的文件路径给解析成一个包含 root, dir, base, name, ext属性的对象</li><li>format则是将这个对象代表的路径转成字符串形式，与parse相反</li></ul><p>如果有了一个路径指向修改其中的一个内容，那么就可以使用parse转成对象然后修改后使用format在转成一个新路径。</p><p>当为 pathObject 提供属性时，注意以下组合，其中一些属性优先于另一些属性：</p><ul><li>如果提供了 pathObject.dir，则忽略 pathObject.root。</li><li>如果 pathObject.base 存在，则忽略 pathObject.ext 和 pathObject.name。</li></ul><h3 id="sep、delimiter、win32、posix"><a href="#sep、delimiter、win32、posix" class="headerlink" title="sep、delimiter、win32、posix"></a>sep、delimiter、win32、posix</h3><ul><li>sep提供平台特定的路径片段分隔符：<ul><li>Windows 上是 \；POSIX 上是 /</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ServiceWorker</title>
    <link href="/uncategorized/ServiceWorker/"/>
    <url>/uncategorized/ServiceWorker/</url>
    
    <content type="html"><![CDATA[<h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p><pre><code class="js">// index.jsif (navigator.serviceWorker) {  navigator.serviceWorker    .register(&#39;sw.js&#39;)    .then(function(registration) {      console.log(&#39;service worker 注册成功&#39;)    })    .catch(function(err) {      console.log(&#39;servcie worker 注册失败&#39;)    })}// sw.js// 监听 `install` 事件，回调中缓存所需文件self.addEventListener(&#39;install&#39;, e =&gt; {  e.waitUntil(    caches.open(&#39;my-cache&#39;).then(function(cache) {      return cache.addAll([&#39;./index.html&#39;, &#39;./index.js&#39;])    })  )})// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener(&#39;fetch&#39;, e =&gt; {  e.respondWith(    caches.match(e.request).then(function(response) {      if (response) {        return response      }      console.log(&#39;fetch source&#39;)    })  )})</code></pre><p>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了<br><img src="../img/serviceWorker.png" srcset="/img/loading.gif" alt=""></p><p>在 Cache 中也可以发现我们所需的文件已被缓存<br><img src="../img/cache-worker.png" srcset="/img/loading.gif" alt=""></p><p>当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的<br><img src="../img/reload-worker.png" srcset="/img/loading.gif" alt=""></p><h3 id="好文链接"><a href="#好文链接" class="headerlink" title="好文链接"></a>好文链接</h3><ul><li><a href="https://www.zcfy.cc/article/service-worker-what-are-you-mariko-kosaka-1927.html" target="_blank" rel="noopener">https://www.zcfy.cc/article/service-worker-what-are-you-mariko-kosaka-1927.html</a></li><li><a href="https://juejin.im/post/5ba0fe356fb9a05d2c43a25c" target="_blank" rel="noopener">https://juejin.im/post/5ba0fe356fb9a05d2c43a25c</a></li><li><a href="https://juejin.im/post/5bf3f656e51d45338e084044" target="_blank" rel="noopener">https://juejin.im/post/5bf3f656e51d45338e084044</a></li><li><a href="https://juejin.im/post/5bf3f6b2e51d45360069e527" target="_blank" rel="noopener">https://juejin.im/post/5bf3f6b2e51d45360069e527</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6</title>
    <link href="/uncategorized/ES6/"/>
    <url>/uncategorized/ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h3 id="var、let-及-const-区别？"><a href="#var、let-及-const-区别？" class="headerlink" title="var、let 及 const 区别？"></a>var、let 及 const 区别？</h3><ul><li>全局申明的var变量会挂载在window上，而let和const不会</li><li>var声明变量存在变量提升，let和const不会</li><li>let、const 的作用范围是块级作用域，而var的作用范围是函数作用域</li><li>同一作用域下let和const不能声明同名变量，而var可以</li><li>同一作用域下在let和const声明前使用会存在暂时性死区</li><li>const<ul><li>一旦声明必须赋值,不能使用null占位</li><li>声明后不能再修改</li><li>如果声明的是复合类型数据，可以修改其属性</li></ul></li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p> Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。</p><pre><code class="js">let p = new Proxy(target, handler)</code></pre><p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。</p><pre><code class="js">let onWatch = (obj, setBind, getLogger) =&gt; {  let handler = {    set(target, property, value, receiver) {      setBind(value, property)      return Reflect.set(target, property, value)    },    get(target, property, receiver) {      getLogger(target, property)      return Reflect.get(target, property, receiver)    }  }  return new Proxy(obj, handler)}let obj = { a: 1 }let p = onWatch(  obj,  (v, property) =&gt; {    console.log(`监听到属性${property}改变为${v}`)  },  (target, property) =&gt; {    console.log(`&#39;${property}&#39; = ${target[property]}`)  })p.a = 2 // 控制台输出：监听到属性a改变p.a // &#39;a&#39; = 2</code></pre><p>自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p><p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后返回一个新数组，原数组不发生改变。</p><p>map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组</p><pre><code class="js">var arr = [1,2,3];var arr2 = arr.map(item =&gt; item + 1)    arr   //[ 1, 2, 3 ]arr2  // [ 2, 3, 4 ]</code></pre><pre><code class="js">[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)// -&gt; [ 1, NaN, NaN ]</code></pre><ul><li>第一个 parseInt(‘1’, 0) -&gt; 1</li><li>第二个 parseInt(‘2’, 1) -&gt; NaN</li><li>第三个 parseInt(‘3’, 2) -&gt; NaN</li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素</p><p>filter 的回调函数接受三个参数，分别是当前索引元素，索引，原数组</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce 可以将数组中的元素通过回调函数最终转换为一个值。<br>如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码</p><pre><code class="js">const arr = [1, 2, 3]let total = 0for (let i = 0; i &lt; arr.length; i++) {  total += arr[i]}console.log(total) //6 </code></pre><p>但是如果我们使用 reduce 的话就可以将遍历部分的代码优化为一行代码</p><pre><code class="js">const arr = [1, 2, 3]const sum = arr.reduce((acc, current) =&gt; acc + current, 0)console.log(sum)</code></pre><p>对于 reduce 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 reduce 的过程</p><ul><li>首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入</li><li>回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数</li><li>在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入</li><li>所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6。</li></ul><h3 id="Es6中箭头函数与普通函数的区别？"><a href="#Es6中箭头函数与普通函数的区别？" class="headerlink" title="Es6中箭头函数与普通函数的区别？"></a>Es6中箭头函数与普通函数的区别？</h3><ul><li>普通function的声明在变量提升中是最高的，箭头函数没有函数提升</li><li>箭头函数没有属于自己的<code>this</code>，<code>arguments</code></li><li>箭头函数不能作为构造函数，不能被new，没有property</li><li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数</li><li>不可以使用 new 命令，因为：<ul><li>没有自己的 this，无法调用 call，apply</li><li>没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 <code>__proto__</code></li></ul></li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了。</p><ul><li>等待中（pending）</li><li>完成了（resolved）</li><li>拒绝了（rejected）</li></ul><p>当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的。</p><pre><code class="js">new Promise((resolve, reject) =&gt; {  console.log(&#39;new Promise&#39;)  resolve(&#39;success&#39;)})console.log(&#39;finifsh&#39;)// 先打印new Promise， 再打印 finifsh</code></pre><p>Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装。</p><pre><code class="js">Promise.resolve(1)  .then(res =&gt; {    console.log(res) // =&gt; 1    return 2 // 包装成 Promise.resolve(2)  })  .then(res =&gt; {    console.log(res) // =&gt; 2  })</code></pre><p>当然了，Promise 也很好地解决了回调地狱的问题</p><pre><code class="js">ajax(url)  .then(res =&gt; {      console.log(res)      return ajax(url1)  }).then(res =&gt; {      console.log(res)      return ajax(url2)  }).then(res =&gt; console.log(res))</code></pre><p>其实它也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。</p><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>一个函数如果加上 async ，那么该函数就会返回一个 Promise</p><pre><code class="js">async function test() {  return &quot;1&quot;}console.log(test()) // -&gt; Promise {&lt;resolved&gt;: &quot;1&quot;}</code></pre><p>async 就是将函数返回值使用 Promise.resolve() 包裹了下，和 then 中处理返回值一样，并且 await 只能配套 async 使用。</p><pre><code class="js">async function test() {  let value = await sleep()}</code></pre><p>async 和 await 可以说是异步终极解决方案了，相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题。</p><p>当然也存在一些缺点，因为 <strong>await 将异步代码改造成了同步代码</strong>，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p><pre><code class="js">async function test() {  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式  // 如果有依赖性的话，其实就是解决回调地狱的例子了  await fetch(url)  await fetch(url1)  await fetch(url2)}</code></pre><p>看一个使用 await 的例子：</p><pre><code class="js">let a = 0let b = async () =&gt; {  a = a + await 10  console.log(&#39;2&#39;, a)}b()a++console.log(&#39;1&#39;, a)//先输出  ‘1’, 1//在输出  ‘2’, 10</code></pre><ul><li>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来</li><li>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码</li><li>同步代码 a++ 与打印 a 执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10</li></ul><p>上述解释中提到了 await 内部实现了 generator，其实 <strong>await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator</strong>。</p><h3 id="代码分析题"><a href="#代码分析题" class="headerlink" title="代码分析题"></a>代码分析题</h3><pre><code class="js">function wait() {  return new Promise(resolve =&gt;      setTimeout(resolve,  1000)  )}async function main() {  console.time();  const x = wait();  const y = wait();  const z = wait();  await x;  await y;  await z;  console.timeEnd();}main();</code></pre><p>答案： 输出耗时： 1秒多一点点。<br>原因： 3个wait函数在赋值的时候就已经开始执行了。</p><p>稍微改造一下就可以得到3 * 1000 ms以上的结果</p><pre><code class="js">function wait () {  return new Promise(    resolve =&gt; setTimeout(resolve,  1000)  )}async function main () {  console.time()  const x = await wait()  const y = await wait()  const z = await wait()  console.timeEnd()}main()</code></pre><h3 id="Generator-生成器"><a href="#Generator-生成器" class="headerlink" title="Generator 生成器"></a>Generator 生成器</h3><pre><code class="js">function *foo(x) {  let y = 2 * (yield (x + 1))  let z = yield (y / 3)  return (x + y + z)}let it = foo(5)console.log(it.next())   // =&gt; {value: 6, done: false}console.log(it.next(12)) // =&gt; {value: 8, done: false}console.log(it.next(13)) // =&gt; {value: 42, done: true}</code></pre><ul><li><p>首先 Generator 函数调用和普通函数不同，它会返回一个迭代器</p></li><li><p>当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6</p></li><li><p>当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8</p></li><li><p>当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42</p></li></ul><h3 id="生成器原理"><a href="#生成器原理" class="headerlink" title="生成器原理"></a>生成器原理</h3><p>当yeild产生一个值后，生成器的执行上下文就会从栈中弹出。但由于迭代器一直保持着队执行上下文的引用，上下文不会丢失，不会像普通函数一样执行完后上下文就被销毁</p><h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><p>ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别</p><ul><li>CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案</li><li>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>ES Module 会编译成 require/exports 来执行的</li></ul><pre><code class="js">// 引入模块 APIimport XXX from &#39;./a.js&#39;import { XXX } from &#39;./a.js&#39;// 导出模块 APIexport function a() {}export default function() {}</code></pre><h3 id="私有方法和私有属性（阿里一面）"><a href="#私有方法和私有属性（阿里一面）" class="headerlink" title="私有方法和私有属性（阿里一面）"></a>私有方法和私有属性（阿里一面）</h3><p><a href="https://es6.ruanyifeng.com/?search=%E7%A7%81%E6%9C%89&x=0&y=0#docs/class#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">阮老师 | ES6入门</a></p><h4 id="现有的解决方案"><a href="#现有的解决方案" class="headerlink" title="现有的解决方案"></a>现有的解决方案</h4><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别，即在函数名或属性名前加<code>_</code>，但这并不安全，只是一种团队规范。</p><p>另一种方法就是索性<strong>将私有方法移出类，放到模块里</strong>，因为模块内部的所有方法都是对外可见的。</p><pre><code class="js">class Widget {  foo (baz) {    bar.call(this, baz);  }  // ...}function bar(baz) {  return this.snaf = baz;}</code></pre><p>上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p><p>还有一种方法是利用<strong>Symbol值的唯一性</strong>，将私有方法的名字命名为一个Symbol值。</p><pre><code class="js">const bar = Symbol(&#39;bar&#39;);const snaf = Symbol(&#39;snaf&#39;);export default class myClass{  // 公有方法  foo(baz) {    this[bar](baz);  }  // 私有方法  [bar](baz) {    return this[snaf] = baz;  }  // ...};</code></pre><p>上面代码中，bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，Reflect.ownKeys()依然可以拿到它们。</p><pre><code class="js">const inst = new myClass();Reflect.ownKeys(myClass.prototype)// [ &#39;constructor&#39;, &#39;foo&#39;, Symbol(bar) ]</code></pre><h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">Proxy</a></h3><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><pre><code class="js">var obj = new Proxy({}, {  get: function (target, key, receiver) {    console.log(`getting ${key}!`);    return Reflect.get(target, key, receiver);  },  set: function (target, key, value, receiver) {    console.log(`setting ${key}!`);    return Reflect.set(target, key, value, receiver);  }});</code></pre><p>Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li>get(target, propKey, receiver)<ul><li>拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li></ul></li><li>set(target, propKey, value, receiver)<ul><li>拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li></ul></li><li>has(target, propKey)<ul><li>拦截propKey in proxy的操作，返回一个布尔值。</li></ul></li><li>deleteProperty(target, propKey)<ul><li>拦截delete proxy[propKey]的操作，返回一个布尔值。</li></ul></li><li>ownKeys(target)<ul><li>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li></ul></li><li>getOwnPropertyDescriptor(target, propKey)<ul><li>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li></ul></li><li>defineProperty(target, propKey, propDesc)<ul><li>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li></ul></li><li>preventExtensions(target)<ul><li>拦截Object.preventExtensions(proxy)，返回一个布尔值。</li></ul></li><li>getPrototypeOf(target)<ul><li>拦截Object.getPrototypeOf(proxy)，返回一个对象。</li></ul></li><li>isExtensible(target)<ul><li>拦截Object.isExtensible(proxy)，返回一个布尔值。</li></ul></li><li>setPrototypeOf(target, proto)<ul><li>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li></ul></li><li>apply(target, object, args)<ul><li>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li></ul></li><li>construct(target, args)<ul><li>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DOM</title>
    <link href="/uncategorized/DOM/"/>
    <url>/uncategorized/DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><ul><li>DOM 事件的级别</li><li>DOM 事件模型</li><li>DOM 事件流</li><li>DOM 事件捕获的具体流程</li><li>Event 对象的常见应用</li><li>自定义事件</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener">DOM概述 | MDN</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element" target="_blank" rel="noopener">DOM | MDN</a></p><p><a href="https://blog.csdn.net/Night_Emperor/article/details/78471051" target="_blank" rel="noopener">DOM操作</a></p><h3 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h3><ul><li>DOM0<ul><li>onXXX类型的定义事件</li><li>element.onclick = function(e) { … }</li></ul></li><li>DOM2<ul><li>addEventListener方式</li><li>element.addEventListener(‘click’, function (e) { … })</li><li>btn.removeEventListener(‘click’, func, false)</li><li>btn.attachEvent(“onclick”, func);</li><li>btn.detachEvent(“onclick”, func);</li></ul></li><li>DOM3<ul><li>增加了很多事件类型</li><li>element.addEventListener(‘keyup’, function (e) { … })</li><li>eventUtil 是自定义对象，textInput 是 DOM3 级事件</li></ul></li></ul><h3 id="DOM-事件模型"><a href="#DOM-事件模型" class="headerlink" title="DOM 事件模型"></a>DOM 事件模型</h3><p>捕获从上到下， 冒泡从下到上。<br>先捕获，再到目标，再冒泡<br><img src="../img/dom%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B.jpg" srcset="/img/loading.gif" alt="事件模型"></p><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从window对象开始，也在window对象结束。</p><p>DOM标准规定事件流包括三个阶段：</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h3 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h3><p>从window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素</p><h3 id="Event对象常见应用"><a href="#Event对象常见应用" class="headerlink" title="Event对象常见应用"></a>Event对象常见应用</h3><ul><li>event.target<ul><li>触发事件的元素</li></ul></li><li>event.currentTarget<ul><li>绑定事件的元素</li></ul></li><li>event.preventDefault()<ul><li>阻止默认行为</li><li>event.cancelBubble()和event.preventBubble 都已经废弃</li></ul></li><li>event.stopPropagation()<ul><li>阻止在捕获阶段或冒泡阶段继续传播，而不是阻止冒泡</li></ul></li><li>event.stopImmediatePropagation()<ul><li>阻止事件冒泡并且阻止相同事件的其他侦听器被调用。</li></ul></li></ul><h3 id="事件的代理-委托"><a href="#事件的代理-委托" class="headerlink" title="事件的代理/委托"></a>事件的代理/委托</h3><p>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件</p><p>优点：</p><ul><li>可以减少事件注册，节省大量内存占用</li><li>可以将事件应用于动态添加的子元素上</li></ul><p>但使用不当会造成事件在不应该触发时触发</p><pre><code class="js">ulEl.addEventListener(&#39;click&#39;, function(e){  var target = event.target || event.srcElement;  if(target &amp;&amp; target.nodeName.toUpperCase() === &quot;LI&quot;){    console.log(target.innerHTML);  }}, false);</code></pre><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><ul><li>Event</li><li>CustomEvent</li></ul><p>CustomEvent不仅可以用来做自定义事件，还可以在后面跟一个object做参数</p><pre><code class="js">var evt = new Event(&#39;myEvent&#39;);someDom.addEventListener(&#39;myEvent&#39;, function() {  //处理这个自定义事件});someDom.dispatchEvent(evt);</code></pre><h3 id="IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>IE 只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获。</p><p>阻止冒泡：</p><ul><li>取消默认操作<ul><li>w3c 的方法是 e.preventDefault()</li><li>IE 则是使用 e.returnValue = false;</li></ul></li><li>return false <ul><li>javascript 的 return false 只会阻止默认行为</li><li>是用 jQuery 的话则既阻止默认行为又防止对象冒泡。</li></ul></li><li>阻止冒泡 <ul><li>w3c 的方法是 e.stopPropagation()</li><li>IE 则是使用 e.cancelBubble = true</li></ul></li></ul><pre><code class="js">[js] view plaincopyfunction stopHandler(event)  window.event   ? window.event.cancelBubble = true   : event.stopPropagation();}</code></pre><h3 id="DOM-元素的-dom-getAttribute-propName-和-dom-propName-有什么区别和联系"><a href="#DOM-元素的-dom-getAttribute-propName-和-dom-propName-有什么区别和联系" class="headerlink" title="DOM 元素的 dom.getAttribute(propName)和 dom.propName 有什么区别和联系"></a>DOM 元素的 dom.getAttribute(propName)和 dom.propName 有什么区别和联系</h3><ul><li>dom.getAttribute()，是标准 DOM 操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性</li><li>dom.propName 通常是在 HTML 文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如 a 标签生成 HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用 getAttribute 进行访问</li><li>dom.getAttribute()返回值是源文件中设置的值，类型是字符串或者 null（有的实现返回””）</li><li>dom.propName 返回值可能是字符串、布尔值、对象、undefined 等</li><li>大部分 attribute 与 property 是一一对应关系，修改其中一个会影响另一个，如 id，title 等属性</li><li>一些布尔属性<code>&lt;input hidden/&gt;</code>的检测设置需要 hasAttribute 和 removeAttribute 来完成，或者设置对应 property</li><li>像<code>&lt;a href=&quot;../index.html&quot;&gt;link&lt;/a&gt;</code>中 href 属性，转换成 property 的时候需要通过转换得到完整 URL</li><li>一些 attribute 和 property 不是一一对应如：form 控件中<code>&lt;input value=&quot;hello&quot;/&gt;</code>对应的是 defaultValue，修改或设置 value property 修改的是控件当前值，setAttribute 修改 value 属性不会改变 value property</li></ul><h3 id="JS获取dom的CSS样式"><a href="#JS获取dom的CSS样式" class="headerlink" title="JS获取dom的CSS样式"></a>JS获取dom的CSS样式</h3><pre><code class="js">function getStyle(obj, attr){  if(obj.currentStyle){    return obj.currentStyle[attr];  } else {    return window.getComputedStyle(obj, false)[attr];  }}</code></pre><h3 id="JS实现鼠标拖拽"><a href="#JS实现鼠标拖拽" class="headerlink" title="JS实现鼠标拖拽"></a><a href="https://blog.csdn.net/qq_37746973/article/details/80748879" target="_blank" rel="noopener">JS实现鼠标拖拽</a></h3><h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点?"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点?</h3><p>创建新节点</p><ul><li>createDocumentFragment() //创建一个 DOM 片段</li><li>createElement() //创建一个具体的元素</li><li>createTextNode() //创建一个文本节点</li></ul><p>添加、移除、替换、插入</p><ul><li>appendChild()</li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore() //在已有的子节点前插入一个新的子节点</li></ul><p>查找</p><ul><li>getElementsByTagName() //通过标签名称</li><li>getElementsByName() // 通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组，其中包括 id 等于 name 值的)  </li><li>getElementById() //通过元素 Id，唯一性</li></ul><h3 id="documen-write-和-innerHTML-的区别"><a href="#documen-write-和-innerHTML-的区别" class="headerlink" title="documen.write 和 innerHTML 的区别"></a>documen.write 和 innerHTML 的区别</h3><ul><li>document.write 只能重绘整个页面</li><li>innerHTML 可以重绘页面的一部分</li></ul><h3 id="Window-对象-与-document对象"><a href="#Window-对象-与-document对象" class="headerlink" title="Window 对象 与 document对象"></a>Window 对象 与 document对象</h3><p>window</p><ul><li>Window 对象表示当前浏览器的窗口，是 JavaScript 的顶级对象。</li><li>我们创建的所有对象、函数、变量都是 Window 对象的成员。</li><li>Window 对象的方法和属性是在全局范围内有效的。</li></ul><p>document</p><ul><li>Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）</li><li>Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问</li><li>Document 对象是 Window 对象的一部分，即 window.document</li></ul><h3 id="区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”"><a href="#区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”" class="headerlink" title="区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”"></a>区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”</h3><ul><li>客户区坐标<ul><li>鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)</li></ul></li><li>页面坐标<ul><li>鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标</li></ul></li><li>屏幕坐标<ul><li>设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)</li></ul></li></ul><h3 id="focus-blur与focusin-focusout的区别与联系"><a href="#focus-blur与focusin-focusout的区别与联系" class="headerlink" title="focus/blur与focusin/focusout的区别与联系"></a>focus/blur与focusin/focusout的区别与联系</h3><ol><li>focus/blur不冒泡，focusin/focusout冒泡</li><li>focus/blur兼容性好，focusin/focusout在除FireFox外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在FireFox下使用事件捕获elem.addEventListener(‘focus’, handler, true)</li></ol><h3 id="mouseover-mouseout与mouseenter-mouseleave的区别与联系"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别与联系" class="headerlink" title="mouseover/mouseout与mouseenter/mouseleave的区别与联系"></a>mouseover/mouseout与mouseenter/mouseleave的区别与联系</h3><ol><li>mouseover/mouseout是标准事件，<strong>所有浏览器都支持</strong>；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持</li><li>mouseover/mouseout是<strong>冒泡</strong>事件；mouseenter/mouseleave<strong>不冒泡</strong>。需要为<strong>多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能</strong></li><li>标准事件模型中event.target表示发生移入/出的元素,<strong>vent.relatedTarget</strong>对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，<strong>event.toElement</strong>表示移出的目标元素，<strong>event.fromElement</strong>表示移入时的来源元素</li></ol><h3 id="IE-的事件处理和-W3C-的事件处理有哪些区别？"><a href="#IE-的事件处理和-W3C-的事件处理有哪些区别？" class="headerlink" title="IE 的事件处理和 W3C 的事件处理有哪些区别？"></a>IE 的事件处理和 W3C 的事件处理有哪些区别？</h3><p>绑定事件</p><ul><li>W3C: targetEl.addEventListener(‘click’, handler, false);</li><li>IE: targetEl.attachEvent(‘onclick’, handler);</li></ul><p>删除事件</p><ul><li>W3C: targetEl.removeEventListener(‘click’, handler, false);</li><li>IE: targetEl.detachEvent(event, handler);</li></ul><p>事件对象</p><ul><li>W3C: var e = arguments.callee.caller.arguments[0]</li><li>IE: window.event</li></ul><p>事件目标</p><ul><li>W3C: e.target</li><li>IE: window.event.srcElement</li></ul><p>阻止事件默认行为</p><ul><li>W3C: e.preventDefault()</li><li>IE: window.event.returnValue = false’</li></ul><p>阻止事件传播</p><ul><li>W3C: e.stopPropagation()</li><li>IE: window.event.cancelBubble = true</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BOM</title>
    <link href="/uncategorized/BOM/"/>
    <url>/uncategorized/BOM/</url>
    
    <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM 是 browser object model 的缩写， 简称浏览器对象模型。 主要处理浏览器窗口和框架，<br>描述了与浏览器进行交互的方法和接口， 可以对浏览器窗口进行访问和操作， 譬如可以弹出<br>新的窗口， 回退历史记录， 获取 url……</p><h3 id="BOM-与-DOM-的关系"><a href="#BOM-与-DOM-的关系" class="headerlink" title="BOM 与 DOM 的关系"></a>BOM 与 DOM 的关系</h3><ol><li>javacsript 是通过访问 BOM 对象来访问、 控制、 修改浏览器</li><li>BOM 的 window 包含了 document， 因此通过 window 对象的 document 属性就可以访问、<br>检索、 修改文档内容与结构。</li><li>document 对象又是 DOM 模型的根节点。</li></ol><p>因此， BOM 包含了 DOM， 浏览器提供出来给予访问的是 BOM 对象， 从 BOM 对象再访<br>问到 DOM 对象， 从而 js 可以操作浏览器以及浏览器读取到的文档</p><h3 id="BOM-对象包含哪些内容？"><a href="#BOM-对象包含哪些内容？" class="headerlink" title="BOM 对象包含哪些内容？"></a>BOM 对象包含哪些内容？</h3><ul><li>Window JavaScript 层级中的顶层对象， 表示浏览器窗口。</li><li>Navigator 包含客户端浏览器的信息。</li><li>History 包含了浏览器窗口访问过的 URL。</li><li>Location 包含了当前 URL 的信息。</li><li>Screen 包含客户端显示屏的信息。</li></ul><h3 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h3><p>History 对象包含用户（在浏览器窗口中） 访问过的 URL</p><table><thead><tr><th>方法/属性</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td>返回浏览器历史列表中的 URL 数量。</td></tr><tr><td>back()</td><td>加载 history 列表中的前一个 URL。</td></tr><tr><td>forward()</td><td>加载 history 列表中的下一个 URL。</td></tr><tr><td>go()</td><td>加载 history 列表中的某个具体页面</td></tr></tbody></table><h3 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h3><p>Location 对象包含有关当前 URL 的信息。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>hash</td><td>设置或返回从井号 (#) 开始的 URL（锚） 。</td></tr><tr><td>host</td><td>设置或返回主机名和当前 URL 的端口号。</td></tr><tr><td>hostname</td><td>设置或返回当前 URL 的主机名。</td></tr><tr><td>href</td><td>设置或返回完整的 URL。</td></tr><tr><td>pathname</td><td>设置或返回当前 URL 的路径部分。</td></tr><tr><td>port</td><td>设置或返回当前 URL 的端口号。</td></tr><tr><td>protocol</td><td>设置或返回当前 URL 的协议。</td></tr><tr><td>search</td><td>置或返回从问号 (?) 开始的 URL（查询部分） 。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>assign()</td><td>加载新的文档。</td></tr><tr><td>reload(‘force’)</td><td>重新加载当前文档。参数可选，不填或填 false 则取浏览器缓存的文档</td></tr><tr><td>replace()</td><td>用新的文档替换当前文档。</td></tr></tbody></table><h3 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h3><p>Window 对象表示一个浏览器窗口或一个框架。 在客户端 JavaScript 中， Window 对象<br>是全局对象，所有的表达式都在当前的环境中计算。 例如，可以只写 document， 而<br>不必写 window.document。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>closed</td><td>返回窗口是否已被关闭。</td></tr><tr><td>defaultStatus</td><td>设置或返回窗口状态栏中的默认文本。 （仅 Opera 支持）</td></tr><tr><td>document</td><td>对 Document 对象的只读引用。 请参阅 Document 对象。</td></tr><tr><td>history</td><td>对 History 对象的只读引用。 请参数 History 对象。</td></tr><tr><td>innerheight</td><td>返回窗口的文档显示区的高度。</td></tr><tr><td>innerwidth</td><td>返回窗口的文档显示区的宽度。</td></tr><tr><td>length</td><td>设置或返回窗口中的框架数量。</td></tr><tr><td>location</td><td>用于窗口或框架的 Location 对象。 请参阅 Location 对象。</td></tr><tr><td>name</td><td>设置或返回窗口的名称。</td></tr><tr><td>Navigator</td><td>对 Navigator 对象的只读引用。 请参数 Navigator 对象。</td></tr><tr><td>opener</td><td>返回对创建此窗口的窗口的引用。</td></tr><tr><td>outerheight</td><td>返回窗口的外部高度。</td></tr><tr><td>outerwidth</td><td>返回窗口的外部宽度。</td></tr><tr><td>pageXOffset</td><td>设置或返回当前页面相对于窗口显示区左上角的 X 位置。</td></tr><tr><td>pageYOffset</td><td>设置或返回当前页面相对于窗口显示区左上角的 Y 位置。</td></tr><tr><td>parent</td><td>返回父窗口。</td></tr><tr><td>Screen</td><td>对 Screen 对象的只读引用。 请参数 Screen 对象。</td></tr><tr><td>self</td><td>返回对当前窗口的引用。 等价于 Window 属性。</td></tr><tr><td>status</td><td>设置窗口状态栏的文本。 (默认只支持 Opera)</td></tr><tr><td>top</td><td>返回最顶层的先辈窗口。</td></tr><tr><td>window</td><td>window 属性等价于 self 属性， 它包含了对窗口自身的引用。</td></tr><tr><td>screenLeft <br/> screenTop <br/> screenX <br/> screenY</td><td>只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。 IE、 Safari、 Chrome 和 Opera 支持 screenLeft 和 screenTop， 而 Chrome、 Firefox 和 Safari 支持 screenX 和 screenY。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>alert()</td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td>blur()</td><td>把键盘焦点从顶层窗口移开。</td></tr><tr><td>confirm()</td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr><tr><td>createPopup()</td><td>创建一个弹出窗口。 只有 ie 支持（不包括 ie11）</td></tr><tr><td>focus()</td><td>把键盘焦点给予一个窗口。</td></tr><tr><td>moveBy()</td><td>可相对窗口的当前坐标把它移动指定的像素。</td></tr><tr><td>moveTo()</td><td>把窗口的左上角移动到一个指定的坐标。</td></tr><tr><td>open()</td><td>打开一个新的浏览器窗口或查找一个已命名的窗口。 window.open(URL,name,features,replace)</td></tr><tr><td>print()</td><td>打印当前窗口的内容。</td></tr><tr><td>prompt()</td><td>显示可提示用户输入的对话框。</td></tr><tr><td>resizeBy()</td><td>按照指定的像素调整窗口的大小。</td></tr><tr><td>resizeTo()</td><td>把窗口的大小调整到指定的宽度和高度。</td></tr><tr><td>scrollBy()</td><td>按照指定的像素值来滚动内容。</td></tr><tr><td>scrollTo()</td><td>把内容滚动到指定的坐标。</td></tr><tr><td>setInterval()</td><td>按照指定的周期（以毫秒计） 来调用函数或计算表达式。</td></tr><tr><td>setTimeout()</td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr><tr><td>clearInterval()</td><td>取消由 setInterval() 设置的 timeout。</td></tr><tr><td>clearTimeout()</td><td>取消由 setTimeout() 方法设置的 timeout。close() 关闭浏览器窗口</td></tr></tbody></table><h3 id="Navigator-对象"><a href="#Navigator-对象" class="headerlink" title="Navigator 对象"></a>Navigator 对象</h3><p>Navigator 对象包含的属性描述了正在使用的浏览器。 可以使用这些属性进行平台专用的配置。 虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器， 但其他实现了 JavaScript 的浏览器也支持这个对象。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>appCodeName</td><td>返回浏览器的代码名。 以 Netscape 代码为基础的浏览器中， 它的值是 “Mozilla”。Microsoft 也是</td></tr><tr><td>appMinorVersion</td><td>返回浏览器的次级版本。 （IE4、 Opera 支持）</td></tr><tr><td>appName</td><td>返回浏览器的名称。</td></tr><tr><td>appVersion</td><td>返回浏览器的平台和版本信息。</td></tr><tr><td>browserLanguage</td><td>返回当前浏览器的语言。 （IE 和 Opera 支持）cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值。</td></tr><tr><td>cpuClass</td><td>返回浏览器系统的 CPU 等级。 （IE 支持）</td></tr><tr><td>onLine</td><td>返回指明系统是否处于脱机模式的布尔值。</td></tr><tr><td>platform</td><td>返回运行浏览器的操作系统平台。</td></tr><tr><td>systemLanguage</td><td>返回当前操作系统的默认语言。 （IE 支持）</td></tr><tr><td>userAgent</td><td>返回由客户机发送服务器的 user-agent 头部的值。</td></tr><tr><td>userLanguage</td><td>返回操作系统设定的自然语言。 （IE 和 Opera 支持）</td></tr><tr><td>plugins</td><td>返回包含客户端安装的所有插件的数组</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>javaEnabled()</td><td>规定浏览器是否支持并启用了 Java。</td></tr><tr><td>taintEnabled()</td><td>规定浏览器是否启用数据污点 (data tainting)。</td></tr></tbody></table><h3 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h3><p>Screen 对象包含有关客户端显示屏幕的信息。 每个 Window 对象的 screen 属性都引用一个 Screen 对象。 Screen 对象中存放着有关显示浏览器屏幕的信息。 JavaScript 程序将利用这些信息来优化它们的输出， 以达到用户的显示要求。 例如，一个程序可以根据显示器的尺寸选择使用大图像还是使用小图像，它还可以根据显示器的颜色深度选择使用 16 位色还是使用 8 位色的图形。 另外，JavaScript 程序还能根有关屏幕尺寸的信息将新的浏览器窗口定位在屏幕中间。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>availHeight</td><td>返回显示屏幕的高度 (除 Windows 任务栏之外)。</td></tr><tr><td>availWidth</td><td>返回显示屏幕的宽度 (除 Windows 任务栏之外)。</td></tr><tr><td>bufferDepth</td><td>设置或返回调色板的比特深度。 （仅 IE 支持）colorDepth 返回目标设备或缓冲器上的调色板的比特深度。</td></tr><tr><td>deviceXDPI</td><td>返回显示屏幕的每英寸水平点数。 （仅 IE 支持）</td></tr><tr><td>deviceYDPI</td><td>返回显示屏幕的每英寸垂直点数。 （仅 IE 支持）</td></tr><tr><td>fontSmoothingEnabled</td><td>返回用户是否在显示控制面板中启用了字体平滑。 （仅 IE 支持）</td></tr><tr><td>height</td><td>返回显示屏幕的高度。</td></tr><tr><td>logicalXDPI</td><td>返回显示屏幕每英寸的水平方向的常规点数。 （仅 IE 支持）</td></tr><tr><td>logicalYDPI</td><td>返回显示屏幕每英寸的垂直方向的常规点数。 （仅 IE 支持）</td></tr><tr><td>pixelDepth</td><td>返回显示屏幕的颜色分辨率（比特每像素） 。</td></tr><tr><td>updateInterval</td><td>设置或返回屏幕的刷新率。 （仅 IE11 以下支持）</td></tr><tr><td>width</td><td>返回显示器屏幕的宽度。</td></tr></tbody></table><h3 id="检测浏览器版本版本有哪些方式？"><a href="#检测浏览器版本版本有哪些方式？" class="headerlink" title="检测浏览器版本版本有哪些方式？"></a>检测浏览器版本版本有哪些方式？</h3><ul><li>根据 navigator.userAgent // UA.toLowerCase().indexOf(‘chrome’)</li><li>根据 window 对象的成员 // ‘ActiveXObject’ in window</li></ul><h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别</h3><ul><li>offsetWidth/offsetHeight 返回值包含 content + padding + border，效果与 e.getBoundingClientRect()相同</li><li>clientWidth/clientHeight 返回值只包含 content + padding，如果有滚动条，也不包含滚动条</li><li>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>this</title>
    <link href="/uncategorized/this/"/>
    <url>/uncategorized/this/</url>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h3 id="this的指向有哪几种情况？"><a href="#this的指向有哪几种情况？" class="headerlink" title="this的指向有哪几种情况？"></a>this的指向有哪几种情况？</h3><p>this代表函数调用相关联的对象，通常页称之为执行上下文。</p><ol><li>作为函数直接调用，非严格模式下，this指向window，严格模式下，this指向undefined；</li><li>作为某对象的方法调用，this通常指向调用的对象。</li><li>使用apply、call、bind 可以绑定this的指向。</li><li>在构造函数中，this指向新创建的对象</li><li>箭头函数没有单独的this值，this在箭头函数创建时确定，它与声明所在的上下文相同。</li></ol><h3 id="如果对一个函数进行多次-bind，那么上下文会是什么呢？"><a href="#如果对一个函数进行多次-bind，那么上下文会是什么呢？" class="headerlink" title="如果对一个函数进行多次 bind，那么上下文会是什么呢？"></a>如果对一个函数进行多次 bind，那么上下文会是什么呢？</h3><pre><code class="js">let a = {}let fn = function () { console.log(this) }fn.bind().bind(a)() // =&gt; ?</code></pre><p>不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。</p><pre><code class="js">// fn.bind().bind(a) 等于let fn2 = function fn1() {  return function() {    return fn.apply()  }.apply(a)}fn2()</code></pre><h3 id="多个this规则出现时，this最终指向哪里？"><a href="#多个this规则出现时，this最终指向哪里？" class="headerlink" title="多个this规则出现时，this最终指向哪里？"></a>多个this规则出现时，this最终指向哪里？</h3><p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。<br><img src="../img/this.png" srcset="/img/loading.gif" alt="this"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
