<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="学习总结知识">
  <meta name="author" content="张振淇">
  <meta name="keywords" content="">
  <title>JS基础/ES6 - 我的学习博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>我的学习博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期六, 四月 4日 2020, 6:32 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    3.5k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                    
                    
                    43
                     分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h3 id="var、let-及-const-区别？"><a href="#var、let-及-const-区别？" class="headerlink" title="var、let 及 const 区别？"></a>var、let 及 const 区别？</h3><ul>
<li>全局申明的var变量会挂载在window上，而let和const不会</li>
<li>var声明变量存在变量提升，let和const不会</li>
<li>let、const 的作用范围是块级作用域，而var的作用范围是函数作用域</li>
<li>同一作用域下let和const不能声明同名变量，而var可以</li>
<li>同一作用域下在let和const声明前使用会存在暂时性死区</li>
<li>const<ul>
<li>一旦声明必须赋值,不能使用null占位</li>
<li>声明后不能再修改</li>
<li>如果声明的是复合类型数据，可以修改其属性</li>
</ul>
</li>
</ul>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p> Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。</p>
<pre><code class="js">let p = new Proxy(target, handler)</code></pre>
<p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。</p>
<pre><code class="js">let onWatch = (obj, setBind, getLogger) =&gt; {
  let handler = {
    set(target, property, value, receiver) {
      setBind(value, property)
      return Reflect.set(target, property, value)
    },
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver)
    }
  }
  return new Proxy(obj, handler)
}

let obj = { a: 1 }
let p = onWatch(
  obj,
  (v, property) =&gt; {
    console.log(`监听到属性${property}改变为${v}`)
  },
  (target, property) =&gt; {
    console.log(`&#39;${property}&#39; = ${target[property]}`)
  }
)
p.a = 2 // 控制台输出：监听到属性a改变
p.a // &#39;a&#39; = 2</code></pre>
<p>自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p>
<p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后返回一个新数组，原数组不发生改变。</p>
<p>map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组</p>
<pre><code class="js">var arr = [1,2,3];
var arr2 = arr.map(item =&gt; item + 1)    
arr   //[ 1, 2, 3 ]
arr2  // [ 2, 3, 4 ]</code></pre>
<pre><code class="js">[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)
// -&gt; [ 1, NaN, NaN ]</code></pre>
<ul>
<li>第一个 parseInt(‘1’, 0) -&gt; 1</li>
<li>第二个 parseInt(‘2’, 1) -&gt; NaN</li>
<li>第三个 parseInt(‘3’, 2) -&gt; NaN</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素</p>
<p>filter 的回调函数接受三个参数，分别是当前索引元素，索引，原数组</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce 可以将数组中的元素通过回调函数最终转换为一个值。<br>如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码</p>
<pre><code class="js">const arr = [1, 2, 3]
let total = 0
for (let i = 0; i &lt; arr.length; i++) {
  total += arr[i]
}
console.log(total) //6 </code></pre>
<p>但是如果我们使用 reduce 的话就可以将遍历部分的代码优化为一行代码</p>
<pre><code class="js">const arr = [1, 2, 3]
const sum = arr.reduce((acc, current) =&gt; acc + current, 0)
console.log(sum)</code></pre>
<p>对于 reduce 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 reduce 的过程</p>
<ul>
<li>首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入</li>
<li>回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数</li>
<li>在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入</li>
<li>所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6。</li>
</ul>
<h3 id="Es6中箭头函数与普通函数的区别？"><a href="#Es6中箭头函数与普通函数的区别？" class="headerlink" title="Es6中箭头函数与普通函数的区别？"></a>Es6中箭头函数与普通函数的区别？</h3><ul>
<li>普通function的声明在变量提升中是最高的，箭头函数没有函数提升</li>
<li>箭头函数没有属于自己的<code>this</code>，<code>arguments</code></li>
<li>箭头函数不能作为构造函数，不能被new，没有property</li>
<li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数</li>
<li>不可以使用 new 命令，因为：<ul>
<li>没有自己的 this，无法调用 call，apply</li>
<li>没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 <code>__proto__</code></li>
</ul>
</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了。</p>
<ul>
<li>等待中（pending）</li>
<li>完成了（resolved）</li>
<li>拒绝了（rejected）</li>
</ul>
<p>当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的。</p>
<pre><code class="js">new Promise((resolve, reject) =&gt; {
  console.log(&#39;new Promise&#39;)
  resolve(&#39;success&#39;)
})
console.log(&#39;finifsh&#39;)

// 先打印new Promise， 再打印 finifsh</code></pre>
<p>Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装。</p>
<pre><code class="js">Promise.resolve(1)
  .then(res =&gt; {
    console.log(res) // =&gt; 1
    return 2 // 包装成 Promise.resolve(2)
  })
  .then(res =&gt; {
    console.log(res) // =&gt; 2
  })</code></pre>
<p>当然了，Promise 也很好地解决了回调地狱的问题</p>
<pre><code class="js">ajax(url)
  .then(res =&gt; {
      console.log(res)
      return ajax(url1)
  }).then(res =&gt; {
      console.log(res)
      return ajax(url2)
  }).then(res =&gt; console.log(res))</code></pre>
<p>其实它也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。</p>
<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>一个函数如果加上 async ，那么该函数就会返回一个 Promise</p>
<pre><code class="js">async function test() {
  return &quot;1&quot;
}
console.log(test()) 
// -&gt; Promise {&lt;resolved&gt;: &quot;1&quot;}</code></pre>
<p>async 就是将函数返回值使用 Promise.resolve() 包裹了下，和 then 中处理返回值一样，并且 await 只能配套 async 使用。</p>
<pre><code class="js">async function test() {
  let value = await sleep()
}</code></pre>
<p>async 和 await 可以说是异步终极解决方案了，相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题。</p>
<p>当然也存在一些缺点，因为 <strong>await 将异步代码改造成了同步代码</strong>，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p>
<pre><code class="js">async function test() {
  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
  // 如果有依赖性的话，其实就是解决回调地狱的例子了
  await fetch(url)
  await fetch(url1)
  await fetch(url2)
}</code></pre>
<p>看一个使用 await 的例子：</p>
<pre><code class="js">let a = 0
let b = async () =&gt; {
  a = a + await 10
  console.log(&#39;2&#39;, a)
}
b()
a++
console.log(&#39;1&#39;, a)

//先输出  ‘1’, 1
//在输出  ‘2’, 10</code></pre>
<ul>
<li>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来</li>
<li>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码</li>
<li>同步代码 a++ 与打印 a 执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10</li>
</ul>
<p>上述解释中提到了 await 内部实现了 generator，其实 <strong>await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator</strong>。</p>
<h3 id="代码分析题"><a href="#代码分析题" class="headerlink" title="代码分析题"></a>代码分析题</h3><pre><code class="js">function wait() {
  return new Promise(resolve =&gt;
      setTimeout(resolve,  1000)
  )
}

async function main() {
  console.time();
  const x = wait();
  const y = wait();
  const z = wait();
  await x;
  await y;
  await z;
  console.timeEnd();
}
main();</code></pre>
<p>答案： 输出耗时： 1秒多一点点。<br>原因： 3个wait函数在赋值的时候就已经开始执行了。</p>
<p>稍微改造一下就可以得到3 * 1000 ms以上的结果</p>
<pre><code class="js">function wait () {
  return new Promise(
    resolve =&gt; setTimeout(resolve,  1000)
  )
}

async function main () {
  console.time()
  const x = await wait()
  const y = await wait()
  const z = await wait()
  console.timeEnd()
}

main()</code></pre>
<h3 id="Generator-生成器"><a href="#Generator-生成器" class="headerlink" title="Generator 生成器"></a>Generator 生成器</h3><pre><code class="js">function *foo(x) {
  let y = 2 * (yield (x + 1))
  let z = yield (y / 3)
  return (x + y + z)
}
let it = foo(5)
console.log(it.next())   // =&gt; {value: 6, done: false}
console.log(it.next(12)) // =&gt; {value: 8, done: false}
console.log(it.next(13)) // =&gt; {value: 42, done: true}</code></pre>
<ul>
<li><p>首先 Generator 函数调用和普通函数不同，它会返回一个迭代器</p>
</li>
<li><p>当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6</p>
</li>
<li><p>当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8</p>
</li>
<li><p>当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42</p>
</li>
</ul>
<h3 id="生成器原理"><a href="#生成器原理" class="headerlink" title="生成器原理"></a>生成器原理</h3><p>当yeild产生一个值后，生成器的执行上下文就会从栈中弹出。但由于迭代器一直保持着队执行上下文的引用，上下文不会丢失，不会像普通函数一样执行完后上下文就被销毁</p>
<h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><p>ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别</p>
<ul>
<li>CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案</li>
<li>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
<li>CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>
<li>ES Module 会编译成 require/exports 来执行的</li>
</ul>
<pre><code class="js">// 引入模块 API
import XXX from &#39;./a.js&#39;
import { XXX } from &#39;./a.js&#39;
// 导出模块 API
export function a() {}
export default function() {}</code></pre>
<h3 id="私有方法和私有属性（阿里一面）"><a href="#私有方法和私有属性（阿里一面）" class="headerlink" title="私有方法和私有属性（阿里一面）"></a>私有方法和私有属性（阿里一面）</h3><p><a href="https://es6.ruanyifeng.com/?search=%E7%A7%81%E6%9C%89&x=0&y=0#docs/class#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">阮老师 | ES6入门</a></p>
<h4 id="现有的解决方案"><a href="#现有的解决方案" class="headerlink" title="现有的解决方案"></a>现有的解决方案</h4><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别，即在函数名或属性名前加<code>_</code>，但这并不安全，只是一种团队规范。</p>
<p>另一种方法就是索性<strong>将私有方法移出类，放到模块里</strong>，因为模块内部的所有方法都是对外可见的。</p>
<pre><code class="js">class Widget {
  foo (baz) {
    bar.call(this, baz);
  }

  // ...
}

function bar(baz) {
  return this.snaf = baz;
}</code></pre>
<p>上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p>
<p>还有一种方法是利用<strong>Symbol值的唯一性</strong>，将私有方法的名字命名为一个Symbol值。</p>
<pre><code class="js">const bar = Symbol(&#39;bar&#39;);
const snaf = Symbol(&#39;snaf&#39;);

export default class myClass{

  // 公有方法
  foo(baz) {
    this[bar](baz);
  }

  // 私有方法
  [bar](baz) {
    return this[snaf] = baz;
  }

  // ...
};</code></pre>
<p>上面代码中，bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，Reflect.ownKeys()依然可以拿到它们。</p>
<pre><code class="js">const inst = new myClass();

Reflect.ownKeys(myClass.prototype)
// [ &#39;constructor&#39;, &#39;foo&#39;, Symbol(bar) ]</code></pre>
<h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">Proxy</a></h3><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre><code class="js">var obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`);
    return Reflect.set(target, key, value, receiver);
  }
});</code></pre>
<p>Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li>get(target, propKey, receiver)<ul>
<li>拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li>
</ul>
</li>
<li>set(target, propKey, value, receiver)<ul>
<li>拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
</ul>
</li>
<li>has(target, propKey)<ul>
<li>拦截propKey in proxy的操作，返回一个布尔值。</li>
</ul>
</li>
<li>deleteProperty(target, propKey)<ul>
<li>拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
</ul>
</li>
<li>ownKeys(target)<ul>
<li>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
</ul>
</li>
<li>getOwnPropertyDescriptor(target, propKey)<ul>
<li>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
</ul>
</li>
<li>defineProperty(target, propKey, propDesc)<ul>
<li>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
</ul>
</li>
<li>preventExtensions(target)<ul>
<li>拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
</ul>
</li>
<li>getPrototypeOf(target)<ul>
<li>拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
</ul>
</li>
<li>isExtensible(target)<ul>
<li>拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
</ul>
</li>
<li>setPrototypeOf(target, proto)<ul>
<li>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
</ul>
</li>
<li>apply(target, object, args)<ul>
<li>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
</ul>
</li>
<li>construct(target, args)<ul>
<li>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ul>
</li>
</ul>

            </div>
            <hr>
            <div>
              <p>
                
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/uncategorized/JS%E5%9F%BA%E7%A1%80/node%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">JS基础/node事件轮询</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/uncategorized/JS%E5%9F%BA%E7%A1%80/DOM/">
                        <span class="hidden-mobile">JS基础/DOM</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>








<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').each(function () {
        const pre = $(this);
        if (pre.find('code.mermaid').length > 0) {
          return;
        }
        pre.addClass('prettyprint  linenums');
      });
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "JS基础/ES6&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-Epsilon2.1"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
