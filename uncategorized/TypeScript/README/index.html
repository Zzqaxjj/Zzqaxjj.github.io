<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="学习总结知识">
  <meta name="author" content="张振淇">
  <meta name="keywords" content="">
  <title>TypeScript/README - 我的学习博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>我的学习博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期六, 四月 4日 2020, 6:32 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    3.5k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                    
                    
                    41
                     分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持。</p>
<p>TypeScript 只会进行静态检查，编译为 js 之后，并没有什么检查的代码被插入进来。如果编译时发现有错误，就会报错，但还是会生成编译结果。</p>
<h3 id="TS优势"><a href="#TS优势" class="headerlink" title="TS优势"></a>TS优势</h3><ul>
<li>TypeScript 增加了代码的可读性和可维护性<ul>
<li>类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了</li>
<li>可以在编译阶段就发现大部分错误，这总比在运行时候出错好</li>
<li>增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</li>
</ul>
</li>
<li>TypeScript 非常包容<ul>
<li>TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可</li>
<li>即使不显式的定义类型，也能够自动做出类型推论</li>
<li>可以定义从简单到复杂的几乎一切类型</li>
<li>即使 TypeScript 编译报错，也可以生成 JavaScript 文件</li>
<li>兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取</li>
</ul>
</li>
<li>TypeScript 拥有活跃的社区<ul>
<li>大部分第三方库都有提供给 TypeScript 的类型定义文件</li>
</ul>
</li>
<li>TypeScript 的缺点<ul>
<li>有一定的学习成本</li>
<li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本</li>
<li>集成到构建流程需要一些工作量</li>
<li>可能和一些库结合的不是很完美</li>
</ul>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><code>boolean</code></li>
<li><code>number</code></li>
<li><code>string</code></li>
<li><code>undefind</code></li>
<li><code>list</code></li>
<li><code>Tuple</code><ul>
<li>合并了不同类型的对象的数组</li>
</ul>
</li>
<li><code>enum</code><ul>
<li>用于取值被限定在一定范围内的场景</li>
<li>未手动赋值的枚举项会接着上一个枚举项递增</li>
<li>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的</li>
<li>如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</li>
<li>常数枚举<ul>
<li>是使用 const enum 定义的枚举类型，不能包含计算成员</li>
</ul>
</li>
<li>外部枚举<ul>
<li>使用 declare enum 定义的枚举类型</li>
<li>外部枚举与声明语句一样，常出现在声明文件中</li>
</ul>
</li>
</ul>
</li>
<li><code>any</code><ul>
<li>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</li>
<li>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</li>
</ul>
</li>
<li><code>void</code><ul>
<li>可以用 void 表示没有任何返回值的函数</li>
<li>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null</li>
</ul>
</li>
</ul>
<h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>
<p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</p>
<p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p>
<pre><code>let myFavoriteNumber = &#39;seven&#39;;
myFavoriteNumber = 7;</code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>
<pre><code class="ts">let myFavoriteNumber: string | number;
myFavoriteNumber = &#39;seven&#39;;
myFavoriteNumber = 7;</code></pre>
<h4 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="headerlink" title="访问联合类型的属性或方法"></a>访问联合类型的属性或方法</h4><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法。</p>
<pre><code class="ts">function getLength(something: string | number): number {
    return something.length;
}
// index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.
//   Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>
<p>length 不是 string 和 number 的共有属性，只有string有，所以会报错。</p>
<p>联合类型的变量在被<strong>赋值</strong>的时候，会根据类型推论的规则推断出一个类型。推断后访问该类型没有的属性就会报错。</p>
<h3 id="对象的类型"><a href="#对象的类型" class="headerlink" title="对象的类型"></a>对象的类型</h3><p>除了可用于<a href="https://ts.xcatliu.com/advanced/class-and-interfaces.html#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">对类的一部分行为进行抽象</a>以外，也常用于对<code>对象的形状（Shape）</code>进行描述。</p>
<ul>
<li>普通接口<ul>
<li>定义的变量比接口<strong>少了</strong>或是<strong>多了</strong>一些属性是不允许的</li>
</ul>
</li>
<li>可选属性<ul>
<li>在属性后面加<code>?</code>表示该属性为可选属性</li>
</ul>
</li>
<li>任意属性<ul>
<li><code>[propName: string]: 类型;</code></li>
<li>注意：一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</li>
</ul>
</li>
<li>只读属性<ul>
<li>在属性名前加<code>readonly</code>，则该属性只能在创建的时候被赋值</li>
</ul>
</li>
</ul>
<h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><ul>
<li><p>类型 + 方括号 表示法</p>
<ul>
<li><code>let fibonacci: number[] = [1, 1, 2, 3, 5];</code></li>
<li><code>let fibonacci: (number | string)[] = [1, &#39;1&#39;, 2, 3, 5];</code></li>
</ul>
</li>
<li><p>数组泛型<code>Array&lt;elemType&gt;</code> 来表示数组</p>
<ul>
<li>let fibonacci: Array<number> = [1, 1, 2, 3, 5];</li>
</ul>
</li>
<li><p>在数组中的<code>any</code></p>
<ul>
<li><code>let list: any[] = [&#39;yaoyao&#39;, 25, { a: &#39;str&#39; }];</code></li>
</ul>
</li>
<li><p>用接口表示数组</p>
<ul>
<li>NumberArray 表示：只要 index 的类型是 number，那么值的类型必须是 number<pre><code class="ts">interface NumberArray {</code></pre>
</li>
</ul>
<p> [index: number]: number;<br>}<br>let fibonacci: NumberArray = [1, 1, 2, 3, 5];</p>
<pre><code></code></pre></li>
<li><p>类数组</p>
<ul>
<li>类数组（Array-like Object）不是数组类型，比如 <code>arguments</code></li>
<li>事实上常见的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection<pre><code class="ts">function sum() {
let args: IArguments = arguments;
}</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><ul>
<li><p>声明式</p>
<ul>
<li>一个函数有输入和输出，需要把输入和输出都考虑到。并且输入多余的（或者少于要求的）参数，是不被允许的<pre><code class="ts">function sum(x:number, y:number): number {
return x + y;
}</code></pre>
</li>
</ul>
</li>
<li><p>函数表达式</p>
<ul>
<li>TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 不要和ES6的箭头函数搞混了<pre><code class="ts">let mySum : (x: number, y: number) =&gt; number
= function (x: number, y: number): number {
return x + y;
};</code></pre>
</li>
</ul>
</li>
<li><p>用接口定义函数的形状</p>
<pre><code class="ts">interface SearchFunc {
(source: string, subString: string): boolean;
}
let mySerch : SearchFunc
= function(source: string, subString: string): boolean {
 return source.search(subString) !== -1;
};</code></pre>
</li>
<li><p>可选参数</p>
<ul>
<li>用<code>?</code>表示可选的参数<pre><code class="ts">function buildName(firstName: string, lastName?: string) {
if (lastName) {
   return firstName + &#39; &#39; + lastName;
} else {
   return firstName;
}
}</code></pre>
</li>
</ul>
</li>
<li><p>参数默认值</p>
<ul>
<li>TypeScript 会将添加了默认值的参数识别为可选参数<pre><code class="ts">function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {
return firstName + &#39; &#39; + lastName;
}</code></pre>
</li>
</ul>
</li>
<li><p>剩余参数</p>
<ul>
<li>事实上，剩余参数是一个数组。所以我们可以用数组的类型来定义它<pre><code class="ts">function push(array: any[], ...items: any[]) {
items.forEach(function(item) {
   array.push(item);
});
}
let a = [];
push(a, 1, 2, 3);</code></pre>
</li>
</ul>
</li>
<li><p>重载</p>
<ul>
<li>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理</li>
<li>通常做法：重复定义了多次函数，前几次都是函数定义，最后一次是函数实现。</li>
<li>TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。<pre><code class="ts">function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string {
if (typeof x === &#39;number&#39;) {
   return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));
} else if (typeof x === &#39;string&#39;) {
   return x.split(&#39;&#39;).reverse().join(&#39;&#39;);
}
}</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p>
<p>语法： <code>&lt;类型&gt;值</code> 或 <code>值 as 类型</code>，在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种。</p>
<pre><code class="ts">// 获取长度例子：
function getLength(something: string|number): number {
  if((&lt;string&gt;something).length) {  //可能是number，所以断言
    return (&lt;string&gt;something).length
  } else {
    return something.toString().length;
  }
}</code></pre>
<p>注意： 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</p>
<h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><p>通常我们会把声明语句放到一个单独的文件中，声明文件必需以 <code>.d.ts</code> 为后缀。</p>
<pre><code class="ts">// src/jQuery.d.ts
declare var jQuery: (selector: string) =&gt; any;</code></pre>
<p>更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p>
<p>@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：<code>npm install @types/jquery --save-dev</code></p>
<p>可以在<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">这个页面</a>搜索你需要的声明文件。</p>
<h4 id="书写声明文件"><a href="#书写声明文件" class="headerlink" title="书写声明文件"></a>书写声明文件</h4><ul>
<li>以<code>npm install @types/xxx --save-dev</code>安装的，则不需要任何配置。</li>
<li>如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 src 目录下</li>
<li>如果没有生效，可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件</li>
<li>语法<ul>
<li>declare var/let/const <ul>
<li>声明全局变量，一般用const</li>
</ul>
</li>
<li>declare function <ul>
<li>声明全局方法的<strong>类型</strong></li>
</ul>
</li>
<li>declare class <ul>
<li>声明全局类，只定义不实现</li>
</ul>
</li>
<li>declare enum <ul>
<li>声明全局枚举类型</li>
</ul>
</li>
<li>declare namespace <ul>
<li>它用来表示全局变量是一个对象，包含很多子属性。</li>
<li>可嵌套定义</li>
</ul>
</li>
<li>interface 和 type<ul>
<li>声明全局类型</li>
</ul>
</li>
</ul>
</li>
<li>防止命名冲突<ul>
<li>暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故应该将他们放到 namespace 下。在使用这个 interface 的时候，也应该加上 命名空间 前缀了</li>
</ul>
</li>
<li>npm 包<ul>
<li>已存在配置<ul>
<li>与该 npm 包绑定在一起。</li>
<li>发布到了 <code>@types</code> 里。</li>
</ul>
</li>
<li>自己为它写声明文件<ul>
<li>创建一个 types 目录，专门用来管理自己写的声明文件，将 foo 的声明文件放到 types/foo/index.d.ts 中。</li>
</ul>
</li>
<li><code>export</code><ul>
<li>在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p>
<p>在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库</a>的定义文件中定义了JS的内置对象。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名用来给一个类型起个新名字。类型别名常用于联合类型。</p>
<h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>类型别名与字符串字面量类型都是使用 type 进行定义。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</li>
<li>对象（Object）：类的实例，通过 new 生成</li>
<li>面向对象（OOP）的三大特性：封装、继承、多态</li>
<li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li>
<li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>
<li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。</li>
<li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li>
<li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法</li>
<li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>
<li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li>
</ul>
<h4 id="TS中的类"><a href="#TS中的类" class="headerlink" title="TS中的类"></a>TS中的类</h4><ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>
<ul>
<li>抽象类是不允许被实例化</li>
<li>抽象类中的抽象方法必须被子类实现</li>
</ul>
<h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><p>有时候<strong>不同类之间可以有一些共有的特性，这时候就把特性提取成接口（interfaces）</strong>，用 implements 关键字来实现。 </p>
<ul>
<li>一个类可实现多个接口</li>
<li>接口与接口之间可以是继承关系</li>
<li>接口也可以继承类</li>
<li>混合类型（有时候，一个函数还可以有自己的属性和方法）</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用了。</p>
<pre><code class="ts">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {
    let result: T[] = [];
    for (let i = 0; i &lt; length; i++) {
        result[i] = value;
    }
    return result;
}
createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre>
<p>定义泛型的时候，可以一次定义多个类型参数：</p>
<pre><code class="ts">function swap&lt;T, U&gt; (tuple:[T, U]) : [U, T] {
  return [tuple[1], tuple[0]];
}

swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]</code></pre>
<ul>
<li>泛型约束<ul>
<li>即函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法，这时，我们可以对泛型进行约束。<strong>即让泛型继承一个接口</strong></li>
<li>多个类型参数之间也可以相互约束，如下例：其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。</li>
</ul>
</li>
<li>泛型接口<ul>
<li>在使用泛型接口的时候，需要定义泛型的类型</li>
</ul>
</li>
<li>泛型类</li>
<li>泛型参数的默认类型<ul>
<li>当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</li>
</ul>
</li>
</ul>
<h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型。</p>
<pre><code class="ts">interface Alarm {
    price: number;
    alert(s: string): string;
}
interface Alarm {
    weight: number;
    alert(s: string, n: number): string;
}</code></pre>
<p>相当于：</p>
<pre><code class="ts">interface Alarm {
    price: number;
    weight: number;
    alert(s: string): string;
    alert(s: string, n: number): string;
}</code></pre>

            </div>
            <hr>
            <div>
              <p>
                
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/uncategorized/Vue/README/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">Vue/README</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/uncategorized/TypeScript/interface%E4%B8%8Etype/">
                        <span class="hidden-mobile">TypeScript/interface与type</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>








<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').each(function () {
        const pre = $(this);
        if (pre.find('code.mermaid').length > 0) {
          return;
        }
        pre.addClass('prettyprint  linenums');
      });
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "TypeScript/README&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/nito.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
